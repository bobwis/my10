package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class adcch001c_template
{
  protected static String nl;
  public static synchronized adcch001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    adcch001c_template result = new adcch001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[ADCCH001.c]*/" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without**" + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4500 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : DAVE App Developer                                              **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : 8 August 2012                                        **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** PM           DAVE App Developer                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @file ADCCH001.c" + NL + " *" + NL + " * @brief   This file contains the implementation of all public and private functions of the" + NL + " *          ADCCH001 App.   " + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_2 = NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "" + NL + "" + NL + "" + NL + "/*************************************************************************" + NL + " *                 Private Function declarations" + NL + " ***************************************************************************/" + NL + "" + NL + "/**" + NL + " * @brief This function initializes ADC channel and result registers \\n" + NL + " * @param[in] HandlePtr Handle of the ADCCH001 App" + NL + " * @return void" + NL + " * <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " */" + NL + "static void ADCCH001_lInit(const ADCCH001_HandleType* HandlePtr);" + NL + "" + NL + "" + NL + "/********************************************************************************" + NL + " *                 LOCAL FUNCTIONS DEFINITIONS" + NL + " **********************************************************************************/" + NL + "/**" + NL + " * This function initializes ADC channel and result registers as per UI configurations. " + NL + " */" + NL + "static void ADCCH001_lInit(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;" + NL + "  uint8_t Index = (uint8_t)0;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State == ADCCH001_UNINITIALIZED))" + NL + "  {" + NL + "    /* Priority Channel */" + NL + "    WR_REG( GroupPtr->CHASS, " + NL + "            ((uint32_t)0x01 << HandlePtr->kChannelNo)," + NL + "            HandlePtr->kChannelNo," + NL + "            (uint32_t)HandlePtr->kPrioChannel" + NL + "           );    " + NL + "    /* Input class */" + NL + "    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo]," + NL + "            VADC_G_CHCTR_ICLSEL_Msk," + NL + "            VADC_G_CHCTR_ICLSEL_Pos," + NL + "            (uint32_t)HandlePtr->kIpClassSel" + NL + "           );" + NL + "    /* Channel event mode */" + NL + "    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo]," + NL + "            VADC_G_CHCTR_CHEVMODE_Msk," + NL + "            VADC_G_CHCTR_CHEVMODE_Pos," + NL + "            (uint32_t)HandlePtr->kChEvtmode" + NL + "           );    " + NL + "    /* reference input selection */" + NL + "    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo]," + NL + "            VADC_G_CHCTR_REFSEL_Msk," + NL + "            VADC_G_CHCTR_REFSEL_Pos," + NL + "            (uint32_t)HandlePtr->kRefInput" + NL + "           );" + NL + "    /* XMC4500: EMUXCSS is not present.  */" + NL + "    if(HandlePtr->kExtMuxControl == (uint8_t)1)" + NL + "    {" + NL + "      /*WR_REG( GroupPtr->EMUXCTR," + NL + "              VADC_G_EMUXCTR_EMXCSS_Msk," + NL + "              VADC_G_EMUXCTR_EMXCSS_Pos," + NL + "              (0x01)" + NL + "             );     */" + NL + "      WR_REG( GroupPtr->EMUXCTR," + NL + "              VADC_G_EMUXCTR_EMUXCH_Msk," + NL + "              VADC_G_EMUXCTR_EMUXCH_Pos," + NL + "              (uint32_t)(HandlePtr->kChannelNo)" + NL + "             );  " + NL + "    }" + NL + "    /*Configure result registers if Fast Compare Mode is not selected */" + NL + "    if(HandlePtr->kCompareMode == (uint8_t)0)" + NL + "    {" + NL + "      /* Upper and Lower Boundary Select */ " + NL + "      WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo]," + NL + "              ((uint32_t)0xF << VADC_G_CHCTR_BNDSELL_Pos)," + NL + "              VADC_G_CHCTR_BNDSELL_Pos," + NL + "              (uint32_t)HandlePtr->kBoundarySel" + NL + "             ); " + NL + "      /*Result Alignment */" + NL + "      WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo]," + NL + "              VADC_G_CHCTR_RESPOS_Msk," + NL + "              VADC_G_CHCTR_RESPOS_Pos," + NL + "              (uint32_t)HandlePtr->kResultControl" + NL + "             );" + NL + "      /* Data modification mode */" + NL + "      WR_REG( GroupPtr->RCR[HandlePtr->kStartResultRegNo]," + NL + "              ((uint32_t)0x3F << VADC_G_RCR_DRCTR_Pos)," + NL + "              VADC_G_RCR_DRCTR_Pos," + NL + "              (uint32_t)HandlePtr->kDataModification" + NL + "             );" + NL + "      /* Wait for read mode */" + NL + "      WR_REG( GroupPtr->RCR[HandlePtr->kStartResultRegNo]," + NL + "              VADC_G_RCR_WFR_Msk," + NL + "              VADC_G_RCR_WFR_Pos," + NL + "              (uint32_t)HandlePtr->kWaitForRead" + NL + "             );" + NL + "  /* result interrupt */    " + NL + "      WR_REG( GroupPtr->RCR[HandlePtr->kEndResultRegNo]," + NL + "              VADC_G_RCR_SRGEN_Msk," + NL + "              VADC_G_RCR_SRGEN_Pos," + NL + "              (uint32_t)HandlePtr->kResultEvtEnable" + NL + "             );" + NL + "  /* Setting FEN bit in all result registers except start result register */    " + NL + "      if(HandlePtr->kFIFOEnable == (uint8_t)1)" + NL + "      {" + NL + "        for(Index = (HandlePtr->kEndResultRegNo); Index <= (HandlePtr->kStartResultRegNo -(uint8_t)1); Index++)" + NL + "        {" + NL + "           WR_REG( GroupPtr->RCR[Index]," + NL + "                   VADC_G_RCR_FEN_Msk," + NL + "                   VADC_G_RCR_FEN_Pos," + NL + "                   (uint32_t)0x1" + NL + "                 );" + NL + "        }" + NL + "      }" + NL + "    }" + NL + "/* Write compare value in the result register for the Fast Compare Mode */    " + NL + "    else" + NL + "    {" + NL + "      WR_REG( GroupPtr->RES[HandlePtr->kStartResultRegNo]," + NL + "              VADC_G_RES_RESULT_Msk," + NL + "              VADC_G_RES_RESULT_Pos," + NL + "              (uint32_t)(HandlePtr->kResultCompVal)" + NL + "            );      " + NL + "    }" + NL + "    /* Set boundary flag for all the advanced result registers */" + NL + "    if(HandlePtr->kBoundaryFlagEnable == (uint8_t)1)" + NL + "    {" + NL + "      WR_REG( GroupPtr->BFL," + NL + "              ((uint32_t)0x01 << (HandlePtr->kStartResultRegNo + (uint8_t)16))," + NL + "              (HandlePtr->kStartResultRegNo + (uint8_t)16)," + NL + "              (uint32_t)(0x1)" + NL + "            );" + NL + "    }" + NL + "    /* change the state to the Initialized */" + NL + "    HandlePtr->DynamicHandlePtr->State = ADCCH001_INITIALIZED;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_OPERATION_NOT_ALLOWED, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "}" + NL + "" + NL + "/******************************************************************************************************" + NL + " *                 API DEFINITION" + NL + " *******************************************************************************************************/" + NL + "" + NL + "/**" + NL + " * This function initializes all instances of the ADCCH001 App" + NL + " */" + NL + "void ADCCH001_Init(void)" + NL + "{" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);  " + NL + "  ADCGLOB001_Init();";
  protected final String TEXT_3 = NL + "/* Call the local function with the handle pointer for each instance */" + NL + "  ADCCH001_lInit(&ADCCH001_Handle";
  protected final String TEXT_4 = ");";
  protected final String TEXT_5 = NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "}" + NL + "" + NL + "/**" + NL + " * This function resets all the channel and result registers. " + NL + " */" + NL + "status_t ADCCH001_Deinit(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;" + NL + "  uint8_t Index;" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State == ADCCH001_INITIALIZED))" + NL + "  {" + NL + "    GroupPtr->CHCTR[HandlePtr->kChannelNo] = (uint32_t)0x00;" + NL + "    WR_REG( GroupPtr->EMUXCTR, " + NL + "            VADC_G_EMUXCTR_EMUXCH_Msk," + NL + "            VADC_G_EMUXCTR_EMUXCH_Pos," + NL + "            (uint32_t)0x00" + NL + "          );" + NL + "  " + NL + "    for(Index = (HandlePtr->kEndResultRegNo); Index <= (HandlePtr->kStartResultRegNo); Index++)" + NL + "    {" + NL + "      GroupPtr->RCR[Index] = (uint32_t)0x00;" + NL + "      GroupPtr->RES[Index] = (uint32_t)0x00;" + NL + "    }" + NL + "    if(HandlePtr->kBoundaryFlagEnable == (uint8_t)1)" + NL + "    {" + NL + "      CLR_BIT(GroupPtr->BFL, (((uint32_t)16 + (uint32_t)HandlePtr->kStartResultRegNo)));" + NL + "    }" + NL + "    HandlePtr->DynamicHandlePtr->State = ADCCH001_UNINITIALIZED;" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function assigns the alias channel number" + NL + " */" + NL + "status_t ADCCH001_SetAlias(const ADCCH001_HandleType* HandlePtr, uint8_t ChannelNo)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((ChannelNo > (uint8_t)7))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      ((HandlePtr->kChannelNo == (uint8_t)0) || (HandlePtr->kChannelNo == (uint8_t)1)))" + NL + "  {" + NL + "    HandlePtr->ADCGrPtr->ALIAS &= ~((uint32_t)0x1F << (HandlePtr->kChannelNo * (uint8_t)8));" + NL + "    HandlePtr->ADCGrPtr->ALIAS |= ((uint32_t)ChannelNo << (HandlePtr->kChannelNo * (uint8_t)8));" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);  " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * This function enables the boundary flag for result register 0, 1, 2 or 3." + NL + " */" + NL + "status_t ADCCH001_EnableBoundaryFlag(const ADCCH001_HandleType* HandlePtr, uint8_t FlagNo)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((FlagNo > (uint8_t)3))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))" + NL + "  {" + NL + "    SET_BIT(HandlePtr->ADCGrPtr->BFL, ((uint32_t)FlagNo + (uint32_t)16));" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);  " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function disables the boundary flag for result register 0, 1, 2 or 3." + NL + " */" + NL + "status_t ADCCH001_DisableBoundaryFlag(const ADCCH001_HandleType* HandlePtr, uint8_t FlagNo)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  " + NL + "  if((FlagNo > (uint8_t)3))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))" + NL + "  {" + NL + "    CLR_BIT(HandlePtr->ADCGrPtr->BFL, ((uint32_t)FlagNo + (uint32_t)16));" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);  " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;  " + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function selects the input class for the channel. " + NL + " */" + NL + "status_t ADCCH001_SelectInputClass(const ADCCH001_HandleType* HandlePtr, ADCCH001_InputClassType Class)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  " + NL + "  if((Class > (ADCCH001_InputClassType)3))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }  " + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) && " + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "            VADC_G_CHCTR_ICLSEL_Msk," + NL + "            VADC_G_CHCTR_ICLSEL_Pos," + NL + "            (uint32_t)Class" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function configures the channel event mode to generate the channel interrupt" + NL + " */" + NL + "status_t ADCCH001_SelectChEvtMode(const ADCCH001_HandleType* HandlePtr, ADCCH001_ChanEvtModeType Mode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((Mode > (ADCCH001_ChanEvtModeType)3))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }   " + NL + "  else if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)" + NL + "  {" + NL + "    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "            VADC_G_CHCTR_CHEVMODE_Msk," + NL + "            VADC_G_CHCTR_CHEVMODE_Pos," + NL + "            (uint32_t)Mode" + NL + "          );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function selects the upper boundary for limit checking function. " + NL + " * This is the upper delta for Fast Compare Mode." + NL + " */" + NL + "status_t ADCCH001_SelectUpperBoundary(const ADCCH001_HandleType* HandlePtr, ADCCH001_BoundaryType UBoundary)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((UBoundary > (ADCCH001_BoundaryType)3))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }   " + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "            VADC_G_CHCTR_BNDSELU_Msk," + NL + "            VADC_G_CHCTR_BNDSELU_Pos," + NL + "            (uint32_t)UBoundary" + NL + "          );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT); " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function selects the lower boundary for limit checking function. " + NL + " * This is the lower delta for Fast Compare Mode." + NL + " */" + NL + "status_t ADCCH001_SelectLowerBoundary(const ADCCH001_HandleType* HandlePtr, ADCCH001_BoundaryType LBoundary)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((LBoundary > (ADCCH001_BoundaryType)3))" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    " + NL + "  }   " + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "            VADC_G_CHCTR_BNDSELL_Msk," + NL + "            VADC_G_CHCTR_BNDSELL_Pos," + NL + "            (uint32_t)LBoundary" + NL + "          );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function returns the result of the normal mode ADC conversion. " + NL + " */" + NL + "status_t ADCCH001_GetResult(const ADCCH001_HandleType* HandlePtr, uint16_t* ResultPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;" + NL + "  uint32_t TempResult;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];" + NL + "    /* If valid flag is set */" + NL + "    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)" + NL + "    {" + NL + "      HandlePtr->DynamicHandlePtr->Result = " + NL + "          (uint16_t)(TempResult & VADC_G_RES_RESULT_Msk);" + NL + "      *ResultPtr = HandlePtr->DynamicHandlePtr->Result;" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    /* If data is old, then send error as invalid result */" + NL + "    else" + NL + "    {" + NL + "      *ResultPtr = HandlePtr->DynamicHandlePtr->Result;" + NL + "      Status = (uint32_t)ADCCH001_INVALID_RESULT;" + NL + "      ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function returns the result of the fast compare ADC conversion. " + NL + " */" + NL + "status_t ADCCH001_GetFastCompareResult(const ADCCH001_HandleType* HandlePtr, uint8_t* ResultPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;" + NL + "  uint32_t TempResult;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)1))" + NL + "  {" + NL + "    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];" + NL + "    /* If valid flag is set */" + NL + "    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)" + NL + "    {" + NL + "      HandlePtr->DynamicHandlePtr->FastCompResult = (uint8_t)RD_REG(TempResult, " + NL + "                                                    VADC_G_RES_FCR_Msk," + NL + "                                                    VADC_G_RES_FCR_Pos" + NL + "                                                   );" + NL + "      *ResultPtr = HandlePtr->DynamicHandlePtr->FastCompResult;" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    /* If data is old, then send error as invalid result */" + NL + "    else" + NL + "    {" + NL + "      *ResultPtr = HandlePtr->DynamicHandlePtr->FastCompResult;" + NL + "      Status = (uint32_t)ADCCH001_INVALID_RESULT;" + NL + "      ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function sets the compare value for the Fast Compare Mode. " + NL + " * Compare value should 10-bit value." + NL + " */" + NL + "status_t ADCCH001_SetCompareValue(const ADCCH001_HandleType* HandlePtr, uint16_t CompVal)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if(CompVal > (uint16_t)0x3FF)" + NL + "  {" + NL + "    Status = (uint32_t)ADCCH001_INVALID_PARAM;" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL); " + NL + "  }" + NL + "  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      ((HandlePtr->kCompareMode == (uint8_t)1)))" + NL + "  {" + NL + "    WR_REG( HandlePtr->ADCGrPtr->RES[HandlePtr->kStartResultRegNo], " + NL + "            VADC_G_RES_RESULT_Msk," + NL + "            VADC_G_RES_RESULT_Pos," + NL + "            ((uint32_t)CompVal << (uint8_t)2)" + NL + "          );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function enables the channel as a priority channel. " + NL + " */" + NL + "status_t ADCCH001_EnablePriorityChannel(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))" + NL + "  {" + NL + "    SET_BIT(HandlePtr->ADCGrPtr->CHASS, (HandlePtr->kChannelNo));" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;  " + NL + "}" + NL + "" + NL + "/**" + NL + " * This function disables the channel as a priority channel. " + NL + " */" + NL + "status_t ADCCH001_DisablePriorityChannel(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))" + NL + "  {" + NL;
  protected final String TEXT_6 = "    CLR_BIT(HandlePtr->ADCGrPtr->CHASS, (HandlePtr->kChannelNo));  " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;  " + NL + "}" + NL + "" + NL + "/**" + NL + " * This function enables the  Result event. " + NL + " */" + NL + "status_t ADCCH001_EnableResultEvt(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    SET_BIT( HandlePtr->ADCGrPtr->RCR[HandlePtr->kEndResultRegNo]," + NL + "             VADC_G_RCR_SRGEN_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function disables the  Result event. " + NL + " */" + NL + "status_t ADCCH001_DisableResultEvt(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    CLR_BIT( HandlePtr->ADCGrPtr->RCR[HandlePtr->kEndResultRegNo]," + NL + "             VADC_G_RCR_SRGEN_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This function checks whether Result event flag is set." + NL + " */" + NL + "status_t ADCCH001_GetResultEvtFlag(const ADCCH001_HandleType* HandlePtr, uint8_t* EvtStatus)" + NL + "{" + NL + "" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    *EvtStatus = (uint8_t)RD_REG( HandlePtr->ADCGrPtr->REFLAG, " + NL + "                        ((uint32_t)0x01 << HandlePtr->kEndResultRegNo), " + NL + "                        (uint32_t)HandlePtr->kEndResultRegNo" + NL + "                 );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function checks whether Channel event flag is set." + NL + " */" + NL + "status_t ADCCH001_GetChannelEvtFlag(const ADCCH001_HandleType* HandlePtr, uint8_t* EvtStatus)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)" + NL + "  {" + NL + "    *EvtStatus = (uint8_t)RD_REG(HandlePtr->ADCGrPtr->CEFLAG, " + NL + "                        ((uint32_t)0x01 << HandlePtr->kChannelNo), " + NL + "                        (uint32_t)HandlePtr->kChannelNo" + NL + "                 );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will set the result event flag through software." + NL + " */" + NL + "status_t ADCCH001_SetResultEvtFlag(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    SET_BIT( HandlePtr->ADCGrPtr->REFLAG, " + NL + "             HandlePtr->kEndResultRegNo" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will set the channel event flagv through software" + NL + " */" + NL + "status_t ADCCH001_SetChannelEvtFlag(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)" + NL + "  {" + NL + "    SET_BIT( HandlePtr->ADCGrPtr->CEFLAG, " + NL + "             HandlePtr->kChannelNo" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will clear the pending result event flag" + NL + " */" + NL + "status_t ADCCH001_ClearResultEvtFlag(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    SET_BIT( HandlePtr->ADCGrPtr->REFCLR, " + NL + "             HandlePtr->kEndResultRegNo" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will clear the pending channel event flag" + NL + " */" + NL + "status_t ADCCH001_ClearChannelEvtFlag(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)" + NL + "  {" + NL + "    SET_BIT( HandlePtr->ADCGrPtr->CEFCLR, " + NL + "             HandlePtr->kChannelNo" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function slects the Broken Wire Detection Channel. " + NL + " */" + NL + "status_t ADCCH001_SetBWDChannel(const ADCCH001_HandleType* HandlePtr, ADCCH001_BWDType BWDChannel)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "            VADC_G_CHCTR_BWDCH_Msk," + NL + "            VADC_G_CHCTR_BWDCH_Pos," + NL + "            (uint32_t)BWDChannel" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will enable the Broken Wire Detection feature." + NL + " */" + NL + "status_t ADCCH001_EnableBWD(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    SET_BIT( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "             VADC_G_CHCTR_BWDEN_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will disable the Broken Wire Detection feature." + NL + " */" + NL + "status_t ADCCH001_DisableBWD(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "    CLR_BIT( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], " + NL + "             VADC_G_CHCTR_BWDEN_Pos" + NL + "           );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * This will enable wait for read mode of the result register" + NL + " */" + NL + "status_t ADCCH001_EnableWaitForRead(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "      WR_REG( HandlePtr->ADCGrPtr->RCR[HandlePtr->kStartResultRegNo]," + NL + "              VADC_G_RCR_WFR_Msk," + NL + "              VADC_G_RCR_WFR_Pos," + NL + "              (uint32_t)0x1" + NL + "             );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * This will disable wait for read mode of the result register" + NL + " */" + NL + "status_t ADCCH001_DisableWaitForRead(const ADCCH001_HandleType* HandlePtr)" + NL + "{" + NL + "" + NL + "  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;" + NL + "  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);" + NL + "" + NL + "  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&" + NL + "      (HandlePtr->kCompareMode == (uint8_t)0))" + NL + "  {" + NL + "      WR_REG( HandlePtr->ADCGrPtr->RCR[HandlePtr->kStartResultRegNo]," + NL + "              VADC_G_RCR_WFR_Msk," + NL + "              VADC_G_RCR_WFR_Pos," + NL + "              (uint32_t)0x0" + NL + "             );" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    " + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  " + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL;
  protected final String TEXT_7 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/ADCCH001/"; 
     String appInst  = null; 
    stringBuffer.append(TEXT_2);
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/ADCCH001/"));
for (String appIns : appsList ) {
appInst = appIns.substring(appIns.lastIndexOf("/")+1);
    stringBuffer.append(TEXT_3);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_4);
    }
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(TEXT_7);
    return stringBuffer.toString();
  }
}
