package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class sdmmc003h_template
{
  protected static String nl;
  public static synchronized sdmmc003h_template create(String lineSeparator)
  {
    nl = lineSeparator;
    sdmmc003h_template result = new sdmmc003h_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[SDMMC003.h]*/" + NL + "" + NL + "/* THIS FILE IS PROVIDED BY DAVE." + NL + " * THIS FILE IS GENERATED." + NL + " */" + NL + " " + NL + "/*******************************************************************************" + NL + " *" + NL + " * Copyright (C) 2011 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with" + NL + " * Infineon's microcontrollers." + NL + " * This file can be freely distributed within development tools that are" + NL + " * supporting such microcontrollers." + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL," + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Oct 1, 2012                                            **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/" + NL;
  protected final String TEXT_2 = NL + NL + NL + "#ifndef SDMMC003_H_" + NL + "#define SDMMC003_H_" + NL + "" + NL + "" + NL + "/**" + NL + " * @file SDMMC003.h" + NL + " * " + NL + " * @App Version SDMMC003 <";
  protected final String TEXT_3 = ">" + NL + " *" + NL + " * @brief  This file contains all public data structures,enums and function" + NL + " *          prototypes for Sdmmc LLD App." + NL + " *" + NL + " * Revision History" + NL + " * 22 March 2012  v1.0.0    Initial version" + NL + " * 3 Aug 2012     v1.0.12   Erase optimizations introduced." + NL + " *                          Make File System(MKFS) through software issue fixed. " + NL + " * 1 Oct 2012     v1.0.14   Delays reduced." + NL + " *                          Removed RTOS specific code. " + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                INCLUDE FILES                               **" + NL + " *****************************************************************************/" + NL + "#include <String.h>" + NL + "#include <DAVE3.h>" + NL + "#include \"../../inc/SDMMC003/SDMMC003_Conf.h\"" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "#define SDMMC003_COMMON_COMMAND(CmdIndex)   SDMMC003_Command[SDMMC003_SDHashTable[CmdIndex]]" + NL + "#define SDMMC003_SD_COMMAND(CmdIndex)       SDMMC003_Command[SDMMC003_SDHashTable[CmdIndex]]" + NL + "#define SDMMC003_MMC_COMMAND(CmdIndex)      SDMMC003_Command[SDMMC003_MMCHashTable[CmdIndex]]" + NL + "" + NL + "" + NL + "/**" + NL + " * @ingroup SDMMC003_publicparam" + NL + " * @{" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                      Global Macro Definitions                              **" + NL + "*******************************************************************************/" + NL + "/* Command Indexes  */" + NL + "#define SDMMC003_GO_IDLE_STATE                    0x00    /* CMD0     */" + NL + "#define SDMMC003_MMC_SEND_OP_COND                 0x01    /*MMC CMD1  */" + NL + "#define SDMMC003_ALL_SEND_CID                     0x02    /* CMD2     */" + NL + "#define SDMMC003_SEND_RELATIVE_ADDR               0x03    /* CMD3     */" + NL + "#define SDMMC003_SET_DSR                          0x04    /* CMD4     */" + NL + "#define SDMMC003_MMC_SLEEP_AWAKE                  0x05    /*MMC CMD5  */" + NL + "#define SDMMC003_SWITCH_FUNC                      0x06    /* CMD6     */" + NL + "#define SDMMC003_SELECT_DESELECT_CARD             0x07    /* CMD7     */" + NL + "#define SDMMC003_SD_SEND_IF_COND                  0x08    /*SD CMD8   */" + NL + "#define SDMMC003_MMC_SEND_EXT_CSD                 0x08    /* MMC CMD8 */" + NL + "#define SDMMC003_SEND_CSD                         0x09    /* CMD9     */" + NL + "#define SDMMC003_SEND_CID                         0x0A    /* CMD10    */" + NL + "#define SDMMC003_STOP_TRANSMISSION                0x0C    /* CMD12    */" + NL + "#define SDMMC003_SEND_STATUS                      0x0D    /* CMD13    */" + NL + "#define SDMMC003_GO_INACTIVE_STATE                0x0F    /* CMD15    */" + NL + "#define SDMMC003_SET_BLOCKLEN                     0x10    /* CMD16    */" + NL + "#define SDMMC003_READ_SINGLE_BLOCK                0x11    /* CMD17    */" + NL + "#define SDMMC003_READ_MULTIPLE_BLOCK              0x12    /* CMD18    */" + NL + "#define SDMMC003_WRITE_BLOCK                      0x18    /*CMD24     */" + NL + "#define SDMMC003_WRITE_MULTIPLE_BLOCK             0x19    /* CMD25    */" + NL + "#define SDMMC003_PROGRAM_CSD                      0x1B    /* CMD27    */" + NL + "#define SDMMC003_SET_WRITE_PROT                   0x1C    /* CMD28    */" + NL + "#define SDMMC003_CLR_WRITE_PROT                   0x1D    /* CMD29    */" + NL + "#define SDMMC003_SEND_WRITE_PROT                  0x1E    /* CMD30    */" + NL + "#define SDMMC003_ERASE_WR_BLK_START               0x20    /* CMD32    */" + NL + "#define SDMMC003_ERASE_WR_BLK_END                 0x21    /* CMD33    */" + NL + "#define SDMMC003_ERASE_GROUP_START                0x23    /* CMD35    */" + NL + "#define SDMMC003_ERASE_GROUP_END                  0x24    /* CMD36    */" + NL + "#define SDMMC003_ERASE                            0x26    /* CMD38    */" + NL + "#define SDMMC003_LOCK_UNLOCK                      0x2A    /* CMD42    */" + NL + "#define SDMMC003_APP_CMD                          0x37    /* CMD55    */" + NL + "#define SDMMC003_GEN_CMD                          0x38    /* CMD56    */" + NL + "#define SDMMC003_SET_BUS_WIDTH                    0x06    /* ACMD6    */" + NL + "#define SDMMC003_SD_STATUS                        0x0D    /* ACMD13   */" + NL + "#define SDMMC003_SEND_NUM_WR_BLOCKS               0x16    /* ACMD22   */" + NL + "#define SDMMC003_SET_WR_BLK_ERASE_COUNT           0x17    /* ACMD23   */" + NL + "#define SDMMC003_SD_SEND_OP_COND                  0x29    /* ACMD41   */" + NL + "#define SDMMC003_SET_CLR_CARD_DETECT              0x2A    /* ACMD42   */" + NL + "#define SDMMC003_SEND_SCR                         0x33    /* ACMD51   */" + NL + "/* End of Command Indexes */" + NL + "" + NL + "" + NL + "/* Card State definitions */" + NL + "/**" + NL + " * Card is initialized" + NL + " */ " + NL + "#define SDMMC003_STATE_CARD_INITIALIZED                    (1)" + NL + "/**" + NL + " * No Card Present" + NL + " */" + NL + "#define SDMMC003_STATE_NO_CARD                            (2)" + NL + "/**" + NL + " * Command Line is in Use." + NL + " */" + NL + "#define SDMMC003_STATE_CMD_ACTIVE                          (4)" + NL + "/**" + NL + " * Data Line is in Use." + NL + " */" + NL + "#define SDMMC003_STATE_DATA_ACTIVE                         (8)" + NL + "/**" + NL + " * Card is Write Protected. Cannot write on the card." + NL + " */" + NL + "#define SDMMC003_STATE_CARD_WRITE_PROTECT                  (16)" + NL + "/**" + NL + " * Host Controller is Initialized" + NL + " */" + NL + "#define SDMMC003_STATE_HC_INITIALIZED                      (32)" + NL + "/**" + NL + " * Card is Locked. " + NL + " */" + NL + "#define SDMMC003_STATE_CARD_LOCKED                         (64)" + NL + "" + NL + "/* Card Type Definitions */" + NL + "/**" + NL + " * Standard Capacity Card of Version2 " + NL + " */" + NL + "#define SDMMC003_SD_STANDARD_CAPACITY_V2                   (1)" + NL + "/**" + NL + " * Standard Capacity Card of Version1x. " + NL + " */" + NL + "#define SDMMC003_SD_STANDARD_CAPACITY_V1x                  (2)" + NL + "/**" + NL + " * High Capacity Card . " + NL + " */" + NL + "#define SDMMC003_SD_HIGH_CAPACITY                          (4)" + NL + "/**" + NL + " * Card supports Block addressing. It means Address will be taken in terms of " + NL + " * Sector Numbers " + NL + " */" + NL + "#define SDMMC003_BLOCK_ADDRESSING                          (8)" + NL + "/**" + NL + " * MMC card" + NL + " */" + NL + "#define SDMMC003_MMC                                       (16)" + NL + "" + NL + "" + NL + "/**" + NL + " * Maximum Password Length for locking  " + NL + " */" + NL + "#define SDMMC003_MAX_PASSWD_LENGTH                         (16)" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                ENUMERATIONS                                **" + NL + "******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @brief Data Transfer Direction Enumeration." + NL + " */" + NL + "typedef enum SDMMC003_DataTrasferType" + NL + "{" + NL + "/**" + NL + " * Read from the card." + NL + " */" + NL + "  SDMMC003_READ_FROM_BUFF = 1," + NL + "/**" + NL + " * Write on the Card." + NL + " */" + NL + "  SDMMC003_WRITE_INTO_BUFF," + NL + "} SDMMC003_DataTrasferType;" + NL + "" + NL + "/**" + NL + " * @brief Card Lock/Unlock Operation Enumeration." + NL + " */" + NL + "typedef enum SDMMC003_CardLockMode" + NL + "{" + NL + "/**" + NL + " * Lock the card." + NL + " */" + NL + "  SDMMC003_LOCK," + NL + "/**" + NL + " * Unlock the card." + NL + " */" + NL + "  SDMMC003_UNLOCK," + NL + "} SDMMC003_CardLockMode;" + NL + "" + NL + "/**" + NL + " * @brief This enumerates SDMMC LLD Errors." + NL + " */" + NL + "typedef enum SDMMC003_ErrorCodesType" + NL + "{" + NL + "  /**" + NL + "   * SDMMC LLD App Error  (1)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMCLLD_ERROR" + NL + "  STRCODESTRING = SDMMC LLD App ERROR" + NL + "  */" + NL + "  SDMMC003_ERROR =1," + NL + "  /**" + NL + "   * Command Timeout Error. (2)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_COMMAND_TIMEOUT_ERROR" + NL + "  STRCODESTRING = No response recieved for the command sent." + NL + "  */" + NL + "  SDMMC003_COMMAND_TIMEOUT_ERROR," + NL + "  /**" + NL + "   * Command CRC Error.  (3)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_COMMAND_CRC_ERROR" + NL + "  STRCODESTRING = Command CRC error." + NL + "  */" + NL + "  SDMMC003_COMMAND_CRC_ERROR," + NL + "" + NL + "  /**" + NL + "   * Command End Bit Error. (4)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_COMMAND_ENDBIT_ERROR" + NL + "  STRCODESTRING = End bit of a command response is 0." + NL + "  */" + NL + "  SDMMC003_COMMAND_ENDBIT_ERROR," + NL + "  /**" + NL + "   * Command Index Error.  (5)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_COMMAND_INDEX_ERROR" + NL + "  STRCODESTRING = Command Index error occurs in the command response." + NL + "  */" + NL + "  SDMMC003_COMMAND_INDEX_ERROR," + NL + "  /**" + NL + "   * Data Timeout Error. (6)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_DATA_TIMEOUT_ERROR" + NL + "  STRCODESTRING = Data timeout occurs." + NL + "  */" + NL + "  SDMMC003_DATA_TIMEOUT_ERROR," + NL + "  /**" + NL + "   * Data CRC Error.  (7)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_DATA_CRC_ERROR" + NL + "  STRCODESTRING = CRC error when transferring data" + NL + "  */" + NL + "  SDMMC003_DATA_CRC_ERROR," + NL + "  /**" + NL + "   * Data Endbit Error. (8)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_DATA_ENDBIT_ERROR" + NL + "  STRCODESTRING = 0 Detected at the end bit position of data." + NL + "  */" + NL + "  SDMMC003_DATA_ENDBIT_ERROR," + NL + "  /**" + NL + "   * ACMD12 Error        (9)" + NL + "   */" + NL + "  /*" + NL + "   GROUPID  #16" + NL + "   MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ACMD12_ERROR" + NL + "  STRCODESTRING = Auto cmd12 Error." + NL + "  */" + NL + "  SDMMC003_ACMD12_ERROR," + NL + "  /**" + NL + "   * Argument Out of range error (10)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_OUT_OF_RANGE_ERROR" + NL + "  STRCODESTRING = Command?s argument was out of the allowed range." + NL + "  */" + NL + "  SDMMC003_OUT_OF_RANGE_ERROR," + NL + "  /**" + NL + "   *  Misaligned address (11)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ADDRESS_ERROR" + NL + "  STRCODESTRING = A misaligned address was used in the command." + NL + "  */" + NL + "  SDMMC003_ADDRESS_ERROR," + NL + "  /**" + NL + "   *  Invalid Block Length (12)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_BLOCK_LEN_ERROR" + NL + "  STRCODESTRING = Invalid Block Length." + NL + "  */" + NL + "  SDMMC003_BLOCK_LEN_ERROR," + NL + "  /**" + NL + "   *  Erase Command Sequence error.(13)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ERASE_SEQ_ERROR" + NL + "  STRCODESTRING = An error in the sequence of erase commands occurred." + NL + "  */" + NL + "  SDMMC003_ERASE_SEQ_ERROR," + NL + "  /**" + NL + "   *  Erase Command Parameter error.(14)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ERASE_PARAM_ERROR" + NL + "  STRCODESTRING = Invalid selection of write-blocks for erase occurred" + NL + "  */" + NL + "  SDMMC003_ERASE_PARAM_ERROR," + NL + "  /**" + NL + "   *  Write Protection Vioalation Error (15)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_WP_VIOLATION_ERROR" + NL + "  STRCODESTRING = Attempt to write a write protected block." + NL + "  */" + NL + "  SDMMC003_WP_VIOLATION_ERROR," + NL + "  /**" + NL + "   *  Lock/Unlock ERROR. (16)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_LOCK_UNLOCK_ERROR" + NL + "  STRCODESTRING = Incorrect password/ Command Sequence" + NL + "  */" + NL + "  SDMMC003_LOCK_UNLOCK_ERROR," + NL + "  /**" + NL + "   *  CRC Error (17)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_COM_CRC_ERROR" + NL + "  STRCODESTRING = The CRC check of the previous command failed." + NL + "  */" + NL + "  SDMMC003_COM_CRC_ERROR," + NL + "  /**" + NL + "   *  Illegal Command  (18)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ILLEGAL_COMMAND_ERROR" + NL + "  STRCODESTRING = Command not legal for the card state" + NL + "  */" + NL + "  SDMMC003_ILLEGAL_COMMAND_ERROR," + NL + "  /**" + NL + "   *  Card internal ECC Error  (19)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL;
  protected final String TEXT_4 = "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_CARD_ECC_ERROR" + NL + "  STRCODESTRING = Card internal ECC failed to correct the data." + NL + "  */" + NL + "  SDMMC003_CARD_ECC_ERROR," + NL + "  /**" + NL + "   *  Internal card controller error  (20)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_CC_ERROR" + NL + "  STRCODESTRING = Internal card controller error" + NL + "  */" + NL + "  SDMMC003_CC_ERROR," + NL + "  /**" + NL + "   *  General or an unknown error (21)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING =  SDMMC003_UNKNOWN_ERROR" + NL + "  STRCODESTRING =  A general or an unknown error" + NL + "  */" + NL + "  SDMMC003_UNKNOWN_ERROR," + NL + "  /**" + NL + "   *  CSD Overwrite error  (22)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING =  SDMMC003_CSD_OVERWRITE" + NL + "  STRCODESTRING =  Mismatch CSD content." + NL + "  */" + NL + "  SDMMC003_CSD_OVERWRITE," + NL + "  /**" + NL + "   *  Erase skipped on a write protection area.  (23)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING =  SDMMC003_WP_ERASE_SKIP_ERROR" + NL + "  STRCODESTRING =  Erase skipped on a write protection area." + NL + "  */" + NL + "  SDMMC003_WP_ERASE_SKIP_ERROR," + NL + "  /**" + NL + "   *   Error in the sequence of the authentication process  (24)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING =  SDMMC003_ASK_SEQ_ERROR" + NL + "  STRCODESTRING =  Error in the sequence of the authentication process" + NL + "  */" + NL + "  SDMMC003_ASK_SEQ_ERROR," + NL + "  /**" + NL + "   *  Bad response recieved. (25)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING =  SDMMC003_BAD_RESPONSE" + NL + "  STRCODESTRING =  Voltage Check pattern incorrect." + NL + "  */" + NL + "  SDMMC003_BAD_RESPONSE," + NL + "  /**" + NL + "   *  Command Line is busy  (26)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_CMD_LINE_BUSY" + NL + "  STRCODESTRING =  Command Line is busy" + NL + "  */" + NL + "  SDMMC003_CMD_LINE_BUSY," + NL + "  /**" + NL + "   *  Data Line is busy  (27)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_DATA_LINE_BUSY" + NL + "  STRCODESTRING = Data Line is busy" + NL + "  */" + NL + "  SDMMC003_DATA_LINE_BUSY," + NL + "  /**" + NL + "   *  Command Completed.  (28)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_COMMAND_COMPLETE" + NL + "  STRCODESTRING = Command is successfully executed." + NL + "  */" + NL + "  SDMMC003_COMMAND_COMPLETE," + NL + "  /**" + NL + "   *  Command Failed. (29)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_SENDCOMMAND_ERROR" + NL + "  STRCODESTRING = Command failed to executed." + NL + "  */" + NL + "  SDMMC003_SENDCOMMAND_ERROR," + NL + "  /**" + NL + "   *  Buffer read/write ready  (30)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_BUFFER_READY" + NL + "  STRCODESTRING = Buffer is ready to read from or write into." + NL + "  */" + NL + "  SDMMC003_BUFFER_READY," + NL + "  /**" + NL + "   *  Data transfer is successful  (31)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_TRANSFER_COMPLETE" + NL + "  STRCODESTRING = Data transfer is successful." + NL + "  */" + NL + "  SDMMC003_TRANSFER_COMPLETE," + NL + "  /**" + NL + "   *  Card is locked. (32)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_CARD_IS_LOCKED" + NL + "  STRCODESTRING = Card is locked." + NL + "  */" + NL + "  SDMMC003_CARD_IS_LOCKED," + NL + "  /**" + NL + "   *  Card unlocked  (33)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_CARD_UNLOCKED" + NL + "  STRCODESTRING = Card is unlocked." + NL + "  */" + NL + "  SDMMC003_CARD_UNLOCKED," + NL + "  /**" + NL + "   *  Read data from the card failed. (34)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_READ_ERROR" + NL + "  STRCODESTRING = Read transaction failed." + NL + "  */" + NL + "  SDMMC003_READ_ERROR," + NL + "  /**" + NL + "   *  Write data into the card failed. (35)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_WRITE_ERROR" + NL + "  STRCODESTRING = Write transaction failed." + NL + "  */" + NL + "  SDMMC003_WRITE_ERROR," + NL + "  /**" + NL + "   *  Recoverable Error (36)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_RECOVERABLE_ERROR" + NL + "  STRCODESTRING = Recoverable Error while recovering error." + NL + "  */" + NL + "  SDMMC003_RECOVERABLE_ERROR," + NL + "  /**" + NL + "   * NOn-Recoverable Error (37)" + NL + "   */" + NL + "  /*GROUPID  #16" + NL + "  MODULENAME = Sdmmc LLD App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_NONRECOVERABLE_ERROR" + NL + "  STRCODESTRING = Non-Recoverable Error while recovering error." + NL + "  */" + NL + "  SDMMC003_NONRECOVERABLE_ERROR," + NL + "  /**" + NL + "   *  Error in the Command not using data line and not ACMD12 Command (38)" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ACMD_CMD_wo_DAT_ERROR" + NL + "  STRCODESTRING = Error in the Command not using data line." + NL + "  */" + NL + "  SDMMC003_ACMD_CMD_wo_DAT_ERROR," + NL + "" + NL + "  /**" + NL + "   * Error has occured in CMD_wo_DAT and the SD memory Transfer (39)" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ACMD_BOTH_ERROR" + NL + "  STRCODESTRING = Error has occured in CMD_wo_DAT and the SD memory Transfer" + NL + "   */" + NL + "    SDMMC003_ACMD_BOTH_ERROR," + NL + "  /**" + NL + "   * Error has not occured in CMD_wo_DAT but in  SD memory Transfer (40)" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ACMD_SD_TRANSFER_ERROR" + NL + "  STRCODESTRING = Error has not occured in CMD_wo_DAT but in  SD memory Transfer" + NL + "  */" + NL + "  SDMMC003_ACMD_SD_TRANSFER_ERROR," + NL + "  /**" + NL + "   * Error has not occured in SD memory Transfer and ACMD12 is not issued.(41)" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_ACMD_CMD_wo_DAT_NOT_ISSUED" + NL + "  STRCODESTRING = Error has not occured in SD memory Transfer and ACMD12 is" + NL + "    not issued." + NL + "  */" + NL + "   SDMMC003_ACMD_CMD_wo_DAT_NOT_ISSUED," + NL + "  /**" + NL + "   * Initialization failed(42)" + NL + "   */" + NL + "   /*" + NL + "   ERRCODESTRING = SDMMC003_INIT_FAIL" + NL + "   STRCODESTRING = Initialization failed." + NL + "   */" + NL + "   SDMMC003_INIT_FAIL," + NL + "  /**" + NL + "   * Initialization success but card is locked (43)" + NL + "   */" + NL + "   /*" + NL + "   ERRCODESTRING =  SDMMC003_INITIALIZED_BUT_LOCKED" + NL + "   STRCODESTRING = Initialization failed." + NL + "   */" + NL + "    SDMMC003_INITIALIZED_BUT_LOCKED," + NL + "    " + NL + "  /**" + NL + "   * Host Controleller already initialized (44)" + NL + "   */" + NL + "   /*" + NL + "   ERRCODESTRING =  SDMMC003_HOST_CONTROLLER_INITIALIZED" + NL + "   STRCODESTRING = Host Controller already Initialization, so failed." + NL + "   */" + NL + "   SDMMC003_HOST_CONTROLLER_INITIALIZED,  " + NL + "  /**" + NL + "   * NULL function pointer passed (45)" + NL + "   */" + NL + "   /*" + NL + "   ERRCODESTRING =  SDMMC003_NULL_POINTER." + NL + "   STRCODESTRING = NULL function pointer passed ." + NL + "   */" + NL + "  SDMMC003_NULL_POINTER," + NL + "  " + NL + "  /**" + NL + "   * Delay Timeout Error (46)" + NL + "   */" + NL + "   /*" + NL + "   ERRCODESTRING =  SDMMC003_TIMEOUT_OCCURED." + NL + "   STRCODESTRING = Timeout Occured while waiting for some event." + NL + "   */" + NL + "  SDMMC003_TIMEOUT_OCCURED," + NL + "  /**" + NL + "   * Start Timer Failed (47)" + NL + "   */" + NL + "  /*" + NL + "   ERRCODESTRING =  SDMMC003_START_TIMER_FAILED." + NL + "   STRCODESTRING =  Start Timer failed." + NL + "   */" + NL + "   SDMMC003_START_TIMER_FAILED," + NL + "   /**" + NL + "   *  Sector Number out of bound (48)" + NL + "   */" + NL + "  /*" + NL + "   ERRCODESTRING =  SDMMC003_SECTOR_OUT_OF_BOUND." + NL + "   STRCODESTRING =  Sector Number out of bound." + NL + "   */" + NL + "   SDMMC003_SECTOR_OUT_OF_BOUND," + NL + "  /**" + NL + "   * Debug log codes starts here  (49)" + NL + "   */" + NL + "  /**" + NL + "   * DebugLog Message Id for Function Entry" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_FUNCTION_ENTRY" + NL + "  STRCODESTRING = Function Entered %s" + NL + "  */" + NL + "  SDMMC003_FUNCTION_ENTRY," + NL + "" + NL + "  /**" + NL + "   * DebugLog Message Id for Function Exit (50)" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = SDMMC003_FUNCTION_EXIT" + NL + "  STRCODESTRING = Function Exited %s" + NL + "  */" + NL + "  SDMMC003_FUNCTION_EXIT" + NL + "} SDMMC003_ErrorCodesType;" + NL + "" + NL + "/**" + NL + " * @brief This enumerates some of the SDMMC Interrupts" + NL + " */" + NL + "typedef enum SDMMC003_InterruptType" + NL + "{" + NL + "  /**" + NL + "   * Card Removal Interrupt" + NL + "   */" + NL + "  SDMMC003_CARD_REMOVAL," + NL + "  /**" + NL + "   * Card Insertion Interrupt" + NL + "   */" + NL + " SDMMC003_CARD_INSERTION," + NL + "} SDMMC003_InterruptType;" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Type Definitions                               **" + NL + "*******************************************************************************/" + NL + "#if SDMMC_CARD_DETECTION_SUPPORT" + NL + "/**" + NL + " * Poinetr to the Call Back Function of Upper layer which will be invoked if " + NL + " * Card is inserted or removed in a card detection circuit." + NL + " */" + NL + "typedef void (*SDMMC003_PtrToCallBackFunction)(SDMMC003_InterruptType); " + NL + "#endif" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                STRUCTURES                                  **" + NL + " ******************************************************************************/" + NL + "#if SDMMC_UVP_TEST" + NL + "/**" + NL + " * @brief This structure is used to Trigger differnt Error Interrupts used for" + NL + " * testing purpose." + NL + " */" + NL + "typedef struct Test_TriggerInterruptType" + NL + "{" + NL + "/**" + NL + " * Trigger Error Interrupt while issuing Command." + NL + " */" + NL + "  bool Trigger_CommandErrorInterrupt;" + NL + "/**" + NL + " * Trigger Error Interrupt in Data Transfer." + NL + " */" + NL + "  bool Trigger_DataErrorInterrupt;" + NL + "/**" + NL + " * Trigger Error Interrupt in command response received." + NL + " */" + NL + "  bool Trigger_CommandResponseError;" + NL + "/**" + NL + " * Trigger Data and Command Line Busy error." + NL + " */" + NL + "  bool Trigger_DataCmdLineBusy;" + NL + "/**" + NL + " * Trigger Erase Start Error Interrupt" + NL + " */" + NL + "  bool Trigger_EraseStartError; " + NL + "/**" + NL + " * Trigger Erase End Error Interrupt" + NL + " */" + NL + "  bool Trigger_EraseEndError; " + NL + "/**" + NL + " * Trigger Auto CMD Error Interrupt" + NL + " */" + NL + "  bool Trigger_AcmdErrorInterrupt;" + NL + "/**" + NL + " * Trigger Transfer  Error Interrupt" + NL;
  protected final String TEXT_5 = " */" + NL + "  bool Trigger_TransferStateError;" + NL + "/**" + NL + " * Trigger Lock Status Error Interrupt" + NL + " */" + NL + "  bool Trigger_LockStatusError;" + NL + "" + NL + "/**" + NL + " * Trigger CMD55 Error Interrupt" + NL + " */" + NL + "  bool Trigger_Cmd55Error;" + NL + "/**" + NL + " *  Trigger CMD55 Error Interrupt for test case 54" + NL + " */" + NL + "  bool Trigger_Cmd55_TC54 ;" + NL + "/**" + NL + " *  Trigger CMD42 Error Interrupt " + NL + " */" + NL + "  bool Trigger_Command42Error;" + NL + "/**" + NL + " *  Trigger  Error Interrupt for test case 8" + NL + " */" + NL + "  bool Trigger_TC8Error;" + NL + "/**" + NL + " *  Trigger  Error Interrupt for test case 10" + NL + " */" + NL + "  bool Trigger_TC10Error;" + NL + "/**" + NL + " *  Trigger  Error Interrupt for test case 13" + NL + " */" + NL + " bool Trigger_TC13Error;" + NL + "/**" + NL + " *  Trigger  Error Interrupt for test case 17" + NL + " */" + NL + " bool Trigger_TC17Error;" + NL + "/**" + NL + " *  Trigger  Error Interrupt for test case 17" + NL + " */" + NL + " bool Trigger_TC20Error;" + NL + " /**" + NL + "  *  Trigger  Error Interrupt for test case 23 part1" + NL + "  */" + NL + "  bool Trigger_TC23_1Error;" + NL + "/**" + NL + "*  Trigger  Error Interrupt for test case 23 part2" + NL + "*/" + NL + "bool Trigger_TC23_2Error;" + NL + "/**" + NL + " *  Trigger  Transfer Interrupt Error" + NL + " */" + NL + " bool Trigger_TransferInterruptError;" + NL + "" + NL + "} Test_TriggerInterruptType;" + NL + "#endif /* SDMMC_UVP_TEST */" + NL + "" + NL + "/**" + NL + " * @brief SDMMC Handle Struture stores the card states, card registers" + NL + " * and other Interrupt Information" + NL + " */" + NL + "typedef struct SDMMC003_HandleType" + NL + "{" + NL + "  /**" + NL + "    * Card States:" + NL + "     SDMMC003_STATE_CARD_INITIALIZED                    (1)" + NL + "     SDMMC003_STATE_NO_CARD                         (2)" + NL + "     SDMMC003_STATE_CMD_ACTIVE                          (4)" + NL + "     SDMMC003_STATE_DATA_ACTIVE                         (8)" + NL + "     SDMMC003_STATE_CARD_WRITE_PROTECT                  (16)" + NL + "     SDMMC003_STATE_HC_INITIALIZED                      (32)" + NL + "     SDMMC003_STATE_CARD_LOCKED                         (64)" + NL + "    */" + NL + "  uint16_t State;" + NL + "  /**" + NL + "   * Card Type Information." + NL + "   * SDMMC003_SD_STANDARD_CAPACITY_V2                   (1)" + NL + "   * SDMMC003_SD_STANDARD_CAPACITY_V1x                  (2)" + NL + "   * SDMMC003_SD_HIGH_CAPACITY                          (4)" + NL + "   * SDMMC003_BLOCK_ADDRESSING                          (8)" + NL + "   * SDMMC003_MMC                                       (16)" + NL + "   */" + NL + "  uint8_t  CardType;" + NL + "  /**" + NL + "   * Interrupt Error in Data Transfer. Error Status like Data timeout, Data CRC," + NL + "   * Data Endbit, Current Limit Error info is stored here." + NL + "   */" + NL + "  SDMMC003_ErrorCodesType DataInterruptError;" + NL + "  /**" + NL + "   * Interrupt Error in Command Issuance. Error Status like Command Timeout," + NL + "   * Command CRC, Command End bit, Command Index or COmmand Complete." + NL + "   */" + NL + "  SDMMC003_ErrorCodesType CommandInterruptError;" + NL + "  /**" + NL + "   * Interrupt Status if Transfer Successful." + NL + "   */" + NL + "  SDMMC003_ErrorCodesType TransferInterruptError;" + NL + "  /**" + NL + "   * Interrupt Status in Issuance of ACMD12 Command." + NL + "   */" + NL + "  SDMMC003_ErrorCodesType AcmdInterruptError;" + NL + "  /**" + NL + "   * Error Recovery Status of a failed transaction" + NL + "   */" + NL + "  SDMMC003_ErrorCodesType ErrorRecoveryStatus;" + NL + "  " + NL + "  /**" + NL + "   * Flag indicating the success initialization process" + NL + "   */" + NL + "   uint8_t InitializeFlag;" + NL + "  /** F8 flag is used in card intialization procedure to identify card type */" + NL + "  uint8_t f8 ;" + NL + "  /**" + NL + "   * Flag to set when semaphores and mutex are created successfully " + NL + "   */" + NL + "#if SDMMC_CARD_DETECTION_SUPPORT" + NL + "  /**" + NL + "   * Poinetr to the Call Back Function of Upper layer which will be invoked if " + NL + "   * Card is inserted or removed in a card detection circuit." + NL + "   */" + NL + " SDMMC003_PtrToCallBackFunction CallBackPtr; " + NL + "#endif" + NL + "  volatile bool TimerExpire;" + NL + "  uint8_t IssueAbort;" + NL + "} SDMMC003_HandleType;" + NL + "" + NL + "/**" + NL + " * @brief This structure is used to store the SD Card's CID register content" + NL + " */" + NL + "typedef struct SDMMC003_SDCIDType" + NL + "{" + NL + "  /**" + NL + "   * This variable stores CID register's 12 bit Manufacturing date(MDT)." + NL + "   */" + NL + "  uint16_t ManufacturingDate;" + NL + "" + NL + "  /**" + NL + "   * This variable stores CID register's 32 bit Serial Numaber(PSN)" + NL + "   */" + NL + "  uint32_t ProductSerialNum;" + NL + "  /**" + NL + "   * This variable stores CID register's 32 bit Product revision (PRV)" + NL + "   */" + NL + "  uint8_t ProductRev;" + NL + "" + NL + "  /**" + NL + "   * This variable stores CID register's 40 bit product's name(PNM)" + NL + "   */" + NL + "  uint8_t ProductName[5];" + NL + "" + NL + "  /**" + NL + "   * This variable stores CID register's 16 bit OEM/Application ID (OID)" + NL + "   */" + NL + "  uint8_t AppOEMId[2];" + NL + "" + NL + "  /**" + NL + "   * This variable stores CID register's 8 bit Manufacturer ID (MID)" + NL + "   */" + NL + "  uint8_t ManufacturerId;" + NL + "} SDMMC003_SDCIDType;" + NL + "" + NL + "/**" + NL + " * @brief This structure is used to store the MMC  Card's CID register content." + NL + " */" + NL + "typedef struct SDMMC003_MMCCIDType" + NL + "{" + NL + "  /**" + NL + "   * This variable stores CID register's 8 bit Manufacturing date(MDT)" + NL + "   */" + NL + "  uint8_t ManufacturingDate;" + NL + "  /**" + NL + "   * This variable stores CID register's 32 bit Serial Numaber(PSN)" + NL + "   */" + NL + "  uint32_t ProductSerialNum;" + NL + "  /**" + NL + "   * This variable stores CID register's 8bit Product revision (PRV)" + NL + "   */" + NL + "  uint8_t ProductRev;" + NL + "  /**" + NL + "   * This variable stores CID register's 48 bit product's name(PNM)" + NL + "   */" + NL + "  uint8_t ProductName[6];" + NL + "  /**" + NL + "   * This variable stores CID register's 16 bit OEM/Application ID (OID)" + NL + "   */" + NL + "  uint8_t AppOEMId;" + NL + "  /**" + NL + "   * CBX indicates the device type." + NL + "   * 00 Card (removable)" + NL + "   * 01 BGA (Discrete embedded)" + NL + "   * 10 POP" + NL + "   * 11 Reserved" + NL + "   */" + NL + "  uint8_t CardBGA :2 ;" + NL + "  /**" + NL + "   * Reserved bits" + NL + "   */" + NL + "  uint8_t Resv2 :6 ;" + NL + "  /**" + NL + "   * This variable stores CID register's 8 bit Manufacturer ID (MID)" + NL + "   */" + NL + "  uint8_t ManufacturerId;" + NL + "} SDMMC003_MMCCIDType;" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the MMC card's CSD register content." + NL + " */" + NL + "typedef struct SDMMC003_MMCCSDType" + NL + "{" + NL + "  /**" + NL + "   * Fixed to 1 always" + NL + "   */" + NL + "  uint32_t Fixed : 1;" + NL + "  /**" + NL + "   * CRC bits" + NL + "   */" + NL + "  uint32_t Crc : 7;" + NL + "  /**" + NL + "   * Reserved bits." + NL + "   */" + NL + "  uint32_t Resv1 : 2;" + NL + "  /**" + NL + "   * Indicates the file format on the card." + NL + "   */" + NL + "  uint32_t FileFormat : 2;" + NL + "  /**" + NL + "   * Temporarily protects the entire card content from being overwritten or erased." + NL + "   */" + NL + "  uint32_t TempWriteProtect :1;" + NL + "  /**" + NL + "   * Permanently protects the entire card content against overwriting or erasing." + NL + "   */" + NL + "  uint32_t PermWriteProtect : 1;" + NL + "  /**" + NL + "   * Defines if the contents is original (=0) or has been copied (=1)." + NL + "   */" + NL + "  uint32_t Copy :1;" + NL + "  /**" + NL + "   * Indicates the selected group of file formats." + NL + "   */" + NL + "  uint32_t FileFormatGroup : 1;" + NL + "  /**" + NL + "   * This field in the CSD indicates whether the content protection application" + NL + "   * is supported." + NL + "   */" + NL + "  uint32_t ContentProtApp : 1;" + NL + "  /**" + NL + "   * Reserved bits." + NL + "   */" + NL + "  uint32_t Resv2 : 4;" + NL + "  /**" + NL + "   * Defines whether partial block sizes can be used in block write commands." + NL + "   */" + NL + "  uint32_t WriteBlkPartial : 1;" + NL + "  /**" + NL + "   * The maximum write data block length is computed as 2WRITE_BL_LEN." + NL + "   */" + NL + "  uint32_t WriteBlkLen : 4;" + NL + "  /**" + NL + "   * Defines the typical block program time as a multiple of the read access time." + NL + "   */" + NL + "  uint32_t WriteSpeedFactor :3;" + NL + "  /**" + NL + "   * Reserved bits." + NL + "   */" + NL + "  uint32_t Resv3 :2;" + NL + "  /**" + NL + "   * A value of 0 means no group write protection possible." + NL + "   */" + NL + "  uint32_t WriteProtGrpEnable :1;" + NL + "  /**" + NL + "   * The size of a write protected group. The actual size is computed by increasing" + NL + "   * this number by one. A value of zero means one erase sector, 127 means 128 erase" + NL + "   * sectors." + NL + "   */" + NL + "  uint32_t WriteProtGrpSize :5;" + NL + "  /**" + NL + "   * A 5 bit binary coded value used for calculating the size of the erasable" + NL + "   * unit of the card" + NL + "   */" + NL + "  uint32_t EraseGrpMult : 5;" + NL + "  /**" + NL + "   * The size of an erasable sector." + NL + "   */" + NL + "  uint32_t EraseGrpSize :5;" + NL + "  /**" + NL + "   * This parameter is used for coding a factor MULT for computing the total" + NL + "   * device size" + NL + "   */" + NL + "  uint32_t DeviceSizeMult :3;" + NL + "  /**" + NL + "   * The maximum values for write currents at the maximal power supply VDD" + NL + "   */" + NL + "  uint32_t MaxWriteCurrent :3;" + NL + "  /**" + NL + "   * The maximum values for write currents at the minimal power supply VDD" + NL + "   */" + NL + "  uint32_t MinWriteCurrent :3;" + NL + "  /**" + NL + "   * The maximum values for read currents at the maximal power supply VDD" + NL + "   */" + NL + "  uint32_t MaxReadCurrent :3;" + NL + "  /**" + NL + "   * The maximum values for read currents at the minimal power supply VDD" + NL + "   */" + NL + "  uint32_t MinReadCurrent :3;" + NL + "  /**" + NL + "   * This parameter is used to compute the user?s data card capacity (not include" + NL + "   * the security protected" + NL + "   */" + NL + "  uint32_t DeviceSizeHigh : 10;" + NL + "  uint32_t DeviceSizeLower :2;" + NL + "  /**" + NL + "   * Reserved bits" + NL + "   */" + NL + "  uint32_t Resv4 : 2;" + NL + "  /**" + NL + "   * Defines if the configurable driver stage is integrated on the card." + NL + "   */" + NL + "  uint32_t DsrImp :1;" + NL + "  /**" + NL + "   * Defines if the data block to be read by one command can be spread over more" + NL + "   * than one physical block" + NL + "   * of the memory device." + NL + "   */" + NL + "  uint32_t ReadBlkMisalign :1;" + NL + "  /**" + NL + "   * Defines if the data block to be written by one command can be spread over more" + NL + "   * than one physical" + NL + "   * block of the memory device." + NL + "   */" + NL + "  uint32_t WriteBlkMisalign :1;" + NL + "  /**" + NL + "   * Partial Block Read is always allowed in an SD Memory Card. It means that" + NL + "   * smaller blocks can be used" + NL + "   * as well." + NL + "   */" + NL + "  uint32_t ReadBlkPartial :1;" + NL + "  /**" + NL + "   * The maximum read data block length is computed as 2READ_BL_LEN." + NL + "   */" + NL + "  uint32_t ReadBlkLen :4;" + NL + "  /**" + NL + "   * The card command class register CCC defines which command classes are supported" + NL + "   * by this card.A value of 1 in a CCC bit means that the corresponding command" + NL + "   * class is supported." + NL + "   */" + NL + "  uint32_t CCC :12;" + NL + "  /**" + NL + "   * Defines the maximum data transfer rate per one data line." + NL + "   */" + NL + "  uint32_t  TranSpeed : 8;" + NL + "  /**" + NL + "   * Defines the worst case for the clock-dependant factor of the data access time." + NL + "   */" + NL + "  uint32_t Nsac : 8 ;" + NL + "  /**" + NL + "   * Defines the asynchronous part of the data access time." + NL + "   */" + NL + "  uint32_t Taac : 8;" + NL + "  /**" + NL + "   * Reserved bits" + NL + "   */" + NL + "  uint32_t Resv5 :2;" + NL + "  /*" + NL + "   * Defines the MultiMediaCard System Specification version supported by the card" + NL + "   */" + NL + "  uint32_t SpecVersion :4;" + NL + "  /*" + NL + "   * Describes the version of the CSD structure." + NL + "   */" + NL + "  uint32_t CsdStruct :2;" + NL + "} SDMMC003_MMCCSDType;" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the SD v1 card's Csd register content." + NL + " */" + NL + "typedef struct SDMMC003_CSDV1Type" + NL + "{" + NL + "  /**" + NL + "   * Fixed to 1 always" + NL + "   */" + NL + "  uint32_t Fixed : 1;" + NL + "" + NL + "  /**" + NL + "   * CRC bits" + NL + "   */" + NL + "  uint32_t Crc : 7;" + NL + "  /**" + NL + "   * Reserved bits." + NL + "   */" + NL + "  uint32_t Resv1 : 2;" + NL + "  /**" + NL + "   * Indicates the file format on the card." + NL + "   */" + NL + "  uint32_t FileFormat : 2;" + NL + "  /**" + NL + "   * Temporarily protects the entire card content from being overwritten or erased." + NL + "   */" + NL + "  uint32_t TempWriteProtect : 1;" + NL + "  /**" + NL + "   * Permanently protects the entire card content against overwriting or erasing." + NL + "   */" + NL;
  protected final String TEXT_6 = "  uint32_t PermWriteProtect : 1;" + NL + "  /**" + NL + "   * Defines if the contents is original (=0) or has been copied (=1)." + NL + "   */" + NL + "  uint32_t Copy : 1;" + NL + "  /**" + NL + "   * Indicates the selected group of file formats." + NL + "   */" + NL + "  uint32_t FileFormatGroup : 1;" + NL + "  /**" + NL + "   * Reserved bits." + NL + "   */" + NL + "  uint32_t Resv2 : 5;" + NL + "  /**" + NL + "   * Defines whether partial block sizes can be used in block write commands." + NL + "   */" + NL + "  uint32_t WriteBlkPartial : 1;" + NL + "  /**" + NL + "   * The maximum write data block length is computed as 2WRITE_BL_LEN." + NL + "   */" + NL + "  uint32_t WriteBlkLen : 4;" + NL + "  /**" + NL + "   * Defines the typical block program time as a multiple of the read access time." + NL + "   */" + NL + "  uint32_t WriteSpeedFactor : 3;" + NL + "  uint32_t Resv3 : 2;" + NL + "  /**" + NL + "   * A value of 0 means no group write protection possible." + NL + "   */" + NL + "  uint32_t WriteProtGrpEnable : 1;" + NL + "  /**" + NL + "   * The size of a write protected group. The actual size is computed by increasing" + NL + "   * this number by one. A value of zero means one erase sector, 127 means 128 erase" + NL + "   * sectors." + NL + "   */" + NL + "  uint32_t WriteProtGrpSize : 7;" + NL + "  /**" + NL + "   * The size of an erasable sector." + NL + "   */" + NL + "  uint32_t EraseSectorSize : 7;" + NL + "  /**" + NL + "   * The ERASE_BLK_EN defines the granularity of the unit size of the data to be" + NL + "   * erased." + NL + "   */" + NL + "  uint32_t EraseSingleBlkEnable : 1;" + NL + "  /**" + NL + "   * This parameter is used for coding a factor MULT for computing the total device" + NL + "   * size (see ?C_SIZE?)." + NL + "   */" + NL + "  uint32_t DeviceSizeMult : 3;" + NL + "  /**" + NL + "   * The maximum values for write currents at the maximal power supply VDD" + NL + "   */" + NL + "  uint32_t MaxWriteCurrent : 3;" + NL + "  /**" + NL + "   * The maximum values for write currents at the minimal power supply VDD" + NL + "   */" + NL + "  uint32_t MinWriteCurrent : 3;" + NL + "  /**" + NL + "   * The maximum values for read currents at the maximal power supply VDD" + NL + "   */" + NL + "  uint32_t MaxReadCurrent : 3;" + NL + "  /**" + NL + "   * The maximum values for read currents at the minimal power supply VDD" + NL + "   */" + NL + "  uint32_t MinReadCurrent : 3;" + NL + "  uint32_t DeviceSizeLower : 2 ;" + NL + "  /**" + NL + "   * This parameter is used to compute the user?s data card capacity (not include" + NL + "   * the security protected" + NL + "   */" + NL + "  uint32_t DeviceSizeHigh : 10;" + NL + "  /**" + NL + "   * Reserved bits" + NL + "   */" + NL + "  uint32_t Resv4 :2;" + NL + "  /**" + NL + "   * Defines if the configurable driver stage is integrated on the card." + NL + "   */" + NL + "  uint32_t DsrImp :1;" + NL + "  /**" + NL + "   * Defines if the data block to be read by one command can be spread over more" + NL + "   * than one physical block" + NL + "   * of the memory device." + NL + "   */" + NL + "  uint32_t ReadBlkMisalign :1;" + NL + "  /**" + NL + "   * Defines if the data block to be written by one command can be spread over more" + NL + "   * than one physical" + NL + "   * block of the memory device." + NL + "   */" + NL + "  uint32_t WriteBlkMisalign :1;" + NL + "  /**" + NL + "   * Partial Block Read is always allowed in an SD Memory Card. It means that" + NL + "   * smaller blocks can be used" + NL + "   * as well." + NL + "   */" + NL + "  uint32_t ReadBlkPartial :1;" + NL + "  /**" + NL + "   * The maximum read data block length is computed as 2READ_BL_LEN." + NL + "   */" + NL + "  uint32_t ReadBlkLen :4;" + NL + "  /**" + NL + "   * The card command class register CCC defines which command classes are supported" + NL + "   * by this card.A value of 1 in a CCC bit means that the corresponding command" + NL + "   * class is supported." + NL + "   */" + NL + "  uint32_t CCC :12;" + NL + "  /**" + NL + "   * Defines the maximum data transfer rate per one data line." + NL + "   */" + NL + "  uint32_t  TranSpeed : 8;" + NL + "  /**" + NL + "   * Defines the worst case for the clock-dependant factor of the data access time." + NL + "   */" + NL + "  uint32_t Nsac : 8  ;" + NL + "  /**" + NL + "   * Defines the asynchronous part of the data access time." + NL + "   */" + NL + "  uint32_t Taac : 8;" + NL + "   /**" + NL + "   * Reserved Bits" + NL + "   */" + NL + "  uint32_t Resv5 : 6;" + NL + "  /**" + NL + "   * The CSD_STRUCTURE field in the CSD register indicates its structure version." + NL + "   */" + NL + "  uint32_t CsdStruct : 2;" + NL + "} SDMMC003_CSDV1Type;" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the SD v2 card's Csd register content." + NL + " */" + NL + "typedef struct SDMMC003_CSDV2Type" + NL + "{" + NL + "  /**" + NL + "   * Fixed to 1 always" + NL + "   */" + NL + "  uint32_t Fixed : 1;" + NL + "" + NL + "  /**" + NL + "   * CRC bits" + NL + "   */" + NL + "  uint32_t Crc : 7;" + NL + "" + NL + "  uint32_t Resv1 : 2;" + NL + "  /**" + NL + "   * This field is set to 0. Host should not use this field." + NL + "   */" + NL + "  uint32_t FileFormat : 2;" + NL + "  /**" + NL + "   * Definition of this field is same as in CSD Version1.0" + NL + "   */" + NL + "  uint32_t TempWriteProtect : 1;" + NL + "  /**" + NL + "   * Definition of this field is same as in CSD Version1.0" + NL + "   */" + NL + "  uint32_t PermWriteProtect : 1;" + NL + "  /**" + NL + "   * Definition of this field is same as in CSD Version1.0." + NL + "   */" + NL + "  uint32_t Copy : 1;" + NL + "  /**" + NL + "   * This field is set to 0. Host should not use this field." + NL + "   */" + NL + "  uint32_t FileFormatGroup : 1;" + NL + "  uint32_t Resv2 : 5;" + NL + "  /**" + NL + "   * This field is fixed to 0, which indicates partial block read is inhibited" + NL + "   * and only unit of block access is allowed." + NL + "   */" + NL + "  uint32_t WriteBlkPartial : 1;" + NL + "  /**" + NL + "   * This field is fixed to 9h, which indicates WRITE_BL_LEN=512 Byte." + NL + "   */" + NL + "  uint32_t WriteBlkLen : 4;" + NL + "  /**" + NL + "   * This field is fixed to 2h, which indicates 4 multiples. Write timeout can be" + NL + "   * calculated by multiplying the" + NL + "   * read access time and R2W_FACTOR." + NL + "   */" + NL + "  uint32_t WriteSpeedFactor : 3;" + NL + "  uint32_t Resv3 : 2;" + NL + "  /**" + NL + "   * This field is fixed to 0. The High Capacity SD Memory Card does not support" + NL + "   * write protected groups." + NL + "   */" + NL + "  uint32_t WriteProtGrpEnable : 1;" + NL + "  /**" + NL + "   * This field is fixed to 00h. The High Capacity SD Memory Card does not support" + NL + "   * write protected groups." + NL + "   */" + NL + "  uint32_t WriteProtGrpSize : 7;" + NL + "  /**" + NL + "   * This field is fixed to 7Fh, which indicates 64 KBytes. This value does not" + NL + "   * relate to erase operation." + NL + "   */" + NL + "  uint32_t EraseSectorSize : 7;" + NL + "  /**" + NL + "   * This field is fixed to 1, which means the host can erase one or multiple units" + NL + "   * of 512 bytes." + NL + "   */" + NL + "  uint32_t EraseSingleBlkEnable : 1;" + NL + "  uint32_t Resv4 : 1;" + NL + "  uint32_t DeviceSizeLower : 16;" + NL + "" + NL + "  /**" + NL + "   * This parameter is used to calculate the user data area capacity in the SD" + NL + "   * memory card (not include the protected area)." + NL + "   */" + NL + "  uint32_t DeviceSizeHigh : 6;" + NL + "  uint32_t  Resv5 : 6;" + NL + "  /**" + NL + "   * Definition of this field is same as in CSD Version1.0." + NL + "   */" + NL + "  uint32_t  DsrImp : 1;" + NL + "  /**" + NL + "   * This field is fixed to 0, which indicates read access crossing physical block" + NL + "   * boundaries is always disabled in High Capacity SD Memory Card." + NL + "   */" + NL + "  uint32_t ReadBlkMisalign : 1;" + NL + "  /**" + NL + "   * This field is fixed to 0, which indicates write access crossing physical block" + NL + "   * boundaries is always  disabled in High Capacity SD Memory Card." + NL + "   */" + NL + "  uint32_t WriteBlkMisalign : 1;" + NL + "  /**" + NL + "   * This field is fixed to 0, which indicates partial block read is inhibited and" + NL + "   * only unit of block access is  allowed." + NL + "   */" + NL + "  uint32_t ReadBlkPartial : 1;" + NL + "  /**" + NL + "   * This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte." + NL + "   */" + NL + "  uint32_t ReadBlkLen : 4;" + NL + "  /**" + NL + "   * Definition of this field is same as in CSD Version1.0." + NL + "   */" + NL + "  uint32_t CCC : 12;" + NL + "  /**" + NL + "   * Definition of this field is same as in CSD Version1.0." + NL + "   */" + NL + "  uint32_t TranSpeed : 8;" + NL + "  /**" + NL + "   * This field is fixed to 00h." + NL + "   */" + NL + "  uint32_t Nsac : 8;" + NL + "  /**" + NL + "   * This field is fixed to 0Eh, which indicates 1 ms." + NL + "   */" + NL + "  uint32_t Taac : 8;" + NL + "  uint32_t Resv6 : 6;" + NL + "  /**" + NL + "   * The CSD_STRUCTURE field in the CSD register indicates its structure version." + NL + "   */" + NL + "  uint32_t CsdStruct : 2;" + NL + "} SDMMC003_CSDV2Type;" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the SD Card's SCR register content." + NL + " */" + NL + "typedef struct SDMMC003_SCRType" + NL + "{" + NL + "  /**" + NL + "   * Describes the Physical Layer Specification Version supported by the card." + NL + "   */" + NL + "  uint32_t SdSpec : 4;" + NL + "" + NL + "  /**" + NL + "   * Defines the SCR version." + NL + "   */" + NL + "  uint32_t ScrStructure : 4;" + NL + "" + NL + "  /**" + NL + "   * Describes all the DAT bus widths that are supported by this card." + NL + "   */" + NL + "  uint32_t SdBusWidth : 4;" + NL + "" + NL + "  /**" + NL + "   * This field indicates CPRM Security Specification Version for each" + NL + "   * capacity card." + NL + "   */" + NL + "  uint32_t SdSecurity : 3;" + NL + "" + NL + "  /**" + NL + "   * Defines the data status after erase, whether it is 0 or 1" + NL + "   * (the status is card vendor dependent)." + NL + "   */" + NL + "  uint32_t DataStatAftrErase : 1;" + NL + "" + NL + "  uint32_t Reserved_9_1: 3;" + NL + "" + NL + "  /**" + NL + "   * This field indicates Extended Security which will be defined by a later" + NL + "   *  version of the Part 3 Security Specification Version 3.00." + NL + "   */" + NL + "  uint32_t ExSecurity : 4;" + NL + "" + NL + "  /**" + NL + "   * SD specs version." + NL + "   */" + NL + "  uint32_t SdSpec3 : 1;" + NL + "" + NL + "/**" + NL + "  * Support bit of new commands are defined to Bit 33-32 of SCR." + NL + "  */" + NL + "  uint32_t CmdSupport : 2;" + NL + "" + NL + "  uint32_t Reserved_9_2  : 6;" + NL + "" + NL + "  /**" + NL + "   * Rserved for Manufactures's Usage." + NL + "   */" + NL + "  uint32_t ManufResvd : 32;" + NL + "} SDMMC003_SCRType;" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the Local Lock Struture information." + NL + " */" + NL + "typedef struct SDMMC003_LocalLockStructType" + NL + "{" + NL + "  /**" + NL + "   * 8-bit card lock/unlock mode" + NL + "   */" + NL + "  uint8_t Mode;" + NL + "  /**" + NL + "   * Defines the following password(s) length (in bytes). In case of a password" + NL + "   *  change, this field includes the total password lengths of old and new" + NL + "   *  passwords." + NL + "   */" + NL + "  uint8_t PwdLen;" + NL + "  /**" + NL + "   * In case of setting a new password, it contains the new password. In case of" + NL + "   * a password change, it contains the old password followed by the new password." + NL + "   */" + NL + "  uint8_t PwdData[SDMMC003_MAX_PASSWD_LENGTH * 2];" + NL + "  /* Padding added to make this structure one block of data */" + NL + "  uint32_t Dummy[120];" + NL + "} SDMMC003_LocalLockStructType;" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                       FUNCTION PROTOTYPES                                  **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup SDMMC003_apidoc" + NL + " * @{" + NL + " */" + NL + "/**" + NL + " * @brief This function initializes the Host Controller with the reset values" + NL + " * and configured values in the Host Controller registers.Host Contoller acts as" + NL + " * an intermediary between card and Host. This function is called from " + NL + " * SDMMC003_Start() function." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the initialization is successful<BR>" + NL + " * SDMMC003_ERROR: If the initialization fails .<BR>" + NL + " * <b>Reentrant: Yes </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before " + NL + " *   //Host Controller Init " + NL + " *   DAVE_Init();" + NL + " *   // Host Controller Initialize " + NL + " *   Status = SDMMC003_HostControllerInit();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *     //Call functions as per requirement only after this " + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t  SDMMC003_HostControllerInit(void);" + NL + "" + NL + "/**" + NL + " * @brief This function de-initializes the Host Controller to the reset values." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the de-initialization is successful<BR>" + NL + " * SDMMC003_ERROR: If the de-initialization fails. <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   // Host Controller De-Init. Host Controller should be initialized before this." + NL + " *   Status = SDMMC003_HostControllerDeInit();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *     //Call functions as per requirement only after this " + NL + " *   }" + NL;
  protected final String TEXT_7 = " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t  SDMMC003_HostControllerDeInit( void );" + NL + "" + NL + "/**" + NL + " * @brief The function gets the current SD Bus status from the card. The SD Status " + NL + " * contains status bits that are related to the SD Memory Card proprietary " + NL + " * features and may be used for future application-specific usage. SD Status is of" + NL + " * 512 bits so buffer of 64bytes needs to be passed to this function." + NL + " * @param[out] Buffer Buffer to read SD status into." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If reading SD status is successful.<BR>" + NL + " * SDMMC003_ERROR: If reading SD status fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   uint32_t SdStatus[16]; " + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *       // get sd ststatus ." + NL + " *        Status  = SDMMC003_GetSdStatus((void*)&SdStatus);" + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //Call functions as per requirement only after this " + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t  SDMMC003_GetSdStatus(void *Buffer);" + NL + "" + NL + "/**" + NL + " * @brief The function Erase the blocks of data from the card. It erases the " + NL + " * block of data from address specified in  StartAddr to end address passed" + NL + " * in EndAddr Argument. The erased sectors can be written with '0' or '1' depending " + NL + " * on the erasing technique used by the card. When a large area is erased, " + NL + " * it is divided into small areas at the Allocation Unit boundary and" + NL + " * continuously erases the small areas using a small area erase timeout." + NL + " * @param[in] StartAddr Start Erase Sector Address " + NL + " * @param[in] EndAddr End  Erase Sector Address" + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS:  If erase is successful.<BR>" + NL + " * SDMMC003_ERROR: If erase fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t EraseStart = 121;" + NL + " *   uint32_t EraseEnd = 124;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *       //Erase Sector number 121-124" + NL + " *        Status  =  SDMMC003_EraseBlock(EraseStart,EraseEnd) ;" + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //Call functions as per requirement only after this " + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_EraseBlock" + NL + "(" + NL + "  uint32_t StartAddr," + NL + "  uint32_t EndAddr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief The function performs the lock/unlock related operations like" + NL + " * Locking a card, Unlocking a card, Setting a password, Clearing a password," + NL + " * Replacing a password, Force Erasing a password and Get the current lock status" + NL + " * of the card.  " + NL + " * @param[in] LockPtr Lock Structure of type SDMMC003_LocalLockStructType" + NL + " * containing the password info to be sent to the card." + NL + " * @param[in] OperationMode Lock or Unlock mode." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS:  If locking/unlocking is successful.<BR>" + NL + " * SDMMC003_ERROR:   If locking/unlocking fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   SDMMC003_LocalLockStructType LockStruct = {0};" + NL + " *   uint8_t Passwd[3] = {'I','F','X'};" + NL + " *   uint8_t NewPasswd[5] = {'W','I','P','R','O'};" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *      //  If card detection support available call the below function in while loop." + NL + " *      //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         // Setting the Password to IFX for the first time." + NL + " *        LockStruct.Mode  = 0x01UL;" + NL + " *        LockStruct.PwdLen = 3UL;" + NL + " *        memcpy(LockStruct.PwdData,Passwd,LockStruct.PwdLen );" + NL + " *        Status = SDMMC003_LockUnlockCard(&LockStruct, SDMMC003_UNLOCK);" + NL + " *        if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {  " + NL + " *         // Re-Setting the Password from \"IFX\" to \"WIPRO\" and Lock it. " + NL + " *          LockStruct.Mode  = 0x05UL;" + NL + " *          LockStruct.PwdLen = 8UL; // Includes length of old passwd + new passwd." + NL + " *          memcpy(LockStruct.PwdData,Passwd,3 );" + NL + " *          memcpy(LockStruct.PwdData + 3,NewPasswd,5 );" + NL + " *          Status = SDMMC003_LockUnlockCard(&LockStruct,SDMMC003_LOCK);" + NL + " *          if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *          {" + NL + " *            // Unlock the card with password WIPRO." + NL + " *            LockStruct.Mode = 0x00UL;" + NL + " *            LockStruct.PwdLen = 5UL;" + NL + " *            memcpy(LockStruct.PwdData,NewPasswd,LockStruct.PwdLen );" + NL + " *            Status = SDMMC003_LockUnlockCard(&LockStruct,SDMMC003_UNLOCK);" + NL + " *          }" + NL + " *        }" + NL + " *      }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t  SDMMC003_LockUnlockCard" + NL + "(" + NL + "  SDMMC003_LocalLockStructType  *LockPtr," + NL + "  SDMMC003_CardLockMode  OperationMode" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief The function gets the cuurent lock status from the card. The upper layer" + NL + " * may use this api to know the lock status information." + NL + " * @param[out] LockStatusPtr Pointer to store card lock status information." + NL + " * SDMMC003_CARD_IS_LOCKED: If card is locked <BR>" + NL + " * SDMMC003_CARD_UNLOCKED: If card is unlocked.<BR>" + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS:  If get lock status is successful.<BR>" + NL + " * SDMMC003_ERROR:   If get lock status fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   SDMMC003_LocalLockStructType LockStruct = {0};" + NL + " *   uint32_t LockStatus;" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *      //  If card detection support available call the below function in while loop." + NL + " *      //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        // Get Lock Status " + NL + " *        Status = SDMMC003_GetLockStatus(&LockStatus) ;" + NL + " *        if (LockStatus & SDMMC003_CARD_IS_LOCKED)" + NL + " *        {" + NL + " *          // Card is Locked. " + NL + " *        }" + NL + " *        else" + NL + " *        {" + NL + " *          // Card is unlocked." + NL + " *        } " + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetLockStatus(uint32_t *LockStatusPtr);" + NL + "" + NL + "/**" + NL + " * @brief  This function is use to get card's current state whether the card is" + NL + " * present, initialized,write protected and Host controller is " + NL + " * Initialized or not. It returns state in a combination of flags." + NL + " * @return  status_t <BR>" + NL + " * SDMMC003_STATE_NO_CARD:  If no card is inserted. <BR>" + NL + " * SDMMC003_STATE_CARD_INITIALIZED: If card is initialized.<BR>" + NL + " * SDMMC003_STATE_CARD_WRITE_PROTECT: If card is write protected.<BR>" + NL + " * SDMMC003_STATE_HC_INITIALIZED: If Host Controller is initialized.<BR>" + NL + " * <b>Reentrant:No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        // Get Current State. " + NL + " *         Status  =  SDMMC003_GetCurrentState();" + NL + " *        if ( Status & (uint32_t)SDMMC003_STATE_NO_CARD )" + NL + " *        {" + NL + " *          //NO Card Present" + NL + " *        }" + NL + " *        if ( Status & (uint32_t)SDMMC003_STATE_CARD_INITIALIZED )" + NL + " *        {" + NL + " *          //Card is initialized Successfully." + NL + " *        }" + NL + " *        if ( Status & (uint32_t)SDMMC003_STATE_HC_INITIALIZED )" + NL + " *        {" + NL + " *          //Host Controller is initialized Successfully." + NL + " *        }" + NL + " *        if ( Status & (uint32_t)SDMMC003_STATE_CARD_WRITE_PROTECT  )" + NL + " *        {" + NL + " *          //Card is write protected." + NL + " *        }" + NL + " *        if ( Status & (uint32_t)SDMMC003_STATE_CARD_LOCKED )" + NL + " *        {" + NL + " *          //Card is Locked. Unlock it first to use it" + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetCurrentState(void);" + NL + "" + NL + "/**" + NL + " * @brief  This function is use to get card type information." + NL + " * @param[in] CardTypePtr Pointer to store card type information.Card Type can be:<BR>" + NL + " * <b>SDMMC003_SD_STANDARD_CAPACITY_V2:</b> Standard Capacity Card of Version2. <BR>" + NL + " * <b>SDMMC003_SD_STANDARD_CAPACITY_V1x:</b> Standard Capacity Card of Version1x.<BR>" + NL + " * <b>SDMMC003_SD_HIGH_CAPACITY :</b> High Capacity Card .<BR>" + NL + " * <b>SDMMC003_MMC  </b>: MMC card. <BR>" + NL + " * If the card takes address in terms of sectors then Card Type will be in " + NL + " * combination of <b> SDMMC003_BLOCK_ADDRESSING </b> flag ." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS:  If get card type api is success.<BR>" + NL + " * SDMMC003_ERROR: If get card type api  fails.<BR>" + NL + " * <b>Reentrant:No </b><BR>" + NL + " * <b><Sync/Async:  Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t CardType = 0;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         Status = SDMMC003_GetCardType(&CardType)  ;" + NL + " *         if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *         {" + NL + " *           if( CardType & SDMMC003_SD_STANDARD_CAPACITY_V2)" + NL + " *           {" + NL + " *             // Standard Capacity Card version2" + NL + " *           }" + NL + " *           if( CardType & SDMMC003_SD_STANDARD_CAPACITY_V1x)" + NL + " *           {" + NL + " *             // Standard Capacity Card version1." + NL + " *           } " + NL + " *           if( CardType & SDMMC003_SD_HIGH_CAPACITY)" + NL + " *           {" + NL + " *             // High Capacity Card." + NL + " *           }" + NL + " *         }" + NL + " *       }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetCardType(uint32_t* CardTypePtr);" + NL + "" + NL + "/**" + NL + " * @brief  This function is use to Get CID( Card identification Number) register" + NL + " * information of card. The CID register is of 128 bits. The upper layer needs to" + NL + " * pass buffer of type SDMMC003_SDCIDType to get the Card's CID data." + NL + " * @param[in] Buffer Pointer of type SDMMC003_SDCIDType to store CID register information." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS:  If Get CID is success.<BR>" + NL + " * SDMMC003_ERROR:   If Get CID fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   //Define a CID STructure ." + NL + " *   SDMMC003_SDCIDType SDCid;" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         Status = SDMMC003_GetCid( (void *)&SDCid); " + NL + " *         if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *         {" + NL + " *          //CID read successfully." + NL + " *         }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetCid(void *Buffer);" + NL + "" + NL + "/**" + NL + " * @brief  This function is use to Get OCR(Operation conditions register) information from the card." + NL + " * OCR is of 32-bits thus the upper Layer needs to pass 32-bit buffer to get the OCR. " + NL + " * @param[in] Buffer Pointer to store OCR register information." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Get OCR is success.<BR>" + NL + " * SDMMC003_ERROR: If Get OCR fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   //Define a 32-bit OCR variable" + NL + " *   uint32_t Ocr = 0;" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         //Read OCR" + NL + " *        Status = SDMMC003_GetOcr( (void *)&Ocr); " + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //OCR read successfully." + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL;
  protected final String TEXT_8 = " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetOcr(void *Buffer);" + NL + "" + NL + "/**" + NL + " * @brief  This function is use to Get CSD( Card Specific Data ) information from the card." + NL + " * CSD is of 128 bits. The upper layer needs to pass structure of type SDMMC003_CSDV1Type" + NL + " * (For Standard Capacity V1/2 card type ) and SDMMC003_CSDV2Type(For High Capacity card type)" + NL + " * @param[in] Buffer Pointer to store CSD register information." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Get CSD is success.<BR>" + NL + " * SDMMC003_ERROR: If Get CSD fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   SDMMC003_CSDV2Type SDCsd;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         // Read CSD" + NL + " *        // first call cardtype function to check which card type is it. csd v1 or csdv2 ." + NL + " *        // for high capacity & Standard capcity v2, use V2 csd structure else" + NL + " *        // Use Csd V1 structure." + NL + " *        Status = SDMMC003_GetCsd((void *)&SDCsd);" + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //CSD Read successfully." + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetCsd (void *Buffer);" + NL + "/**" + NL + " * @brief  This function is use to get number of sectors (not include the security protected" + NL + " * area). on the card. The upper layer needs to pass 32-bit buffer to store the" + NL + " * sector count." + NL + " * @param[in] Buffer Pointer to store Sector Count." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Get Sector count is success.<BR>" + NL + " * SDMMC003_ERROR: If Get Sector count fails.<BR>" + NL + " * <b>Reentrant:No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t SectorInfo;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         //Get sector Count" + NL + " *        Status = SDMMC003_GetSectorCount((void *)&SectorInfo);" + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //Get sector Count Read successfully." + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetSectorCount( void *Buffer );" + NL + "/**" + NL + " * @brief  This function is use to get size of each sector on the card which is" + NL + " * fixed to 512bytes. The upper layer needs to pass 32-bit buffer to store the" + NL + " * sector size." + NL + " * @param[in] Buffer Pointer to store Sector Size" + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Get Sector Size is success.<BR>" + NL + " * SDMMC003_ERROR: If Get Sector Size fails.<BR>" + NL + " * <b>Reentrant:No  </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t SectorInfo;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         //Get sector size" + NL + " *        Status = SDMMC003_GetSectorSize((void *)&SectorInfo);" + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //Get sector size Read successfully." + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetSectorSize  ( void *Buffer );" + NL + "" + NL + "/**" + NL + " * @brief  This function returns erase block size,value, defining the" + NL + " * number of write blocks of the flash memory in unit of sector into the " + NL + " * 32-bit variable pointed by buffer. " + NL + " * @param[in] Buffer Pointer to store Block Size" + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Get Block Size is success.<BR>" + NL + " * SDMMC003_ERROR: If Get Block Size fails.<BR>" + NL + " * <b>Reentrant:No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t SectorInfo;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *         //Get Block Size" + NL + " *        Status = SDMMC003_GetBlockSize((void *)&SectorInfo);" + NL + " *        if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          //Get Block size Read successfully." + NL + " *        }" + NL + " *     }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_GetBlockSize(void *Buffer);" + NL + "/**" + NL + " * @brief  This function is used inorder to make sure that the disk drive has" + NL + " * finished pending write process. When the disk I/O module has a write" + NL + " * back cache, flush the dirty sector immediately." + NL + " * Currently this function doesn't do anything." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Flush Disk Cache is success.<BR>" + NL + " * SDMMC003_ERROR: If Flush Disk Cache fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_FlushDiskWriteCache( void);" + NL + "/**" + NL + " * @brief  The function is used to read multiple blocks of data from the card." + NL + " * @param[out] ReadBufPtr Read buffer pointer to store data." + NL + " * @param[in] ReadAddr Card address form where to read." + NL + " * @param[in] NumberOfBlocks Number of blocks to read." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If multi read is success.<BR>" + NL + " * SDMMC003_READ_ERROR: If read fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t  WriteData[384];" + NL + "*    uint32_t  ReadData[384];" + NL + " *   uint32_t Count;" + NL + " *   uint32_t Counter;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        for(Counter=0;Counter<384;Counter++)" + NL + " *        {" + NL + " *          WriteData[Counter] = Counter * 1;" + NL + " *        }" + NL + " *        //Write 3 blocks of data on sector 125-127" + NL + " *        Status = SDMMC003_CardWriteMultipleBlocks( WriteData,125,3 );" + NL + " *        if( Status == DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *         //Read 3 blocks of data from sector 125-128" + NL + " *          Status = SDMMC003_CardReadMultipleBlocks(ReadData,125,3);   " + NL + " *          if( Status == DAVEApp_SUCCESS)" + NL + " *          {" + NL + " *            for( Count=0; Count<384; Count++)" + NL + " *            {" + NL + " *              if( ReadData[Count] != WriteData[Count])" + NL + " *              {" + NL + " *                Status = SDMMC003_ERROR;" + NL + " *                break;" + NL + " *              }           " + NL + " *            }" + NL + " *          }                   " + NL + " *        }" + NL + " *      }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_CardReadMultipleBlocks" + NL + "(" + NL + "  uint32_t *ReadBufPtr ," + NL + "  uint32_t ReadAddr," + NL + "  uint32_t NumberOfBlocks" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief  The function is used to write multiple blocks of data on the card." + NL + " * @param[in] WriteBufPtr Data to write on the card." + NL + " * @param[in] WriteAddr Card address on where to write." + NL + " * @param[in] NumberOfBlocks Number of blocks to write" + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If multi write is success.<BR>" + NL + " * SDMMC003_WRITE_ERROR: If write fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t  WriteData[384];" + NL + " *   uint32_t  ReadData[384];" + NL + " *   uint32_t Count;" + NL + " *   uint32_t Counter;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        for(Counter=0;Counter<384;Counter++)" + NL + " *        {" + NL + " *          WriteData[Counter] = Counter * 1;" + NL + " *        }" + NL + " *        //Write 3 blocks of data on sector 125-127" + NL + " *        Status = SDMMC003_CardWriteMultipleBlocks( WriteData,125,3 );" + NL + " *        if( Status == DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *         //Read 3 blocks of data from sector 125-128" + NL + " *          Status = SDMMC003_CardReadMultipleBlocks(ReadData,125,3);   " + NL + " *          if( Status == DAVEApp_SUCCESS)" + NL + " *          {" + NL + " *            for( Count=0; Count<384; Count++)" + NL + " *            {" + NL + " *              if( ReadData[Count] != WriteData[Count])" + NL + " *              {" + NL + " *                Status = SDMMC003_ERROR;" + NL + " *                break;" + NL + " *              }           " + NL + " *            }" + NL + " *          }                   " + NL + " *        }" + NL + " *      }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_CardWriteMultipleBlocks" + NL + "(" + NL + "  const uint32_t *WriteBufPtr," + NL + "  uint32_t WriteAddr," + NL + "  uint32_t NumberOfBlocks" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief  The function is used to read single block of data from the card." + NL + " * @param[in] ReadBufPtr Read buffer pointer to store data read from the card." + NL + " * @param[in] ReadAddr Card address form where to read." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If  read is success.<BR>" + NL + " * SDMMC003_READ_ERROR: If read fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t  WriteData[128];" + NL + " *    uint32_t  ReadData[128];" + NL + " *   uint32_t Count;" + NL + " *   uint32_t Counter;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        for(Counter=0;Counter<128;Counter++)" + NL + " *        {" + NL + " *          WriteData[Counter] = Counter * 1;" + NL + " *        }" + NL + " *        //Write 1 block of data on sector 200" + NL + " *        Status = SDMMC003_CardWriteSingleBlock( WriteData, 200);" + NL + " *        if( Status == DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *         //Read 1 block of data from sector 200" + NL + " *          Status = SDMMC003_CardReadSingleBlock(ReadData,200);   " + NL + " *          if( Status == DAVEApp_SUCCESS)" + NL + " *          {" + NL + " *            for( Count=0; Count<128; Count++)" + NL + " *            {" + NL + " *              if( ReadData[Count] != WriteData[Count])" + NL + " *              {" + NL + " *                Status = SDMMC003_ERROR;" + NL + " *                break;" + NL + " *              }           " + NL + " *            }" + NL + " *          }                   " + NL + " *        }" + NL + " *      }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_CardReadSingleBlock" + NL + "(" + NL + "  uint32_t *ReadBufPtr," + NL + "  uint32_t ReadAddr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief  The function is used to write single block of data on the card." + NL + " * @param[in] WriteBufPtr Data to write on the card." + NL + " * @param[in] WriteAddr Card address on where to write" + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If write is success.<BR>" + NL + " * SDMMC003_WRITE_ERROR: If write fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   uint32_t  WriteData[128];" + NL + " *   uint32_t  ReadData[128];" + NL + " *   uint32_t Count;" + NL + " *   uint32_t Counter;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL;
  protected final String TEXT_9 = " *        for(Counter=0;Counter<128;Counter++)" + NL + " *        {" + NL + " *          WriteData[Counter] = Counter * 1;" + NL + " *        }" + NL + " *        //Write 1 block of data on sector 200" + NL + " *        Status = SDMMC003_CardWriteSingleBlock( WriteData, 200);" + NL + " *        if( Status == DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *         //Read 1 block of data from sector 200" + NL + " *          Status = SDMMC003_CardReadSingleBlock(ReadData,200);   " + NL + " *          if( Status == DAVEApp_SUCCESS)" + NL + " *          {" + NL + " *            for( Count=0; Count<128; Count++)" + NL + " *            {" + NL + " *              if( ReadData[Count] != WriteData[Count])" + NL + " *              {" + NL + " *                Status = SDMMC003_ERROR;" + NL + " *                break;" + NL + " *              }           " + NL + " *            }" + NL + " *          }                   " + NL + " *        }" + NL + " *      }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_CardWriteSingleBlock" + NL + "(" + NL + "  const uint32_t *WriteBufPtr," + NL + "  uint32_t WriteAddr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief  This function is use to de-activate or inactivates the card. The card" + NL + " * needs to be initalized again after deactivating it." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If card ejection is success.<BR>" + NL + " * SDMMC003_ERROR: If error occurs.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // DAVE Initialization. SDMMC003_Init() is mandatory to be called before hand." + NL + " *   DAVE_Init();" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *    //  If card detection support available call the below function in while loop." + NL + " *    //while(1) {" + NL + " *      Status = SDMMC003_CardDetectionSupport();" + NL + " *      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        Status = SDMMC003_EjectCard();" + NL + " *        if( Status == DAVEApp_SUCCESS)" + NL + " *        {" + NL + " *          // Card Ejected Successfully. You need to initialize the card" + NL + " *          // again inorder to access the card." + NL + " *        }" + NL + " *      }" + NL + " *   // } End of while loop. uncomment  it if SDCD signal supported" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_EjectCard(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief  This function will bring the SDMMC peripheral out of reset." + NL + " * @return  void <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_Init(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief  This function performs the Host Controller Initialization and enables" + NL + " * the SDMMC Interrupt. Host Controller needs to be compulsarily initialized " + NL + " * before establishing any communication with the card." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If Start api is success.<BR>" + NL + " * SDMMC003_ERROR: If error occurs.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   Status = SDMMC003_Start();" + NL + "     return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_Start(void);" + NL + "" + NL + "/**" + NL + " * @brief This function performs the card initialization and reading card registers" + NL + " * post card initialization.If card detection Support fails due to  \"SDMMC003_INITIALIZED_BUT_LOCKED\"," + NL + " * then you need to call card unlock api and then again call card detection support " + NL + " * function else you cannot proceed further as Card Registers can be read only" + NL + " * if card is in unlocked state. In case of Non-Card Detection circuit, it will be called " + NL + " * in the upper layer disk_init function. In Card Detection circuit it must be " + NL + " * called in the infinite loop." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If function is success.<BR>" + NL + " * SDMMC003_ERROR: If error occurs.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   Status = SDMMC003_Start();" + NL + " *   if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *     Status = SDMMC003_CardDetectionSupport();" + NL + " *     if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + " *     {" + NL + " *       //Call functions as per requirement only after this " + NL + " *     }" + NL + " *   }" + NL + " *   return Status;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_CardDetectionSupport(void);" + NL + "" + NL + "#if SDMMC_CARD_DETECTION_SUPPORT" + NL + "/**" + NL + " * @brief This function registers the call back function of upper layer which will be " + NL + " * invoked from low-level driver if card is inserted or removed in the kit" + NL + " * supporting Card detection mechanism." + NL + " * WARNING!!! \"Don't Call SDMMC003_CardDetectionSupport() here as this function is" + NL + " * invoked in interrupt context.\" SDMMC003_CardDetectionSupport() may trigger some" + NL + " * other interrupts which may thus lead to nested interrupts in interrupt context." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If function is success.<BR>" + NL + " * SDMMC003_ERROR: If null call back function pointer is passed.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t Status = SDMMC003_ERROR;" + NL + " *   // Call back function defined in the upper layer " + NL + " *   void SDMMC_CallBackFuntion(SDMMC003_InterruptType CardState)" + NL + " *   {" + NL + " *     if (CardState == SDMMC003_CARD_INSERTION )" + NL + " *     {" + NL + " *       //NOTE: Set a flag here and in the main process context call card detection" + NL + " *       // support function in while loop switched on to the flag set over here." + NL + " *       //If Card Detection Support Function is success then also set the " + NL + " *       //Sdmmc Block Layers SDMMC001_InitializeFlag to 1 indicating that" + NL + " *       // Card is initialized. " + NL + " *     }" + NL + " *     if (CardState == SDMMC003_CARD_REMOVAL)" + NL + " *     {" + NL + " *       // Card Cleanup " + NL + " *       SDMMC003_lCardCleanUp();" + NL + " *       // Change the State machine  to De-initialized " + NL + " *       SDMMC003_Handle.State &= ~(  SDMMC003_STATE_CARD_INITIALIZED | \\" + NL + " *                                SDMMC003_STATE_CARD_WRITE_PROTECT | \\" + NL + " *                                SDMMC003_STATE_CMD_ACTIVE | \\" + NL + " *                                SDMMC003_STATE_DATA_ACTIVE | \\" + NL + " *                                SDMMC003_STATE_CARD_LOCKED) | \\" + NL + " *                                (SDMMC003_STATE_NO_CARD);" + NL + " *       // Reset the Registers." + NL + " *       SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_ALL_Msk);" + NL + " *     }" + NL + " *   }" + NL + " *   Status = SDMMC003_RegisterCallBack(&SDMMC_CallBackFuntion); " + NL + " *   if (Status != (uint32_t) DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *     //  Call Back Function is Null " + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "status_t SDMMC003_RegisterCallBack(SDMMC003_PtrToCallBackFunction \\" + NL + "                                             CallbackFunction);" + NL + "#endif" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "#endif /* SDMMC003_H_ */" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL + NL + NL + NL + NL + NL + NL + NL;
  protected final String TEXT_10 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/sdmmc003/"; 
     int appInst = 0; 
     int RTOS = app.getIntegerValue(AppBaseuri + appInst + "/sdmmc003_rtos_present");
   String  Module_Name = "SDMMC003";

    stringBuffer.append(TEXT_2);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_3);
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(TEXT_8);
    stringBuffer.append(TEXT_9);
    stringBuffer.append(TEXT_10);
    return stringBuffer.toString();
  }
}
