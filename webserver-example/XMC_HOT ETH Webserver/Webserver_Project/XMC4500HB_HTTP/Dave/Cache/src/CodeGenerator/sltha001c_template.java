package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class sltha001c_template
{
  protected static String nl;
  public static synchronized sltha001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    sltha001c_template result = new sltha001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/* CODE_BLOCK_BEGIN[SLTHA001.c]*/" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : July 31, 2012                                          **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/" + NL + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = NL + NL + "/**" + NL + " * @file   ";
  protected final String TEXT_4 = ".c" + NL + " *" + NL + " * @brief  This file contains definitions of all private and public" + NL + " *         functions of Standard Library App." + NL + " */" + NL + "" + NL + "/*****************************************************************************" + NL + " * INCLUDE FILES" + NL + " *****************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "" + NL + "#ifdef ";
  protected final String TEXT_5 = "_ELUA_IN_USE" + NL + "#include \"../../src/LUA001/elua0.8/inc/newlib/devman.h\"" + NL + "#include \"../../src/LUA001/elua0.8/inc/newlib/genstd.h\"" + NL + "" + NL + "#endif" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/**" + NL + " * @ingroup ";
  protected final String TEXT_6 = "_privatefunc" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief  This function finds whether the file is already opened and also assign a slot for any new " + NL + " * file to open." + NL + " * @param[in] FileDesc File Descriptor for which slot to find." + NL + " * @return : uint32_t <BR>" + NL + " * Slot Number: Allocated Slot Number." + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "uint32_t  ";
  protected final String TEXT_7 = "_lFindAvailableSlot(int FileDesc);" + NL + "" + NL + "/**" + NL + " * @brief Function to Initialize all the local variables and file descriptors. This function should be" + NL + " * called at the very first ." + NL + " * @return : void <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void ";
  protected final String TEXT_8 = "_lLocalInitialize(void);" + NL + "" + NL + "#if _FS_MINIMIZE == 0" + NL + "#if defined (__GNUC__) || defined ( __TASKING__)" + NL + "/**" + NL + " * @brief  This function finds whether the file is already opened and also assign a slot for any new " + NL + " * file to open." + NL + " * @param[in] FatFsInfoPtr Pointer to File Info Structure." + NL + " * @return : time_t <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "static time_t ";
  protected final String TEXT_9 = "_lTimeFormat(FILINFO *FatFsInfoPtr);" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief  Function to store the file information in the file status pointer " + NL + " * @param[out] FileStatusPtr Pointer to stat Structure." + NL + " * @param[in] FatFsInfoPtr Pointer to File Info Structure." + NL + " * @return : void <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "static void ";
  protected final String TEXT_10 = "_lFatInfoToStatus(struct stat *FileStatusPtr, \\" + NL + "                                      FILINFO *FatFsInfoPtr);" + NL + "" + NL + "#endif" + NL + "#endif" + NL + "/**" + NL + " * @brief  This function set the file access modes ." + NL + " * @param[in] FlagsPtr Flags passed by the user" + NL + " * @param[out] FatFsFlagPtr Pointer to Fat file system flags type." + NL + " * @return : status_t/_err_t  <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "#ifdef  __TASKING__" + NL + "  static _err_t ";
  protected final String TEXT_11 = "_lSetFlagsAccessModes( _open_flags_t *FlagsPtr, \\" + NL + "                                            BYTE *FatFsFlagPtr );" + NL + "#else" + NL + "  static status_t ";
  protected final String TEXT_12 = "_lSetFlagsAccessModes( int *FlagsPtr, \\" + NL + "                                                 BYTE *FatFsFlagPtr );" + NL + "#endif" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                ARRAYS                                      **" + NL + " ******************************************************************************/" + NL + "#if defined(__GNUC__) || defined(__TASKING__)" + NL + "uint32_t ErrorCodes[19] = {" + NL + "                             DAVEApp_SUCCESS,  FILE_WRAPPER_ERROR," + NL + "                             FILE_WRAPPER_ERROR, EIO," + NL + "                             ENOENT,             ENOENT," + NL + "                             EINVAL,             EACCES," + NL + "                             EEXIST,             EBADF," + NL + "                             EACCES,             ENODEV," + NL + "                             EIO,                EIO," + NL + "                             FILE_WRAPPER_ERROR, FILE_WRAPPER_ERROR," + NL + "                             FILE_WRAPPER_ERROR, FILE_WRAPPER_ERROR," + NL + "                             FILE_WRAPPER_ERROR" + NL + "                          };" + NL + "#elif defined __CC_ARM" + NL + "uint32_t ErrorCodes[19] = { EINVAL };" + NL + "#elif defined __ICCARM__" + NL + "uint32_t ErrorCodes[19] = {_LLIO_ERROR};" + NL + "#endif" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/";
  protected final String TEXT_13 = NL;
  protected final String TEXT_14 = "_FileHandleStruct FileHandle[MAX_OPEN_FILES] = {{0}};" + NL + "#ifdef ";
  protected final String TEXT_15 = "_ELUA_IN_USE" + NL + "static DIR ";
  protected final String TEXT_16 = "_MmcDir;" + NL + "" + NL + "extern struct dm_dirent dm_shared_dirent;" + NL + "extern char dm_shared_fname[ DM_MAX_FNAME_LENGTH + 1 ];" + NL + "#endif" + NL + "" + NL + "" + NL + "#ifdef __CC_ARM" + NL + "/** Standard IO device name defines. */" + NL + "const char __stdin_name[]  = \"STDIN\";" + NL + "const char __stdout_name[] = \"STDOUT\";" + NL + "const char __stderr_name[] = \"STDERR\";" + NL + "#endif" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/* <<<DD_";
  protected final String TEXT_17 = "_nonAPI_1>>> */" + NL + "/* " + NL + " * Function to find whether the file is already opened and also assign a slot for any new " + NL + " * file to open." + NL + " */" + NL + "uint32_t  ";
  protected final String TEXT_18 = "_lFindAvailableSlot(int FileDesc)" + NL + "{" + NL + "  static int Slot;" + NL + "  static int LastAllocFileHandle = -1;" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_";
  protected final String TEXT_19 = "_nonAPI_1_1>>> */" + NL + "    /* Check if the File handle is the last allocated one */" + NL + "    if( (FileDesc != -1)  && (FileDesc == LastAllocFileHandle))" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_";
  protected final String TEXT_20 = "_nonAPI_1_2>>> */" + NL + "    /* Check the FileHandle array to find the match for the File Handle*/" + NL + "    for (Slot=0; Slot< MAX_OPEN_FILES; Slot++)" + NL + "    {" + NL + "      if(FileHandle[Slot].Fd == FileDesc)" + NL + "      break;" + NL + "    }" + NL + "    /* Save the last Allocated File Handle.*/" + NL + "    LastAllocFileHandle = FileDesc;" + NL + "  } while(0);" + NL + "  return Slot;" + NL + "}" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_21 = "_nonAPI_2>>>*/" + NL + "/*" + NL + " * Function to Initialize all the local variables and file descriptors. This function should be" + NL + " * called very first ." + NL + " */" + NL + "void ";
  protected final String TEXT_22 = "_lLocalInitialize()" + NL + "{" + NL + "  int Slot;" + NL + "/* Initialize Handle in the FileHandle Structure to -1*/" + NL + "  for(Slot=0; Slot<MAX_OPEN_FILES; Slot++)" + NL + "  {" + NL + "    FileHandle[Slot].Fd = -1;" + NL + "  }" + NL + "/* Preserve the 0th, 1th and 2nd File Handles for Standard I/O and Error.*/" + NL + "  FileHandle [0].Fd = STDIN_HANDLE;" + NL + "  FileHandle [1].Fd = STDOUT_HANDLE;" + NL + "  FileHandle [2].Fd = STDERR_HANDLE;" + NL + "}" + NL + "" + NL + "" + NL + "#if _FS_MINIMIZE == 0" + NL + "#if defined (__GNUC__) || defined ( __TASKING__)" + NL + "/* <<<DD_";
  protected final String TEXT_23 = "_nonAPI_4>>> */" + NL + "/*" + NL + " * This function converts the time format " + NL + " */" + NL + "static time_t ";
  protected final String TEXT_24 = "_lTimeFormat(FILINFO *FatFsInfoPtr)" + NL + "{" + NL + "  struct tm TimeStruct;" + NL + "  TimeStruct.tm_sec  = (FatFsInfoPtr->ftime & 0x001f) << 1;" + NL + "  TimeStruct.tm_min  = (FatFsInfoPtr->ftime & 0x07e0) >> 5;" + NL + "  TimeStruct.tm_hour = (FatFsInfoPtr->ftime & 0xf800) >> 11;" + NL + "  TimeStruct.tm_mday = (FatFsInfoPtr->fdate & 0x001f);" + NL + "  TimeStruct.tm_mon  = ((FatFsInfoPtr->fdate & 0x01e0) >> 5) - 1;" + NL + "  TimeStruct.tm_year = ((FatFsInfoPtr->fdate & 0xfe00) >> 9) + 80;" + NL + "  TimeStruct.tm_isdst = 0;" + NL + "  return mktime(&TimeStruct);" + NL + "}" + NL + "#endif" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_25 = "_nonAPI_5>>> */" + NL + "/*" + NL + " *  Function to store the file information in the file status pointer " + NL + " */" + NL + "#if defined (__GNUC__) || defined ( __TASKING__)" + NL + "static void ";
  protected final String TEXT_26 = "_lFatInfoToStatus(struct stat *FileStatusPtr, \\" + NL + "                                      FILINFO *FatFsInfoPtr)" + NL + "{" + NL + "  memset(FileStatusPtr, 0, sizeof(*FileStatusPtr));" + NL + "  /*Populate the Argument Status Pointer with the Fat FS status Pointer*/" + NL + "  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_DIR) ? \\" + NL + "                                                            S_IFDIR : S_IFREG;" + NL + "  " + NL + "#if defined (__GNUC__)" + NL + "  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ? \\" + NL + "                                                 ((S_IRWXU & ~S_IWUSR) | \\" + NL + "                                                 (S_IRWXG & ~S_IWGRP) | \\" + NL + "                                                 (S_IRWXO & ~S_IWOTH)) : \\" + NL + "                                                 (S_IRWXU | S_IRWXG | S_IRWXO);" + NL + "#else" + NL + "" + NL + "  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ? \\" + NL + "                                                    (~_S_IWRITE)  : \\" + NL + "                                                    (_S_IWRITE);" + NL + "#endif" + NL + "  FileStatusPtr->st_size = FatFsInfoPtr->fsize;" + NL + "  FileStatusPtr->st_ctime = ";
  protected final String TEXT_27 = "_lTimeFormat(FatFsInfoPtr);" + NL + "  FileStatusPtr->st_mtime = FileStatusPtr->st_ctime;" + NL + "  FileStatusPtr->st_atime = FileStatusPtr->st_ctime;" + NL + "#if defined (__GNUC__)" + NL + "  FileStatusPtr->st_blksize = 512;" + NL + "#endif" + NL + "}" + NL + "#endif" + NL + "#endif" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_28 = "_nonAPI_6>>> */" + NL + "/*" + NL + " * This function set the file access modes " + NL + " */" + NL + "#ifdef  __TASKING__" + NL + "  static _err_t ";
  protected final String TEXT_29 = "_lSetFlagsAccessModes( _open_flags_t *FlagsPtr, \\" + NL + "                                            BYTE *FatFsFlagPtr )" + NL + "#else" + NL + "  static status_t ";
  protected final String TEXT_30 = "_lSetFlagsAccessModes( int *FlagsPtr, \\" + NL + "                                                 BYTE *FatFsFlagPtr )" + NL + "#endif" + NL + "{" + NL + "#ifdef  __TASKING__" + NL + "  _err_t Status = FILE_WRAPPER_ERROR;" + NL + "#else" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#endif" + NL + "  do" + NL + "  {" + NL + "#if defined(__GNUC__) || defined( __TASKING__) || defined(__ICCARM__ )" + NL + "/*<<<DD_";
  protected final String TEXT_31 = "_nonAPI_6_1>>> */" + NL + "     /*  Append and Truncate flags cannot be set together */" + NL + "    if (*FlagsPtr & ";
  protected final String TEXT_32 = "_APPEND)" + NL + "    {" + NL + "      *FlagsPtr &= ~";
  protected final String TEXT_33 = "_TRUNC ;" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_34 = "_nonAPI_6_2>>> */" + NL + "    /* Create & Truncate & Access mode is Write */" + NL + "    if ( ((*FlagsPtr & (";
  protected final String TEXT_35 = "_CREAT | ";
  protected final String TEXT_36 = "_TRUNC)) ==" + NL + "         (";
  protected final String TEXT_37 = "_CREAT | ";
  protected final String TEXT_38 = "_TRUNC)) && (*FlagsPtr & (";
  protected final String TEXT_39 = "_RDWR | \\";
  protected final String TEXT_40 = NL + "                                                             ";
  protected final String TEXT_41 = "_WRONLY)))" + NL + "    {" + NL + "#if _FS_READONLY" + NL + "      break;" + NL + "#else" + NL + "      *FatFsFlagPtr = FA_CREATE_ALWAYS;" + NL + "#endif" + NL + "    }" + NL + "    /* O_EXCL  When used with O_CREAT, if the file already exists it is an error" + NL + "    *  and the open() will fail. */" + NL + "/*<<<DD_";
  protected final String TEXT_42 = "_nonAPI_6_3>>> */" + NL + "    else if ((*FlagsPtr & (";
  protected final String TEXT_43 = "_CREAT | ";
  protected final String TEXT_44 = "_EXCL)) ==" + NL + "                          (";
  protected final String TEXT_45 = "_CREAT | ";
  protected final String TEXT_46 = "_EXCL))" + NL + "    {" + NL + "      *FatFsFlagPtr = FA_OPEN_EXISTING;" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_47 = "_nonAPI_6_4>>> */" + NL + "    /* Only create flag is set, opens the file if exist else creates a new file */" + NL + "    else if ((*FlagsPtr & ";
  protected final String TEXT_48 = "_CREAT) == ";
  protected final String TEXT_49 = "_CREAT)" + NL + "    {" + NL + "#if _FS_READONLY" + NL + "       break;" + NL + "#else" + NL + "      *FatFsFlagPtr = FA_OPEN_ALWAYS;" + NL + "#endif" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_50 = "_nonAPI_6_5>>> */" + NL + "    /* Opens the file if any of the read, write or r/w flags are only set*/" + NL + "    else if ((*FlagsPtr == ";
  protected final String TEXT_51 = "_RDONLY) || (*FlagsPtr == ";
  protected final String TEXT_52 = "_WRONLY)" + NL + "                                            || (*FlagsPtr == ";
  protected final String TEXT_53 = "_RDWR))" + NL + "    {" + NL + "      *FatFsFlagPtr = FA_OPEN_EXISTING;" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_54 = "_nonAPI_6_6>>> */" + NL + "    else" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = EINVAL;" + NL + "#elif defined( __ICCARM__)                              " + NL + "      errno = _LLIO_ERROR;" + NL + "#endif" + NL + "      break;" + NL + "    }" + NL + "#endif" + NL + "/*<<<DD_";
  protected final String TEXT_55 = "_nonAPI_6_7>>> */" + NL + "    /* Check the access mode */" + NL + "#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )" + NL + "    if ((*FlagsPtr & ";
  protected final String TEXT_56 = "_RDWRMASK) == ";
  protected final String TEXT_57 = "_RDONLY)" + NL + "#elif defined __CC_ARM" + NL + "    if (*FlagsPtr &  ";
  protected final String TEXT_58 = "_RDONLY)" + NL + "#endif" + NL + "    {" + NL + "      *FatFsFlagPtr |= FA_READ;" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_59 = "_nonAPI_6_8>>> */" + NL + "#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )" + NL + "    else if ((*FlagsPtr & ";
  protected final String TEXT_60 = "_RDWRMASK) == ";
  protected final String TEXT_61 = "_WRONLY)" + NL + "#elif defined __CC_ARM" + NL + "    else if(*FlagsPtr &  ";
  protected final String TEXT_62 = "_WRONLY)" + NL + "#endif" + NL + "    {" + NL + "#if _FS_READONLY" + NL + "      break;" + NL + "#else" + NL + "      *FatFsFlagPtr |= FA_WRITE;" + NL + "#endif" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_63 = "_nonAPI_6_9>>> */" + NL + "#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )" + NL + "    else if ((*FlagsPtr & ";
  protected final String TEXT_64 = "_RDWRMASK) == ";
  protected final String TEXT_65 = "_RDWR)" + NL + "#elif defined __CC_ARM" + NL + "    else if (*FlagsPtr & ";
  protected final String TEXT_66 = "_RDWR)" + NL + "#endif" + NL + "    {" + NL + "#if _FS_READONLY" + NL + "      break;" + NL + "#else" + NL + "      *FatFsFlagPtr |= (FA_READ | FA_WRITE);" + NL + "#endif" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_67 = "_nonAPI_6_10>>> */" + NL + "    else" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = EINVAL;" + NL + "#elif defined  __ICCARM__" + NL + "      errno = _LLIO_ERROR;" + NL + "#elif defined __CC_ARM" + NL + "      errno = EINVAL;" + NL + "#endif" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "" + NL + "/******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "/* <<<DD_";
  protected final String TEXT_68 = "_API_1>>> */" + NL + "/*" + NL + " * This function opens the file specified by the Path in the mode " + NL + " */" + NL + "#ifdef __GNUC__" + NL + "int _open" + NL + "(" + NL + "   const TCHAR *Path," + NL + "   int Flags,..." + NL + ")" + NL + "#elif __CC_ARM" + NL + "" + NL + "FILEHANDLE _sys_open" + NL + "(" + NL + "  const char  *Path," + NL + "  int Flags" + NL + ")" + NL + "#elif  __TASKING__" + NL + "_err_t _open" + NL + "(" + NL + "  const char *Path," + NL + "  _open_flags_t Flags" + NL + ")" + NL + "#elif  __ICCARM__" + NL + "int __open" + NL + "(" + NL + "  const char * Path," + NL + "  int Flags" + NL + ")" + NL + "#endif" + NL + "{" + NL + "#ifdef  __TASKING__" + NL + "  _err_t Status = FILE_WRAPPER_ERROR;" + NL + "  _err_t FileDesc = 0;" + NL + "#else" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "  int FileDesc = 0;" + NL + "#endif" + NL + "  int  SlotNumber;" + NL + "  uint32_t PathLen = 0;" + NL + "  BYTE FatFsFlags = FA_OPEN_EXISTING;" + NL + "  FRESULT Result;" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_";
  protected final String TEXT_69 = "_API_1_1>>> */" + NL + "/*  Check free slot is available to open the file. If not then return error. */" + NL + "    SlotNumber = ";
  protected final String TEXT_70 = "_lFindAvailableSlot(EMPTY_SLOT);" + NL + "    if (SlotNumber == MAX_OPEN_FILES)" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = ENFILE;" + NL + "#elif defined __CC_ARM" + NL + "      errno =  EINVAL;" + NL + "#elif defined  __ICCARM__" + NL + "      errno = _LLIO_ERROR;" + NL + "#endif" + NL + "      break;" + NL + "    }/* End of \"if (SlotNumber == MAX_OPEN_FILES)\"*/" + NL + "    " + NL + "    /* Check the file path name should not exceed the maximum value*/" + NL + "    PathLen = strlen(Path);" + NL + "    if (PathLen > FILENAME_MAX )" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_";
  protected final String TEXT_71 = "_API_1_2>>> */" + NL + "/* Check and Set Flags Accordingly */" + NL + "    Status = ";
  protected final String TEXT_72 = "_lSetFlagsAccessModes(&Flags,&FatFsFlags);" + NL + "    if( Status != DAVEApp_SUCCESS)" + NL + "    {" + NL + "      FileDesc = -1;" + NL + "      break;" + NL + "    } /* End of \"if ( Status != DAVEApp_SUCCESS))\"*/" + NL + "    /* Allocate memory to store the file path name.*/" + NL + "    FileHandle[SlotNumber].FilePath = (char *)malloc(PathLen+1);" + NL + "    if( FileHandle[SlotNumber].FilePath  == NULL )" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Store the file path name */" + NL + "    strcpy(FileHandle[SlotNumber].FilePath ,Path);" + NL + "/* Set File Handle to -1 and error no variable to default EIO */" + NL + "    FileDesc = -1;" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "    errno = EIO;" + NL + "#elif defined __CC_ARM" + NL + "    errno =  EINVAL;" + NL + "#elif  __ICCARM__" + NL + "    errno = _LLIO_ERROR;" + NL + "#endif" + NL + "/* <<<DD_";
  protected final String TEXT_73 = "_API_1_3>>> */" + NL + "    /* If File Pointer is NULL, then allocate the memory to open a file  */" + NL + "    if (FileHandle[SlotNumber].FatFsPtr == NULL)" + NL + "    {" + NL + "      FileHandle[SlotNumber].FatFsPtr = (FIL *)calloc(1, sizeof(FIL));" + NL + "/* <<<DD_";
  protected final String TEXT_74 = "_API_1_4>>> */" + NL + "      if (FileHandle[SlotNumber].FatFsPtr == NULL)" + NL + "      {" + NL + "        Status = FILE_WRAPPER_ERROR;" + NL + "        break;" + NL + "      } /* End of \"if (FileHandle[SlotNumber].FatFsPtr == NULL))\"*/" + NL + "    } /* End of \"if (FileHandle[SlotNumber].FatFsPtr == NULL)\"*/" + NL + "/* Call the f_open function */" + NL + "   Result = f_open(FileHandle[SlotNumber].FatFsPtr,Path,FatFsFlags);" + NL + "/* <<<DD_";
  protected final String TEXT_75 = "_API_1_5>>> */" + NL + "   if( Result != FR_OK)" + NL + "   {" + NL + "     errno = ErrorCodes[ Result];" + NL + "     break;" + NL + "   } /* End of \"if( Result != FR_OK)\"*/" + NL + "   FileDesc = SlotNumber + MONITOR_FATFS;" + NL + "   FileHandle[SlotNumber].Fd = FileDesc;" + NL + "   FileHandle[SlotNumber].Flags = Flags;" + NL + "   FileHandle[SlotNumber].CurrentPos = 0;" + NL + "/* <<<DD_";
  protected final String TEXT_76 = "_API_1_6>>> */" + NL + "/* if Append flag set, Get the end position by using FatFS lseek function */" + NL + "   if (Flags & ";
  protected final String TEXT_77 = "_APPEND)" + NL + "   {" + NL + "#if _FS_MINIMIZE == 3" + NL + "     Result = FR_DENIED;" + NL + "#else" + NL + "     Result = f_lseek( FileHandle[SlotNumber].FatFsPtr, \\" + NL + "                       FileHandle[SlotNumber].FatFsPtr->fsize );" + NL + "#endif" + NL + "/* <<<DD_";
  protected final String TEXT_78 = "_API_1_7>>> */" + NL + "     if (Result != FR_OK)" + NL + "     {" + NL + "       FileDesc = -1;" + NL + "       break;" + NL + "     }/* End of \"if( Result != FR_OK)\"*/" + NL + "     FileHandle[SlotNumber].CurrentPos = FileHandle[SlotNumber].FatFsPtr->fptr;" + NL + "   } /* End of \"if(Flags & ";
  protected final String TEXT_79 = "_APPEND)\"*/" + NL + " } while(0);" + NL + "  Status = FileDesc;" + NL + "/* <<<DD_";
  protected final String TEXT_80 = "_API_1_8>>> */" + NL + "/* Free the memory if File Handle is -1 and Valid FatFsPtr exists */" + NL + " if ((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )" + NL + " {" + NL + "   free (FileHandle[SlotNumber].FilePath);" + NL + "   free (FileHandle [SlotNumber].FatFsPtr);" + NL + "   FileHandle[SlotNumber].FilePath = NULL;" + NL + "   FileHandle [SlotNumber].FatFsPtr = NULL;" + NL + " } /* End of \"if((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )\"*/" + NL + " return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_81 = "_API_2>>> */" + NL + "/*" + NL + " * This function closes the file specified by the File descriptor." + NL + " */" + NL + "#if defined __GNUC__" + NL + "int _close(int Fd)" + NL + "#elif defined __CC_ARM" + NL + "int _sys_close(FILEHANDLE Fd)" + NL + "#elif defined  __TASKING__" + NL + "_err_t  _close(_fd_t Fd)" + NL + "#elif defined  __ICCARM__" + NL + "int __close(int Fd)" + NL + "#endif" + NL + "{" + NL + "#ifdef  __TASKING__" + NL + "  _err_t Status = FILE_WRAPPER_ERROR;" + NL + "#else" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#endif" + NL + "  int SlotNumber;" + NL + "  FRESULT Result;" + NL + "  do" + NL + "  {" + NL + "    /* Find the Slot number */" + NL + "    SlotNumber = ";
  protected final String TEXT_82 = "_lFindAvailableSlot(Fd);" + NL + "/* <<<DD_";
  protected final String TEXT_83 = "_API_2_1>>> */" + NL + "    if (SlotNumber == MAX_OPEN_FILES)" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = EBADF;" + NL + "#elif defined __CC_ARM" + NL + "      errno = EINVAL;" + NL + "#elif defined  __ICCARM__" + NL + "      errno = _LLIO_ERROR;" + NL + "#endif" + NL + "      break;" + NL + "    }" + NL + " /* Set the handle in the file info structure to -1 */" + NL + "    FileHandle [SlotNumber].Fd = -1;" + NL + "/* Check FilePtr is not Null */" + NL + "/* <<<DD_";
  protected final String TEXT_84 = "_API_2_2>>> */" + NL + "    if (FileHandle [SlotNumber].FatFsPtr != NULL )" + NL + "    {" + NL + "      Result = f_close (FileHandle[SlotNumber].FatFsPtr);" + NL + "      if (Result != FR_OK)" + NL + "      {" + NL + "        errno = ErrorCodes[ Result];" + NL + "        break;" + NL + "      }" + NL + "      free (FileHandle[SlotNumber].FilePath);" + NL + "      free (FileHandle[SlotNumber].FatFsPtr);" + NL + "      FileHandle [SlotNumber].FatFsPtr = NULL;" + NL + "/* <<<DD_";
  protected final String TEXT_85 = "_API_2_3>>> */" + NL + "      Status = DAVEApp_SUCCESS;" + NL + "    }" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_86 = "_API_3>>> */" + NL + "/*" + NL + " * This function reads Length bytes of data from the file specified" + NL + " */ " + NL + "#if defined __GNUC__" + NL + "" + NL + "//_ssize_t _read_r( struct _reent *r, int file, void *ptr, size_t len )" + NL + "_ssize_t _read_r" + NL + "(" + NL + "  struct _reent *r," + NL + "  int Fd," + NL + "  void *BufferPtr," + NL + "  size_t Length" + NL + ")" + NL + "#elif defined __CC_ARM" + NL + "int _sys_read" + NL + "(" + NL + "  FILEHANDLE Fd," + NL + "  U8 *BufferPtr," + NL + "  U32 Length," + NL + "  int mode" + NL + ")" + NL + "#elif defined  __TASKING__" + NL + "int _read" + NL + "(" + NL + "  _fd_t Fd," + NL + "  void *BufferPtr," + NL + "  size_t Length" + NL + ")" + NL + "#elif defined __ICCARM__" + NL + "size_t __read" + NL + "(" + NL + "  int Fd," + NL + "  unsigned char *BufferPtr," + NL + "  size_t Length" + NL + ")" + NL + "#endif" + NL + "{" + NL + "  int SlotNumber;" + NL + "  int BytesRead = 0;" + NL + "  int BytesUnRead = -1;" + NL + "  FRESULT Result;" + NL + "  do" + NL + "  {" + NL + "#if ";
  protected final String TEXT_87 = "_ELUA_IN_USE" + NL + "\t   if(Fd == STDIN_HANDLE)" + NL + "\t   {" + NL + "\t\t   return std_read( r,DM_GET_FD(Fd), BufferPtr, Length );" + NL + "\t   }" + NL + "#endif" + NL + "/* Re-map the adjusted File Handle  */" + NL + "/* Find the Slot number occupied by the file to read from.*/" + NL + "    SlotNumber = ";
  protected final String TEXT_88 = "_lFindAvailableSlot(Fd);" + NL + "/* <<<DD_";
  protected final String TEXT_89 = "_API_3_1>>> */" + NL + "/* Check If write only flag is set  or Max Files are opened.*/" + NL + "    if ( (SlotNumber == MAX_OPEN_FILES) || " + NL + "\t\t     ((FileHandle[SlotNumber].Flags & ";
  protected final String TEXT_90 = "_WRONLY) != 0UL ))" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = EBADF;" + NL + "#elif defined __CC_ARM" + NL + "      errno = EINVAL;" + NL + "#elif defined __ICCARM__" + NL + "      errno = _LLIO_ERROR;" + NL + "#endif" + NL + "      BytesRead = -1;" + NL + "      break;" + NL + "    }" + NL + "/* Switch as per the file descriptor.*/" + NL + "   switch(Fd)" + NL + "   {" + NL + "     case STDIN_HANDLE:" + NL + "          break;" + NL + "" + NL + "     case STDOUT_HANDLE:" + NL + "           break;" + NL + "" + NL + "     case STDERR_HANDLE:" + NL + "           break;" + NL + "" + NL + "     default:" + NL + "/* <<<DD_";
  protected final String TEXT_91 = "_API_3_2>>> */" + NL + "       if (FileHandle[SlotNumber].FatFsPtr != NULL)" + NL + "       {" + NL + "/* Call the Fat FS f_read function */" + NL + "         Result = f_read(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length," + NL + "                          (UINT *)&BytesRead);" + NL + "/* <<<DD_";
  protected final String TEXT_92 = "_API_3_3>>> */" + NL + "         if (Result != FR_OK)" + NL + "         {" + NL + "           errno = ErrorCodes[ Result];" + NL + "           BytesRead = -1;" + NL + "           break;" + NL + "         }" + NL + "         BytesUnRead = Length - BytesRead;" + NL + "       }" + NL + "       break;" + NL + "    }" + NL + "/* <<<DD_";
  protected final String TEXT_93 = "_API_3_4>>> */" + NL + "    if (BytesUnRead < 0)" + NL + "    {" + NL + "      BytesRead = -1;" + NL + "      break;" + NL + "    }" + NL + "    FileHandle[SlotNumber].CurrentPos += (Length - BytesUnRead);" + NL + "  } while(0);" + NL + "  return BytesRead;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_94 = "_API_4>>> */" + NL + "/*" + NL + " * This function writes Length bytes of data into the file specified." + NL + " */" + NL + "#if defined __GNUC__" + NL + "" + NL + "" + NL + "_ssize_t _write_r" + NL + "(" + NL + " struct _reent *r," + NL + "  int Fd," + NL + "  const void *BufferPtr," + NL + "  size_t Length" + NL + ")" + NL + "#elif defined __CC_ARM" + NL + "int _sys_write" + NL + "(" + NL + "  FILEHANDLE Fd," + NL + "  const U8 *BufferPtr," + NL + "  U32 Length," + NL + "  int Mode" + NL + ")" + NL + "#elif defined  __TASKING__" + NL + "int _write" + NL + "(" + NL + "  _fd_t Fd," + NL + "  const void *BufferPtr," + NL + "  size_t Length" + NL + ")" + NL + "#elif defined  __ICCARM__" + NL + "size_t __write" + NL + "(" + NL + "  int Fd," + NL + "  const unsigned char * BufferPtr," + NL + "  size_t Length" + NL + ")" + NL + "#endif" + NL + "{" + NL + "  int SlotNumber;" + NL + "  int BytesWritten = 0;" + NL + "  int BytesUnWritten = -1;" + NL + "#if !_FS_READONLY" + NL + "  FRESULT Result;" + NL + "#endif" + NL + "  do" + NL + "  {" + NL + "#if ";
  protected final String TEXT_95 = "_ELUA_IN_USE" + NL + "\t  if(Fd == STDOUT_HANDLE)" + NL + "\t  {" + NL + "\t\t  return std_write( r,DM_GET_FD(Fd), BufferPtr, Length );" + NL + "\t  }" + NL + "#endif" + NL + "/* Find the Slot number occupied by the file to read from.*/" + NL + "    SlotNumber = ";
  protected final String TEXT_96 = "_lFindAvailableSlot(Fd);" + NL + "/* <<<DD_";
  protected final String TEXT_97 = "_API_4_1>>> */" + NL + "/* Check If read only flag is set or Max Files are opened. */" + NL + "    if ( (SlotNumber == MAX_OPEN_FILES) || " + NL + "\t\t   ((FileHandle[SlotNumber].Flags & ";
  protected final String TEXT_98 = "_RDONLY ) == 1UL ))" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = EBADF;" + NL + "#elif defined  __CC_ARM" + NL + "      errno = EINVAL;" + NL + "#elif defined  __ICCARM__" + NL + "      errno = _LLIO_ERROR;" + NL + "#endif" + NL + "      break;" + NL + "    }" + NL + "/* Switch as per the file descriptor.*/" + NL + "    switch(Fd)" + NL + "    {" + NL + "      case STDIN_HANDLE:" + NL + "           break;" + NL + "" + NL + "      case STDOUT_HANDLE:" + NL + "           break;" + NL + "" + NL + "      case STDERR_HANDLE:" + NL + "           break;" + NL + "" + NL + "      default:" + NL + "#if _FS_READONLY   " + NL + "    break;" + NL + "#else " + NL + "/* <<<DD_";
  protected final String TEXT_99 = "_API_4_2>>> */" + NL + "        if (FileHandle[SlotNumber].FatFsPtr != NULL)" + NL + "        {" + NL + "          /* Call the Fat FS f_write function */" + NL + "          Result = f_write(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length," + NL + "                        (UINT *)&BytesWritten);" + NL + "/* <<<DD_";
  protected final String TEXT_100 = "_API_4_3>>> */" + NL + "          if (Result != FR_OK)" + NL + "          {" + NL + "            errno = ErrorCodes[Result];" + NL + "            break;" + NL + "          }" + NL + "          BytesUnWritten = Length - BytesWritten;" + NL + "        }" + NL + "        break;" + NL + "#endif" + NL + "    }" + NL + "  } while(0);" + NL + "/* <<<DD_";
  protected final String TEXT_101 = "_API_4_4>>> */" + NL + "  if((BytesUnWritten  == -1) || (BytesUnWritten == Length))" + NL + "  {" + NL + "    BytesWritten = -1;" + NL + "  }" + NL + "/* <<<DD_";
  protected final String TEXT_102 = "_API_4_5>>> */" + NL + "  else" + NL + "  {" + NL + "    FileHandle[SlotNumber].CurrentPos += (Length - BytesUnWritten);" + NL + "  }" + NL + "  return BytesWritten;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_103 = "_API_5>>> */" + NL + "/*" + NL + " * This function Move file pointer of a file object specified by the" + NL + " * File Descriptor." + NL + " */" + NL + "#ifdef __GNUC__" + NL + "int _lseek" + NL + "(" + NL + "  int Fd," + NL + "  long Offset," + NL + "  int DirMode" + NL + ")" + NL + "#elif __CC_ARM" + NL + "int _sys_seek" + NL + "(" + NL + "  FILEHANDLE Fd," + NL + "  long Offset" + NL + ")" + NL + "#elif  __TASKING__" + NL + "long _lseek" + NL + "(" + NL + "  _fd_t Fd," + NL + "  long Offset," + NL + "  _whence_t DirMode" + NL + ")" + NL + "#elif  __ICCARM__" + NL + "long __lseek" + NL + "(" + NL + "  int Fd," + NL + "  long Offset," + NL + "  int DirMode" + NL + ")" + NL + "#endif" + NL + "{" + NL + "  int FileOffset = -1;" + NL + "#if _FS_MINIMIZE != 3 " + NL + "  int SlotNumber;" + NL + "  FRESULT Result;" + NL + "#endif" + NL + "  do" + NL + "  {" + NL + "#if _FS_MINIMIZE == 3" + NL + "    break;" + NL + "#else" + NL + "    /* Find the Slot number occupied by the file to read from.*/" + NL + "    SlotNumber = ";
  protected final String TEXT_104 = "_lFindAvailableSlot(Fd);" + NL + "/* <<<DD_";
  protected final String TEXT_105 = "_API_5_1>>> */" + NL + "    if ( (SlotNumber == MAX_OPEN_FILES) ||" + NL + "         (FileHandle[SlotNumber].FatFsPtr == NULL))" + NL + "    {" + NL + "#if defined(__GNUC__) || defined( __TASKING__)" + NL + "      errno = EBADF;" + NL + "#elif defined __CC_ARM" + NL + "      errno = EINVAL;" + NL + "#elif defined  __ICCARM__" + NL + "      errno = _LLIO_ERROR;" + NL + "#endif" + NL + "      break;" + NL + "    }" + NL + "#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )" + NL + "    /* Check Direction Mode */" + NL + "/* <<<DD_";
  protected final String TEXT_106 = "_API_5_2>>> */" + NL + "    if (DirMode == SEEK_SET)" + NL + "    {" + NL + "      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, Offset);" + NL + "    }" + NL + "/* <<<DD_";
  protected final String TEXT_107 = "_API_5_3>>> */" + NL + "    else if (DirMode == SEEK_CUR)" + NL + "    {" + NL + "      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \\" + NL + "                     FileHandle [SlotNumber].FatFsPtr->fptr + Offset);" + NL + "    }" + NL + "/* <<<DD_";
  protected final String TEXT_108 = "_API_5_4>>> */" + NL + "    else if (DirMode == SEEK_END)" + NL + "    {" + NL + "      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \\" + NL + "                        FileHandle [SlotNumber].FatFsPtr->fsize + Offset);" + NL + "    }" + NL + "    else" + NL + "      break;" + NL + "#elif __CC_ARM" + NL + "/* <<<DD_";
  protected final String TEXT_109 = "_API_5_5>>> */" + NL + "    Result= f_lseek (FileHandle[SlotNumber].FatFsPtr,Offset);" + NL + "#endif" + NL + "    /* If Fat FS Function call returns Error*/" + NL + "/* <<<DD_";
  protected final String TEXT_110 = "_API_5_6>>> */" + NL + "    if (Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    FileHandle[SlotNumber].CurrentPos = FileHandle [SlotNumber].FatFsPtr->fptr;" + NL + "    FileOffset = FileHandle[SlotNumber].CurrentPos;" + NL + "#endif" + NL + "  } while(0);" + NL + "  return FileOffset;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_111 = "_API_6>>> */" + NL + "/* " + NL + " * This function Delete an existing file or directory." + NL + " */" + NL + "#ifdef __GNUC__" + NL + "int _unlink (const char  *Path)" + NL + "#elif __CC_ARM" + NL + "int remove(const char *Path)" + NL + "#elif  __TASKING__" + NL + "int remove (const char *Path)" + NL + "#elif __ICCARM__" + NL + "int remove(const char * Path)" + NL + "#endif" + NL + "{" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#if ((!_FS_READONLY ) && ( _FS_MINIMIZE == 0) ) " + NL + "  FRESULT Result;" + NL + "#endif" + NL + "  do" + NL + "  {" + NL + "#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))   " + NL + "    break;" + NL + "#else  " + NL + "    /* Call the Fat FS unlink function */" + NL + "    Result = f_unlink (Path);" + NL + "/* <<<DD_";
  protected final String TEXT_112 = "_API_6_1>>> */" + NL + "    if( Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "#endif" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_113 = "_API_7>>> */" + NL + "/*" + NL + " * This function gets file status on basis of file descriptor passed." + NL + " */" + NL + "" + NL + "#if defined  (__GNUC__) || defined (  __TASKING__)" + NL + "#if defined (__GNUC__)" + NL + "int _fstat(int Fd, struct stat *FileStatusPtr)" + NL + "#elif  defined (  __TASKING__)" + NL + "int fstat(int Fd, struct stat *FileStatusPtr)" + NL + "#endif" + NL + "{" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#if _FS_MINIMIZE == 0   " + NL + "  FILINFO FatFsInfoStruct = {0};" + NL + "  FRESULT Result;" + NL + "  int SlotNumber;" + NL + " " + NL + "  do" + NL + "  {" + NL + "" + NL + "  if( ( Fd >= STDIN_HANDLE ) && ( Fd <= STDERR_HANDLE ) )" + NL + "\t{" + NL + "\t  FileStatusPtr->st_mode = S_IFCHR;" + NL + "\t  return 0;" + NL + "\t}" + NL + "    /* Find the Slot number occupied by the file to read the status*/" + NL + "    SlotNumber = ";
  protected final String TEXT_114 = "_lFindAvailableSlot(Fd);" + NL + "    /* Call the Fat FS Status function */" + NL + "    Result = f_stat(FileHandle[SlotNumber].FilePath, &FatFsInfoStruct);" + NL + "/* <<<DD_";
  protected final String TEXT_115 = "_API_7_1>>> */" + NL + "    if (Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }";
  protected final String TEXT_116 = NL + "    ";
  protected final String TEXT_117 = "_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  } while(0);" + NL + "#endif" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_118 = "_API_8>>> */" + NL + "/*" + NL + " * This function gets file status on basis of file path " + NL + " */" + NL + "#if defined (__GNUC__)" + NL + "int _stat(const char *Path,  struct stat *FileStatusPtr)" + NL + "#elif  defined (  __TASKING__)" + NL + "int stat(const char *Path,  struct stat *FileStatusPtr)" + NL + "#endif" + NL + "{" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#if _FS_MINIMIZE == 0 " + NL + "  FILINFO FatFsInfoStruct = {0};" + NL + "  FRESULT Result;" + NL + "  do" + NL + "  {" + NL + "    /* Call the Fat FS Status function */" + NL + "    Result = f_stat (Path, &FatFsInfoStruct);" + NL + "/* <<<DD_";
  protected final String TEXT_119 = "_API_8_1>>> */" + NL + "    if( Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }";
  protected final String TEXT_120 = NL + "    ";
  protected final String TEXT_121 = "_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  } while(0);" + NL + "#endif" + NL + "  return Status;" + NL + "}" + NL + "#endif" + NL + "" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_122 = "_API_9>>> */" + NL + "/*" + NL + " * This function rename/move a file or directory." + NL + " */" + NL + "#if defined (__GNUC__) || defined ( __TASKING__)" + NL + "int rename( const char *OldPath,  const char *NewPath)" + NL + "#elif __CC_ARM" + NL + "int rename(const char *OldPath, const char *NewPath)" + NL + "#elif  __ICCARM__" + NL + "int rename(const char *OldPath, const char *NewPath)" + NL + "#endif" + NL + "{" + NL + "#if ((!_FS_READONLY) && ( _FS_MINIMIZE == 0))" + NL + "  FRESULT Result;" + NL + "#endif" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "  do" + NL + "  {" + NL + "#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))" + NL + "    break;" + NL + "#else   " + NL + "    /* Call the Fat FS Status function */" + NL + "    Result = f_rename(OldPath, NewPath);" + NL + "/* <<<DD_";
  protected final String TEXT_123 = "_API_9_1>>> */" + NL + "    if( Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "#endif" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_124 = "_API_10>>> */" + NL + "/*" + NL + " * This function change attributes of the file/dir " + NL + " */" + NL + "#if defined __GNUC__" + NL + "int _chmod (const char *Path, mode_t Mode)" + NL + "#elif defined __CC_ARM || defined  __TASKING__ || defined  __ICCARM__" + NL + "int chmod (const char *Path, mode_t Mode)" + NL + "#endif" + NL + "{" + NL + "#if ((!_FS_READONLY) && ( _FS_MINIMIZE == 0))" + NL + "  FRESULT Result;" + NL + "#endif" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "  do" + NL + "  {" + NL + "#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))" + NL + "    break;" + NL + "#else  " + NL + "    /* Call the Fat FS Status function */" + NL + "    Result = f_chmod(Path, Mode, AM_RDO);" + NL + "/* <<<DD_";
  protected final String TEXT_125 = "_API_10_1>>> */" + NL + "    if( Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "#endif" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_126 = "_API_11>>> */" + NL + "/*" + NL + " * This function creates a new directory." + NL + " */" + NL + "#if defined __GNUC__" + NL + "int _mkdir (const char *Path, mode_t Mode)" + NL + "#elif defined __CC_ARM || defined  __TASKING__ || defined  __ICCARM__" + NL + "int mkdir (const char *Path, mode_t Mode)" + NL + "#endif" + NL + "{" + NL + "#if ((!_FS_READONLY) && ( _FS_MINIMIZE == 0))  " + NL + "  FRESULT Result;" + NL + "#endif" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "  do" + NL + "  {" + NL + "#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))  " + NL + "    break;" + NL + "#else " + NL + "    /* Call the Fat FS Mkdir function */" + NL + "    Result = f_mkdir(Path);" + NL + "/* <<<DD_";
  protected final String TEXT_127 = "_API_11_1>>> */" + NL + "    if( Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "#endif" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_128 = "_API_12>>> */" + NL + "/*" + NL + " *  This function flush cached data of a writing file." + NL + " */" + NL + "#if defined (__GNUC__) || defined ( __TASKING__)" + NL + "void  _sync (void)" + NL + "#elif defined (__CC_ARM) || defined ( __ICCARM__)" + NL + "void  sync (void)" + NL + "#endif" + NL + "{" + NL + "#if !_FS_READONLY " + NL + "  int SlotNumber;" + NL + "  for( SlotNumber = 0; SlotNumber < MAX_OPEN_FILES; SlotNumber++ )" + NL + "  {" + NL + "/* <<<DD_";
  protected final String TEXT_129 = "_API_12_1>>> */" + NL + "    if (FileHandle[SlotNumber].FatFsPtr)" + NL + "      f_sync (FileHandle[SlotNumber].FatFsPtr);" + NL + "  }" + NL + "#endif" + NL + "}" + NL + "" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_130 = "_API_13>>> */" + NL + "/*" + NL + " * This function creates the file system on the drive." + NL + " */" + NL + "int mkfs( uint8_t DriveNumber, uint8_t PartitioningRule,uint32_t AllocSize)" + NL + "{" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#if _USE_MKFS" + NL + "  FRESULT Result;" + NL + "  do" + NL + "  {" + NL + "    Result = f_mkfs(DriveNumber,PartitioningRule,AllocSize);" + NL + "/* <<<DD_";
  protected final String TEXT_131 = "_API_13_1>>> */" + NL + "    if(Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  }while(0);" + NL + "#endif" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_132 = "_API_14>>> */" + NL + "/*" + NL + " * This function registers/unregisters a work area." + NL + " */" + NL + "int mount( uint8_t DriveNumber, FATFS *FatFSObj)" + NL + "{" + NL + "  FRESULT Result;" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "  do" + NL + "  {" + NL + "    Result = f_mount(DriveNumber,FatFSObj);" + NL + "/* <<<DD_";
  protected final String TEXT_133 = "_API_14_1>>> */" + NL + "    if(Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  }while(0);" + NL + "  return  Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function querries whether output stream is a terminal. " + NL + " */" + NL + " /* <<<DD_";
  protected final String TEXT_134 = "_API_15>>> */" + NL + "" + NL + "#if defined(__GNUC__)  || defined (__CC_ARM)" + NL + "#if defined(__GNUC__)" + NL + "int _isatty(int Fd)" + NL + "#elif defined (__CC_ARM)" + NL + "int _sys_istty(FILEHANDLE Fd)" + NL + "#endif" + NL + "{" + NL + "  return (Fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */" + NL + "}" + NL + "#endif" + NL + "" + NL + "" + NL + "/*" + NL + " *  Function to Initialize all the local variables of Standard Librarry App " + NL + " */" + NL + "/* <<<DD_";
  protected final String TEXT_135 = "_API_16>>> */" + NL + "void ";
  protected final String TEXT_136 = "_Init()" + NL + "{";
  protected final String TEXT_137 = NL + "   ";
  protected final String TEXT_138 = "_lLocalInitialize();" + NL + "}" + NL + "" + NL + "" + NL + "#if defined(__GNUC__)" + NL + "/* This function establish a new name for an existing file. This function is" + NL + " * not supported by Fat File system." + NL + " */" + NL + "/* <<<DD_";
  protected final String TEXT_139 = "_API_17>>> */" + NL + "int _link (char *OldName, char *NewName)" + NL + "{" + NL + "  errno = EMLINK;" + NL + "  return -1;" + NL + "}" + NL + "#endif" + NL + "" + NL + "/* This function creates a partition table into the MBR of the physical drive." + NL + " */" + NL + "/* <<<DD_";
  protected final String TEXT_140 = "_API_18>>> */" + NL + "int fdisk( uint8_t DriveNumber, const uint32_t Partitions[], void * Work)" + NL + "{" + NL + "  int Status = FILE_WRAPPER_ERROR;" + NL + "#if _MULTI_PARTITION" + NL + "  FRESULT Result;" + NL + "  do" + NL + "  {" + NL + "    Result = f_fdisk(DriveNumber,Partitions, Work);" + NL + "/* <<<DD_";
  protected final String TEXT_141 = "_API_18_1>>> */" + NL + "    if(Result != FR_OK)" + NL + "    {" + NL + "      errno = ErrorCodes[Result];" + NL + "      break;" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  } while(0);" + NL + "#endif" + NL + "  return  Status;" + NL + "}" + NL + "" + NL + "/* " + NL + " * IAR internally calls __dwrite for write system call ." + NL + " */" + NL + "#if defined ( __ICCARM__)" + NL + "size_t __dwrite(int Fd,const unsigned char *BufferPtr, size_t Length)" + NL + "{" + NL + "  return  __write(Fd,BufferPtr,Length);" + NL + "}" + NL + "#endif" + NL + "" + NL + "/*" + NL + " * Keil compiler searches for the following system calls while retargetting is " + NL + " * done." + NL + " */" + NL + "#if defined (__CC_ARM)" + NL + "void _ttywrch (int ch) {" + NL + "" + NL + "}" + NL + "" + NL + "int _sys_ensure (FILEHANDLE Fh) {" + NL + "    Fh = Fh;" + NL + "    return (0);" + NL + "}" + NL + "" + NL + "long _sys_flen (FILEHANDLE Fh) {" + NL + "    Fh = Fh;" + NL + "    return (0);" + NL + "}" + NL + "" + NL + "int _sys_tmpnam (char *Name, int Sig, unsigned Maxlen)" + NL + "{" + NL + "  *Name = *Name;" + NL + "  Sig = Sig;" + NL + "  Maxlen = Maxlen;" + NL + "  return (0);" + NL + "}" + NL + "" + NL + "char *_sys_command_string (char *Cmd, int Len)" + NL + "{" + NL + "  *Cmd = *Cmd;" + NL + "  Len = Len;" + NL + "  return (0);" + NL + "}" + NL + "" + NL + "void _sys_exit (int return_code)" + NL + "{" + NL + "  /* Endless loop. */" + NL + "  while (1);" + NL + "}" + NL + "" + NL + "#endif" + NL + "" + NL + "#ifdef ";
  protected final String TEXT_142 = "_ELUA_IN_USE" + NL + "/* System calls used in Elua implementation */" + NL + "pid_t _getpid()" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "void _exit( int Status )" + NL + "{" + NL + "  while( 1 );" + NL + "}" + NL + "" + NL + "int _kill( int Pid, int Sig )" + NL + "{" + NL + "  return -1;" + NL + "}" + NL + "" + NL + "_fini()" + NL + "{" + NL + "" + NL + "}" + NL + "" + NL + "/* This function allows eLua to list all the files in the file systems used by eLua" + NL + " */" + NL + "void* fatfs_opendir_r( struct _reent *r, const char* DirName )" + NL + "{" + NL + "  void *ResPtr = NULL;" + NL + "  if( (!DirName)  || (strlen( DirName ) == 0 ) || \\" + NL + "      (strlen( DirName ) == 1 && !strcmp( DirName, \"/\" ) ) " + NL + "    )" + NL + "  {" + NL + "    ResPtr = f_opendir( &";
  protected final String TEXT_143 = "_MmcDir, \"/\" ) != FR_OK ? NULL : &";
  protected final String TEXT_144 = "_MmcDir;" + NL + "  }" + NL + "  return ResPtr;" + NL + "}" + NL + "/* This function allows eLua to print the content of (usually text) files on the console." + NL + " */" + NL + "struct dm_dirent* fatfs_readdir_r( struct _reent *r, void *d )" + NL + "{" + NL + "  DIR *pdir = (DIR*)d;" + NL + "  FILINFO mmc_file_info;" + NL + "  struct dm_dirent* pent = &dm_shared_dirent;" + NL + "  char *fn;" + NL + "#if _USE_LFN" + NL + "  static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1];" + NL + "  mmc_file_info.lfname = lfn;" + NL + "  mmc_file_info.lfsize = sizeof(lfn);" + NL + "#endif" + NL + "/* loop until we get a file, error, or end of directory */" + NL + "  while( 1 ) " + NL + "  {" + NL + "    /* return NULL on read error if read dir fails */" + NL + "    if( f_readdir( pdir, &mmc_file_info ) != FR_OK ) " + NL + "      return NULL;" + NL + "    /* return NULL when listing is done */  " + NL + "    if( mmc_file_info.fname[ 0 ] == '\\0' ) " + NL + "      return NULL;" + NL + "    /* if we have a file, exit loop */" + NL + "    if( ( mmc_file_info.fattrib & AM_DIR ) == 0 ) " + NL + "      break;" + NL + "  }" + NL + "#if _USE_LFN" + NL + "  fn = *mmc_file_info.lfname ? mmc_file_info.lfname : mmc_file_info.fname;" + NL + "#else" + NL + "  fn = mmc_file_info.fname;" + NL + "#endif" + NL + "  strncpy( dm_shared_fname, fn, DM_MAX_FNAME_LENGTH );" + NL + "  pent->fname = dm_shared_fname;" + NL + "  pent->fsize = mmc_file_info.fsize;" + NL + "  pent->ftime = mmc_file_info.ftime;" + NL + "  return pent;" + NL + "}" + NL + "" + NL + "/* This function closes the files in the filesystem used by elua. */" + NL + "int fatfs_closedir_r( struct _reent *r, void *d )" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "#endif" + NL + "" + NL + "" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL + NL;
  protected final String TEXT_145 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/sltha001/"; 
     int appInst = 0; 
     int RTOS = app.getIntegerValue(AppBaseuri + appInst + "/sltha001_rtos_present");
   String  Module_Name = "SLTHA001";

    stringBuffer.append(TEXT_2);
     
  if (RTOS == 1)
  {
    Module_Name = "SLTHA002";
  }
  else
  {
    Module_Name = "SLTHA001";
  }

    stringBuffer.append(TEXT_3);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_4);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_5);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_6);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_7);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_8);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_9);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_10);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_11);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_12);
    stringBuffer.append(TEXT_13);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_14);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_15);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_16);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_17);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_18);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_19);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_20);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_21);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_22);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_23);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_24);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_25);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_26);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_27);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_28);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_29);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_30);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_31);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_32);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_33);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_34);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_35);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_36);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_37);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_38);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_39);
    stringBuffer.append(TEXT_40);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_41);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_42);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_43);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_44);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_45);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_46);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_47);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_48);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_49);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_50);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_51);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_52);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_53);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_54);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_55);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_56);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_57);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_58);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_59);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_60);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_61);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_62);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_63);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_64);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_65);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_66);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_67);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_68);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_69);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_70);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_71);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_72);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_73);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_74);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_75);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_76);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_77);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_78);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_79);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_80);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_81);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_82);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_83);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_84);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_85);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_86);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_87);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_88);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_89);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_90);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_91);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_92);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_93);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_94);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_95);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_96);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_97);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_98);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_99);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_100);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_101);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_102);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_103);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_104);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_105);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_106);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_107);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_108);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_109);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_110);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_111);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_112);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_113);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_114);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_115);
    stringBuffer.append(TEXT_116);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_117);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_118);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_119);
    stringBuffer.append(TEXT_120);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_121);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_122);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_123);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_124);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_125);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_126);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_127);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_128);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_129);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_130);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_131);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_132);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_133);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_134);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_135);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_136);
    stringBuffer.append(TEXT_137);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_138);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_139);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_140);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_141);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_142);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_143);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_144);
    stringBuffer.append(TEXT_145);
    return stringBuffer.toString();
  }
}
