package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class adc002c_template
{
  protected static String nl;
  public static synchronized adc002c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    adc002c_template result = new adc002c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[ADC002.c]*/" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without**" + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4500 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : KM                                                              **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : July 31, 2012                                          **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/**" + NL + " * @file ADC002.c" + NL + " *" + NL + " * @brief This file contains ADC002 App API definitions" + NL + " *" + NL + " */" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "" + NL + "/******************************************************************************" + NL + "**                      Author(s) Identity                                   **" + NL + "*******************************************************************************" + NL + "**                                                                           **" + NL + "** Initials     Name                                                         **" + NL + "** KM           DAVE App Developer                                           **" + NL + "** --------------------------------------------------------------------------**" + NL + "" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief This function initializes the app." + NL + " *" + NL + " * @param [in] HandlePtr pointer to the Instance variable<BR>" + NL + " *" + NL + " * @return  NOne <BR>" + NL + " *" + NL + " * <b>Reentrancy:  Yes</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b><BR>" + NL + " */" + NL + "/*This is local init function*/" + NL + "static void ADC002_lInit(const ADC002_HandleType *HandlePtr );" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + NL;
  protected final String TEXT_2 = NL + NL + NL + "/** This function initializes the app */" + NL + "void ADC002_Init(void)" + NL + "{" + NL + "   /*Initialization of app 'ADCGLOB001'*/         " + NL + "  ADCGLOB001_Init();";
  protected final String TEXT_3 = "  " + NL + "  ADC002_lInit(&ADC002_Handle";
  protected final String TEXT_4 = ");    ";
  protected final String TEXT_5 = NL + "}" + NL + "/* " + NL + " * This function initializes the queue App. Local function is used to " + NL + " * initialize all the instances of the app." + NL + " */" + NL + "static void ADC002_lInit(const ADC002_HandleType *HandlePtr )" + NL + "{" + NL + "  /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "  " + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_UNINITIALIZED)" + NL + "  {" + NL + "    /* Flush the Queue */" + NL + "    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_FLUSH_Pos);" + NL + "    " + NL + "    /* Sets the priority of the queue request source */" + NL + "    WR_REG( VADCGroupPtr->ARBPR, VADC_G_ARBPR_PRIO0_Msk, " + NL + "            VADC_G_ARBPR_PRIO0_Pos,(uint32_t)HandlePtr->kPriority);                                                        " + NL + "    /*" + NL + "     * Enable XTWC Bitfield so that XTMODE and XTSEL can be written " + NL + "     * Selects trigger mode ." + NL + "     */" + NL + "    VADCGroupPtr->QCTRL0 |= (uint32_t)" + NL + "        ((((uint32_t)1 << VADC_G_QCTRL0_XTWC_Pos) & VADC_G_QCTRL0_XTWC_Msk)|\\" + NL + "        (((uint32_t)HandlePtr->kTriggerMode << VADC_G_QCTRL0_XTMODE_Pos) &\\" + NL + "         VADC_G_QCTRL0_XTMODE_Msk));" + NL + "    /*" + NL + "     *Selects the gating mode and enables trigger mode" + NL + "     */" + NL + "    VADCGroupPtr->QMR0 |=(uint32_t)" + NL + "        ((((uint32_t)HandlePtr->kTriggerEn << VADC_G_QMR0_ENTR_Pos)& VADC_G_QMR0_ENTR_Msk)|\\" + NL + "        (((uint32_t)HandlePtr->kGatingMode << VADC_G_QMR0_ENGT_Pos)& VADC_G_QMR0_ENGT_Msk));" + NL + "    /*" + NL + "     * Enable Arbitration slot." + NL + "     * Select conversion start mode for request source. " + NL + "     */" + NL + "    VADCGroupPtr->ARBPR |= (uint32_t)" + NL + "        ((((uint32_t)HandlePtr->kAsenEnable << VADC_G_ARBPR_ASEN0_Pos)&VADC_G_ARBPR_ASEN0_Msk)|\\" + NL + "        (((uint32_t)HandlePtr->kStartmode << VADC_G_ARBPR_CSM0_Pos) & VADC_G_ARBPR_CSM0_Msk));" + NL + "    /*" + NL + "     * Enable cancel mode." + NL + "     * Sets the bit rptdis of QMR0 Register " + NL + "     */" + NL + "    if(HandlePtr->kStartmode == (uint8_t)ADC002_CANCEL_INJECT_REPEAT_WITH_CANCEL)" + NL + "    {" + NL + "      SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_RPTDIS_Pos);" + NL + "    }" + NL + "    /* Set the App State to Initialized */" + NL + "    HandlePtr->DynamicHandlePtr->State = ADC002_INITIALIZED;                            " + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)ADC002_OPER_NOT_ALLOWED_ERROR, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "}" + NL + "/*This function initializes queue entries*/" + NL + "status_t ADC002_InitializeQueue(const ADC002_HandleType *HandlePtr )" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "  uint8_t QueueEntryNum;" + NL + "  uint32_t QINR0Val;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "  " + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  { " + NL + "   /* Inserts the selected entries to the Queue. */" + NL + "    for(QueueEntryNum = (uint8_t)0; QueueEntryNum <= (uint8_t)7; QueueEntryNum++)" + NL + "    {" + NL + "      /* Register the queue entry */" + NL + "      if((&HandlePtr->kQueueEntryHandlePtr[QueueEntryNum] != NULL) &&" + NL + "        (HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Active == (uint8_t)1))" + NL + "      {" + NL + "        QINR0Val = (uint32_t) " + NL + "             ((((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ChannelNumber\\" + NL + "                   << VADC_G_QINR0_REQCHNR_Pos) &VADC_G_QINR0_REQCHNR_Msk ) |\\" + NL + "             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Refill\\" + NL + "                   << VADC_G_QINR0_RF_Pos) &VADC_G_QINR0_RF_Msk)|\\" + NL + "             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Interrupt\\" + NL + "                   << VADC_G_QINR0_ENSI_Pos) &VADC_G_QINR0_ENSI_Msk )     |\\" + NL + "             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ExternalTrigger\\" + NL + "                   << VADC_G_QINR0_EXTR_Pos) & VADC_G_QINR0_EXTR_Msk))  ;" + NL + "        VADCGroupPtr->QINR0 = QINR0Val;" + NL + "      }" + NL + "    }" + NL + "    " + NL + "    /* Generate a trigger event by software */" + NL + "    WR_REG(VADCGroupPtr->QMR0, VADC_G_QMR0_TREV_Msk, VADC_G_QMR0_TREV_Pos," + NL + "                                                 (uint32_t)HandlePtr->kStart);" + NL + "  " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function resets the ADC002 app */" + NL + "status_t ADC002_Deinit(const ADC002_HandleType *HandlePtr )" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "  " + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  { " + NL + "    /* Reset the queue input Register */" + NL + "     VADCGroupPtr->QINR0 = (uint32_t)0x00000000; " + NL + "      " + NL + "    /* Reset ARBPR Register */" + NL + "     VADCGroupPtr->ARBPR &= (uint32_t)0x06000BB4;" + NL + "  " + NL + "    /* Reset QCTRL0 Register*/" + NL + "    /* set write control bit and clear other bits*/" + NL + "     VADCGroupPtr->QCTRL0 = (uint32_t)0x80008000;" + NL + "     " + NL + "    /* Flush the Queue */" + NL + "     SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_FLUSH_Pos);" + NL + "    " + NL + "    /* Reset QMR0 Register */" + NL + "    VADCGroupPtr->QMR0 = (uint32_t)0x00000000;" + NL + "    " + NL + "    /* Reset the source event flag */" + NL + "    VADCGroupPtr->SEFCLR = (uint32_t)0x1;" + NL + "    " + NL + "    /* Set the App State to Uninitialized */" + NL + "    HandlePtr->DynamicHandlePtr->State = ADC002_UNINITIALIZED;" + NL + "  " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function clears the Event flag. */" + NL + "status_t ADC002_ClearEvent(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Clear event flag */" + NL + "    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_CEV_Pos);" + NL + "  " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function clears the queue entries. */" + NL + "status_t ADC002_FlushQueue(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Clear the queue entries */" + NL + "    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_FLUSH_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;    " + NL + "  }" + NL + "  else    " + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function generates a trigger event.*/" + NL + "status_t ADC002_TriggerEvent(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Generate a trigger event */" + NL + "    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_TREV_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else    " + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function clears the next pending valid queue entry in the" + NL + " * sequence and the event flag EV." + NL + " */" + NL + "status_t ADC002_ClearValidBit(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Generate a trigger event */" + NL + "    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_CLRV_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else    " + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function enables the gating." + NL + " */" + NL + "status_t ADC002_EnableGate(const ADC002_HandleType *HandlePtr, " + NL + "                                              uint8_t GateSelectVal)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(GateSelectVal <= (uint8_t)3)" + NL + "    {" + NL + "      /* Selects the gating functionality */" + NL + "     WR_REG(VADCGroupPtr->QMR0, VADC_G_QMR0_ENGT_Msk, VADC_G_QMR0_ENGT_Pos,\\" + NL + "                                                     (uint32_t)GateSelectVal);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else    " + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function enables queue arbitration slot." + NL + " */" + NL + "status_t ADC002_EnableQueueArbitrationSlot(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Enables Queue Arbitration Slot */" + NL + "    SET_BIT(VADCGroupPtr->ARBPR,VADC_G_ARBPR_ASEN0_Pos);    " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function disables queue arbitration slot." + NL + " */" + NL + "status_t ADC002_DisableQueueArbitrationSlot(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Disables Queue Arbitration Slot */" + NL + "    CLR_BIT(VADCGroupPtr->ARBPR,VADC_G_ARBPR_ASEN0_Pos);    " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "/*" + NL + " * This function selects the External trigger mode." + NL + " */" + NL + "status_t ADC002_SetExternalTriggerMode(const ADC002_HandleType *HandlePtr," + NL + "                                                                   uint8_t Mode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if(HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(Mode <= (uint8_t)ADC002_TRIGGER_UPON_BOTH_EDGE)" + NL + "    {" + NL + "      if(Mode == (uint8_t)ADC002_NOTRIGGER)" + NL + "      {" + NL + "        /* Disables external trigger */" + NL + "        CLR_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        /* Enables external trigger */" + NL + "        SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);      " + NL + "      }   " + NL + "  /*" + NL + "   * Enable XTWC Bitfield so that XTMODE and XTSEL can be written" + NL + "   * Selects trigger mode ." + NL + "   */" + NL + "      VADCGroupPtr->QCTRL0 = (uint32_t)" + NL + "        ((((uint32_t)1 << VADC_G_QCTRL0_XTWC_Pos) & VADC_G_QCTRL0_XTWC_Msk)|\\" + NL + "        (((uint32_t)Mode<< VADC_G_QCTRL0_XTMODE_Pos) & VADC_G_QCTRL0_XTMODE_Msk)|\\" + NL + "        (VADCGroupPtr->QCTRL0 & (((uint32_t)0xF)<< VADC_G_QCTRL0_XTSEL_Pos)));" + NL + "" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function enables external trigger." + NL + " */" + NL + "status_t ADC002_EnableExternalTrigger(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + NL;
  protected final String TEXT_6 = "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Enables external trigger */" + NL + "    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function disables external trigger." + NL + " */" + NL + "status_t ADC002_DisableExternalTrigger(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Disables external trigger */" + NL + "    CLR_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function checks if there is valid entry in the queue. */" + NL + "status_t ADC002_IsEmpty(const ADC002_HandleType *HandlePtr, " + NL + "                                                    uint8_t *VailidEntryPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /*Checks if there is valid entry in the queue*/" + NL + "    if(VailidEntryPtr != NULL)" + NL + "    {" + NL + "        *VailidEntryPtr = (uint8_t)RD_REG( VADCGroupPtr->QSR0, " + NL + "                          VADC_G_QSR0_EMPTY_Msk, VADC_G_QSR0_EMPTY_Pos);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;                          " + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* This function indicates number of valid entries in the queue. */" + NL + "status_t ADC002_GetFillingLevel(const ADC002_HandleType *HandlePtr, " + NL + "                                                    uint8_t *FillLevelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "  /* Pointer to the VADC Structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "  /* Status of valid entry in the queue */            " + NL + "  uint8_t VailidEntry; " + NL + "  /* Fill level of queue */" + NL + "  uint8_t FillLevelValue = (uint8_t)0;" + NL + "  " + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /*Checks if there is valid entry in the queue*/" + NL + "    if(FillLevelPtr != NULL)" + NL + "    {" + NL + "        FillLevelValue = (uint8_t)RD_REG( VADCGroupPtr->QSR0, " + NL + "                          VADC_G_QSR0_FILL_Msk, VADC_G_QSR0_FILL_Pos);" + NL + "                          " + NL + "        if(FillLevelValue == (uint8_t)0)" + NL + "        {" + NL + "          if(ADC002_IsEmpty(HandlePtr, &VailidEntry) == " + NL + "                                                      (uint32_t)DAVEApp_SUCCESS)" + NL + "          {" + NL + "          " + NL + "            if(VailidEntry == (uint8_t)1)" + NL + "            {" + NL + "              /* If  VailidEntry==1 then queue is empty */" + NL + "              *FillLevelPtr = (uint8_t)0;" + NL + "              Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "            }" + NL + "            else" + NL + "            {" + NL + "              /* If  VailidEntry==1 then queue has one valid entry */" + NL + "              *FillLevelPtr = (uint8_t)1;" + NL + "              Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "            }" + NL + "          }" + NL + "          else" + NL + "          {" + NL + "            Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "          }" + NL + "        " + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          /* Entries in the queue will be register read value plus one */" + NL + "          *FillLevelPtr = FillLevelValue + (uint8_t)1;" + NL + "          Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "        }" + NL + "        " + NL + "" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "    " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* This function gets the current level of the selected gate input */" + NL + "status_t ADC002_GetGateLevel(const ADC002_HandleType *HandlePtr, " + NL + "                                                    uint8_t *GateLevelPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Get the input level of selected gate input */" + NL + "    if(GateLevelPtr != NULL)" + NL + "    {" + NL + "      *GateLevelPtr = (uint8_t)RD_REG( VADCGroupPtr->QSR0, " + NL + "                          VADC_G_QSR0_REQGT_Msk, VADC_G_QSR0_REQGT_Pos);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function indicates whether an event has been detected while at" + NL + " * least one valid entry has been in the queue. " + NL + " */" + NL + "status_t ADC002_IsEventDetected(const ADC002_HandleType *HandlePtr, " + NL + "                                                    uint8_t *EventPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Get the event detection. */" + NL + "    if(EventPtr != NULL)" + NL + "    {" + NL + "        *EventPtr = (uint8_t)RD_REG( VADCGroupPtr->QSR0, " + NL + "                                    VADC_G_QSR0_EV_Msk, VADC_G_QSR0_EV_Pos);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;                                    " + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function makes the entry to the queue request" + NL + " */" + NL + "status_t ADC002_AddQueueEntry(const ADC002_HandleType *HandlePtr, " + NL + "                               const ADC002_QueueEntryHandleType *QueueEntryPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "  uint32_t QINR0Val;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Register the queue entry */" + NL + "    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\\" + NL + "              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))" + NL + "    {" + NL + "      QINR0Val = (uint32_t)" + NL + "        (((uint32_t)QueueEntryPtr->ChannelNumber << VADC_G_QINR0_REQCHNR_Pos) & VADC_G_QINR0_REQCHNR_Msk)  |\\" + NL + "        (((uint32_t)QueueEntryPtr->Refill << VADC_G_QINR0_RF_Pos) & VADC_G_QINR0_RF_Msk)|\\" + NL + "        (((uint32_t)QueueEntryPtr->Interrupt << VADC_G_QINR0_ENSI_Pos)& VADC_G_QINR0_ENSI_Msk)|\\" + NL + "        (((uint32_t)QueueEntryPtr->ExternalTrigger << VADC_G_QINR0_EXTR_Pos) & VADC_G_QINR0_EXTR_Msk);" + NL + "                  " + NL + "      VADCGroupPtr->QINR0 = QINR0Val;" + NL + "      " + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;               " + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function sets standard conversion mode." + NL + " */" + NL + "status_t ADC002_SetConversionMode(const ADC002_HandleType *HandlePtr," + NL + "                                                        uint8_t ConversionMode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(HandlePtr->kGroup_HandlePtr != NULL)" + NL + "    {" + NL + "      /* Set standard conversion mode */" + NL + "      Status = (uint32_t)ADCGROUP001_SetGroupClass0ConvMode(" + NL + "                           HandlePtr->kGroup_HandlePtr,ConversionMode);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function sets sample time for standard conversion." + NL + " */" + NL + "status_t ADC002_SetSampleTime(const ADC002_HandleType *HandlePtr," + NL + "                                                            uint8_t SampleTime)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(HandlePtr->kGroup_HandlePtr != NULL)" + NL + "    {" + NL + "      /* Set sample time for standard conversion. */" + NL + "      Status =(uint32_t)ADCGROUP001_SetGroupClass0SampleTime(" + NL + "                            HandlePtr->kGroup_HandlePtr,SampleTime);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function sets EMUX conversion mode." + NL + " */" + NL + "status_t ADC002_SetEMUXConversionMode(const ADC002_HandleType *HandlePtr," + NL + "                                                      uint8_t ConversionMode)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(HandlePtr->kGroup_HandlePtr != NULL)" + NL + "    {" + NL + "      /* Set EMUX conversion mode */" + NL + "      Status = (uint32_t)ADCGROUP001_SetGroupClass0EmuxConvMode(" + NL + "                        HandlePtr->kGroup_HandlePtr,ConversionMode);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function sets sample time for EMUX conversion." + NL + " */" + NL + "status_t ADC002_EMUXSetSampleTime(const ADC002_HandleType *HandlePtr," + NL + "                                                            uint8_t SampleTime)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(HandlePtr->kGroup_HandlePtr != NULL)" + NL + "    {" + NL + "      /* Set sample time for EMUX conversion*/" + NL + "      Status = (uint32_t)ADCGROUP001_SetGroupClass0EmuxSampleTime(" + NL + "                              HandlePtr->kGroup_HandlePtr,SampleTime);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function gets the current level of the selected gate input */" + NL + "status_t ADC002_GetQueueStage0Entry(const ADC002_HandleType *HandlePtr, " + NL + "                                                    uint32_t *EntryPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + NL;
  protected final String TEXT_7 = "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Get the queue stage 0 entry 0 */" + NL + "    if(EntryPtr != NULL)" + NL + "    {" + NL + "        *EntryPtr = (uint32_t)VADCGroupPtr->Q0R0;" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function gets the current level of the selected gate input */" + NL + "status_t ADC002_GetQueueBackupStageEntry(const ADC002_HandleType *HandlePtr, " + NL + "                                                    uint32_t *EntryPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Get the queue backup stage entry */" + NL + "    if(EntryPtr != NULL)" + NL + "    {" + NL + "      *EntryPtr = (uint32_t)VADCGroupPtr->QBUR0;" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function gets the Event flag. */" + NL + "status_t ADC002_GetSourceEventFlag(const ADC002_HandleType *HandlePtr, " + NL + "                                                            uint8_t *Flagptr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    if(Flagptr != NULL)" + NL + "    {" + NL + "      /* Gets event flag */" + NL + "      *Flagptr = (uint8_t)RD_REG( VADCGroupPtr->SEFLAG, " + NL + "                               VADC_G_SEFLAG_SEV0_Msk, VADC_G_SEFLAG_SEV0_Pos);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* This function sets the Event flag. */" + NL + "status_t ADC002_SetSourceEventFlag(const ADC002_HandleType *HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "    /* Sets event flag */" + NL + "    SET_BIT(VADCGroupPtr->SEFLAG, VADC_G_SEFLAG_SEV0_Pos);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function clears the source Event flag. */" + NL + "status_t ADC002_ClearSourceEventFlag(const ADC002_HandleType *HandlePtr) " + NL + "{" + NL + "  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;" + NL + "    /*Pointer to the VADC Group register structure */" + NL + "  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;" + NL + "  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);" + NL + "" + NL + "  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)" + NL + "  {" + NL + "      /* Sets event flag */" + NL + "      SET_BIT(VADCGroupPtr->SEFCLR, VADC_G_SEFCLR_SEV0_Pos);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);" + NL + "  }" + NL + "  " + NL + "  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_8 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/ADC002/"; 
     String Periuri = "http://www.infineon.com/0.1.31/Peripheral/vadc/"; 
     String appInst  = null; 
     String ConfigUri = null; 
     String kernelUri = null; 
     String kernelNo = null; 
    stringBuffer.append(TEXT_2);
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/ADC002/"));
for (String appIns : appsList ) {
  appInst = appIns.substring(appIns.lastIndexOf("/")+1);
    stringBuffer.append(TEXT_3);
    stringBuffer.append(appInst);
    stringBuffer.append(TEXT_4);
    }
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(TEXT_8);
    return stringBuffer.toString();
  }
}
