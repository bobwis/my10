package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class rtc001h_template
{
  protected static String nl;
  public static synchronized rtc001h_template create(String lineSeparator)
  {
    nl = lineSeparator;
    rtc001h_template result = new rtc001h_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/******************************************************************************" + NL + " *" + NL + " * Copyright (C) 2011 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with" + NL + " * Infineon?s microcontrollers." + NL + " * This file can be freely distributed within development tools that are" + NL + " * supporting such microcontrollers." + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL," + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [Yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Feb 12, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** RP         App Developer                                                   **" + NL + "*******************************************************************************/";
  protected final String TEXT_2 = " " + NL + "/**" + NL + " * @file RTC001.h" + NL + " *" + NL + " * @App Version RTC001 <";
  protected final String TEXT_3 = ">" + NL + " *" + NL + " * @brief  Real Time Clock App implementation header file." + NL + " *" + NL + " */" + NL;
  protected final String TEXT_4 = NL + " #ifndef RTC001_H_" + NL + " #define RTC001_H_" + NL + " /*******************************************************************************" + NL + "**                      Include Files                                          **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Macro Definitions                              **" + NL + "*******************************************************************************/";
  protected final String TEXT_5 = "\t" + NL + "/** " + NL + " * Note: This part of the code will be generated if Software Timer is" + NL + " *       enabled. This part is not reviewed and tested" + NL + " **/" + NL + "/** Maximum No of timers */" + NL + "#define RTC001_CFG_MAX_TMR 32";
  protected final String TEXT_6 = NL + "#if defined (__GNUC__)" + NL + "#include <sys/time.h>" + NL + "#elif defined(__TASKING__)" + NL + "#include <time.h>" + NL + "#endif" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Type Definitions                               **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup RTC001_publicparam" + NL + " * @{" + NL + " */";
  protected final String TEXT_7 = "\t" + NL + " /** " + NL + "  * Note: This part of the code will be generated if Software Timer is" + NL + "  *       enabled. This part is not reviewed and tested" + NL + "  **/ " + NL + "/**" + NL + " * The RTC001 App contains two timer types for periodic timer functionality" + NL + " * and single shot timer functionality. This enum describes the timer types used." + NL + " */" + NL + "typedef enum RTC001_TimerType" + NL + "{" + NL + "  /** Timer Type selected is one shot */" + NL + "  RTC001_ONE_SHOT,  " + NL + "  /** Timer Type selected is periodic */" + NL + "  RTC001_PERIODIC                           " + NL + "}RTC001_TimerType;";
  protected final String TEXT_8 = NL + NL + NL + "/**" + NL + " * This enumeration defines RTC001 App error and status values." + NL + " */" + NL + "" + NL + "typedef enum RTC001_ErrorType" + NL + "{" + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param MODULENAME RTC001" + NL + "  * @endcond" + NL + "  */" + NL + "/**" + NL + "  * Invalid handle or parameter" + NL + "  */" + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param ERRCODESTRING1 RTC001_INVALID_HANDLE" + NL + "  * @param STRCODESTRING1 Invalid Handle or Parameter" + NL + "  * @endcond" + NL + "  */" + NL + "" + NL + "  RTC001_INVALID_HANDLE = 1," + NL + "/**" + NL + "  * Undefined Error" + NL + "  */" + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param ERRCODESTRING2 RTC001_ERROR" + NL + "  * @param STRCODESTRING2 Undefined Error" + NL + "  * @endcond" + NL + "  */" + NL + "  RTC001_ERROR," + NL + "/**" + NL + "  * Flag is set" + NL + "  */  " + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param ERRCODESTRING2 RTC001_SET" + NL + "  * @param STRCODESTRING2 Flag is Set" + NL + "  * @endcond" + NL + "  */" + NL + "  RTC001_SET," + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param ERRCODESTRING2 RTC001_RESET" + NL + "  * @param STRCODESTRING2 Flag is Reset" + NL + "  * @endcond" + NL + "  */" + NL + "/**" + NL + "  * Flag is reset" + NL + "  */  " + NL + "  RTC001_RESET," + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param ERRCODESTRING2 RTC001_FUNCTION_ENTRY" + NL + "  * @param STRCODESTRING2 Entered function \\%s" + NL + "  * @endcond" + NL + "  */" + NL + "  RTC001_FUNCTION_ENTRY," + NL + "/**" + NL + "  * @cond INTERNAL_DOCS" + NL + "  * @param ERRCODESTRING3 RTC001_FUNCTION_EXIT" + NL + "  * @param STRCODESTRING3 Exited function \\%s" + NL + "  * @endcond" + NL + "  */" + NL + "  RTC001_FUNCTION_EXIT" + NL + "}RTC001_ErrorType;" + NL + "" + NL + "" + NL + "/**" + NL + " * The below set of flags are used to indicate RTC module's" + NL + " * Alarm and Periodic Timer event status. They can be" + NL + " * used while clearing the status as well." + NL + " */" + NL + "" + NL + "typedef enum RTC001_FlagType" + NL + "{" + NL + "  /** The Seconds flag in RTC */" + NL + "  SECONDS_FLAG = 0x1U," + NL + "  /** The Minutes flag in RTC */" + NL + "  MINUTES_FLAG = 0x2U," + NL + "  /** The Hours flag in RTC */" + NL + "  HOURS_FLAG = 0x4U," + NL + "  /** The Days flag in RTC */" + NL + "  DAYS_FLAG = 0x8U," + NL + "  /** The Months flag in RTC */" + NL + "  MONTHS_FLAG = 0x20U," + NL + "  /** The Years flag in RTC */" + NL + "  YEARS_FLAG = 0x40U," + NL + "  /** The Alarm flag in RTC */" + NL + "  ALARM_FLAG = 0x100U" + NL + "}RTC001_FlagType;" + NL;
  protected final String TEXT_9 = NL + "/** " + NL + " * Note: This part of the code will be generated if Software Timer is" + NL + " *       enabled. This part is not reviewed and tested" + NL + " **/" + NL + "/**" + NL + " * RTC001 App also provides a software timer of its own that allows the user to" + NL + " * configure timers of seconds resolution. This enumeration describes software" + NL + " * timer configurations related to RTC001 App." + NL + " */" + NL + "" + NL + "typedef enum RTC001_SoftwareTimerEnableType" + NL + "{" + NL + "  /** Software timer disable */" + NL + "  SOFTWARE_TIMER_DISABLE," + NL + "  /** Software timer enable */" + NL + "  SOFTWARE_TIMER_ENABLE" + NL + "}RTC001_SoftwareTimerEnableType;";
  protected final String TEXT_10 = NL + NL + "/**" + NL + " * Type of Call back function for Alarm Event." + NL + " * A uint32_t argument can be optionally used." + NL + " */" + NL + "typedef void (*AlarmCallBackPtr)(uint32_t CbArg);" + NL + "" + NL + "/**" + NL + " * Type of Call back function for Periodic Timer Event." + NL + " * A (void *) argument can be optionally used." + NL + " *" + NL + " */" + NL + "typedef void (*RTC001_TimerCallBackPtr)(void*);" + NL;
  protected final String TEXT_11 = "\t" + NL + "/** " + NL + " * Note: This part of the code will be generated if Software Timer is" + NL + " *       enabled. This part is not reviewed and tested" + NL + " **/" + NL + "/**" + NL + " * Global structure which acts as the timer control block." + NL + " */" + NL + "typedef struct RTC001_TimerObject" + NL + "{" + NL + "  /* <<<DD_RTC001_STRUCT_1>>> */" + NL + "  /** Each timer created is identified by a unique timer id */" + NL + "  uint8_t TimerID;" + NL + "  /** Timer Type (Single Shot or Periodic) */" + NL + "  RTC001_TimerType TimerType;" + NL + "  /** Timer State  */" + NL + "  uint8_t TimerState;" + NL + "  /** The count of the timer entered by the user  */" + NL + "  uint32_t TimerCount;" + NL + "  /** The count value to be reloaded in the case of a periodic timer */" + NL + "  uint32_t TimerReload;" + NL + "  /** Timer Callback function pointer */" + NL + "  RTC001_TimerCallBackPtr TimerCallBack;" + NL + "  /** Parameter to callback function */" + NL + "  void* ParamToCallBack;" + NL + "  /** The pointer to next timer control block */" + NL + "  struct RTC001_TimerObject*  TimerNext;" + NL + "  /** The pointer to previous timer control block */" + NL + "  struct RTC001_TimerObject*  TimerPrev;" + NL + "}RTC001_TimerObject;";
  protected final String TEXT_12 = NL + "/**" + NL + " * Structure for RTC Time configuration." + NL + " */" + NL + "typedef struct RTC001_TimeHandle" + NL + "{" + NL + "  /** Time value to be entered in seconds field */" + NL + "  uint8_t Sec;" + NL + "  /** Time value to be entered in minutes field*/" + NL + "  uint8_t Min;" + NL + "  /** Time value to be entered in hours field*/" + NL + "  uint8_t Hours;" + NL + "  /** Time value to be entered in days field */" + NL + "  uint8_t Days;" + NL + "  /** Time value to be entered in days of week field*/" + NL + "  uint8_t DaWe;" + NL + "  /** Time value to be entered in months field*/" + NL + "  uint8_t Month;" + NL + "  /** Time value to be entered in years field*/" + NL + "  uint16_t Year;" + NL + "}RTC001_TimeHandle;" + NL + "" + NL + "" + NL + "/**" + NL + "* RTC001 App Handle structure. Stores a few parameters configured in App UI." + NL + " */" + NL + "" + NL + "typedef struct  RTC001_HandleType" + NL + "{";
  protected final String TEXT_13 = "\t\t\t\t\t\t" + NL + "  /** Software timer selection, the user can enable the software timer if needed */" + NL + "  RTC001_SoftwareTimerEnableType SoftwareTimerSel;";
  protected final String TEXT_14 = NL + " /** If value of this flag is 1, then RTC time value will be initialized" + NL + "  * only once even after system reset" + NL + "  */" + NL + "  bool RTCInitOnce;" + NL + "  /** Clock divider value */" + NL + "  uint16_t DividerValue;" + NL + "}RTC001_HandleType;" + NL + "" + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Declarations                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Extern Variables                                      **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                     FUNCTION PROTOTYPES                                    **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup RTC001_apidoc" + NL + " * @{" + NL + " */" + NL + "" + NL + " /**" + NL + " * Initialization function for the App." + NL + " * This function configures the RTC module registers as per options given in App UI and enables the RTC module." + NL + " *" + NL + " *" + NL + " *" + NL + " * @return     void" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    // Initialize Apps" + NL + " *    DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {}" + NL + " *  }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "void  RTC001_Init(void);" + NL + "" + NL + "" + NL + " /**" + NL + " * Deinitialization function for the app. Current version of the function is empty." + NL + " *" + NL + " * @return     void" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    // Initialize Apps" + NL + " *    DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *    RTC001_DeInit();" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {}" + NL + " *  }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "void  RTC001_DeInit(void);" + NL + "" + NL + "" + NL + " /**" + NL + " * Enables the RTC module. May be called if RTC module is disabled previously." + NL + " *" + NL + " *" + NL + " * @return     status <br>" + NL + " *             DAVEApp_SUCCESS\t: for success <br>" + NL + " *             RTC001_ERROR  \t: for failure case <br>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    // Initialize Apps" + NL + " *    DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *    RTC001_Enable();" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {}" + NL + " *  }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t  RTC001_Enable(void);" + NL + "" + NL + "" + NL + " /**" + NL + " * This function disables the RTC Module." + NL + " * Time and Alarm registers are cleared. Can be used to Disable RTC module before configuring RTC Time." + NL + " *" + NL + " * @return     status <br>" + NL + " *             DAVEApp_SUCCESS\t: If Disable successful <br>" + NL + " *             RTC001_ERROR  \t: If any error during Disable <br>" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    // Initialize Apps" + NL + " *    DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *    RTC001_Disable();" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {}" + NL + " *  }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t  RTC001_Disable(void);" + NL + "" + NL + "" + NL + " /**" + NL + " * This function clears the given RTC flag." + NL + " *" + NL + " * @param[in]  Flag Indicates which flag to clear. Use the symbolic constants enumerated by RTC001_FlagType." + NL + " * @return     void" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    // Initialize Apps" + NL + " *    DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *    RTC001_Enable();" + NL + " *    while(!RTC001_GetFlagStatus(HOURS_FLAG))" + NL + " *    {" + NL + " *      // Hour event happened" + NL + " *      RTC001_ClearFlagStatus(HOURS_FLAG);" + NL + " *    }" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {}" + NL + " *  }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "void  RTC001_ClearFlagStatus(RTC001_FlagType Flag);" + NL + "" + NL + "" + NL + " /**" + NL + " * Get the status of specified flag." + NL + " *" + NL + " * @param[in]  Flag Indicates which Flag to be checked. Use the symbolic constants enumerated by RTC001_FlagType." + NL + " *" + NL + " * @return     status <br>" + NL + " *             RTC001_SET\t    : Flag is set <br>" + NL + " *             RTC001_RESET  \t: Flag is reset <br>" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   // Initialize Apps" + NL + " *   DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *   RTC001_Enable();" + NL + " *   while(!RTC001_GetFlagStatus(HOURS_FLAG))" + NL + " *   {" + NL + " *     // Hour event happened" + NL + " *     RTC001_ClearFlagStatus(HOURS_FLAG);" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t  RTC001_GetFlagStatus(RTC001_FlagType Flag);" + NL;
  protected final String TEXT_15 = "\t" + NL + "/** " + NL + " * Note: This part of the code will be generated if Software Timer is" + NL + " *       enabled. This part is not reviewed and tested" + NL + " **/" + NL + "/**" + NL + " * Interface for creating a new software Timer instance." + NL + " *" + NL + " * Note : One shot timers are removed from the timer list, if it expires. To use" + NL + " * this SW timer again it have to be first deleted and then created again." + NL + " * Periodic timer will be added again to the timer list with the same periodic" + NL + " * value after it expires." + NL + " *" + NL + " * @param[in]  Period Timer period value in sec" + NL + " * @param[in]  TimerType Type of Timer(RTC001_ONE_SHOT/RTC001_PERIODIC)" + NL + " * @param[in]  TimerCallBack Call back function of the timer" + NL + " * @param[in]  pCallBackArgPtr Call back function parameter" + NL + " * @return     handle_t Timer ID allocated" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * static volatile bool TimerExpired;" + NL + " * void Timer_CallBack(void* Temp)" + NL + " * {" + NL + " *   static uint32_t Count = 1;" + NL + " *   if(Count == 10)" + NL + " *   {" + NL + " *     TimerExpired = TRUE;" + NL + " *   }" + NL + " *   Count++;" + NL + " * }" + NL + " * int main(void)" + NL + " * {" + NL + " *   handle_t TimerId;" + NL + " *   uint32_t Status;" + NL + " *    // ... Initializes Apps ..." + NL + " *   DAVE_Init();" + NL + " *   TimerId = RTC001_CreateTimer(100,RTC001_PERIODIC,Timer_CallBack,NULL);" + NL + " *   if(TimerId != 0)" + NL + " *   {" + NL + " *     //Timer is created successfully" + NL + " *     Status = RTC001_StartTimer(TimerId);" + NL + " *     if(Status == DAVEApp_SUCCESS)" + NL + " *     {" + NL + " *   \t //Timer started" + NL + " *     }" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *     while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "handle_t RTC001_CreateTimer" + NL + "(" + NL + "  uint32_t Period," + NL + "  RTC001_TimerType TimerType," + NL + "  RTC001_TimerCallBackPtr TimerCallBack," + NL + "  void  * pCallBackArgPtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * Interface to start the software timer ." + NL + " *" + NL + " * @param[in]  Handle Timer ID obtained from RTC001_CreateTimer" + NL + " * @return     status_t" + NL + " *             DAVEApp_SUCCESS if timer is created successfully" + NL + " *             RTC001_INVALID_HANDLE If passed Timer Id invalid" + NL + " *             RTC001_ERROR Unknown Error" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * static volatile bool TimerExpired;" + NL + " * void Timer_CallBack(void* Temp)" + NL + " * {" + NL + " *   static uint32_t Count = 1;" + NL + " *   if(Count == 10)" + NL + " *   {" + NL + " *     TimerExpired = TRUE;" + NL + " *   }" + NL + " *   Count++;" + NL + " * }" + NL + " * int main(void)" + NL + " * {" + NL + " *   handle_t TimerId;" + NL + " *   uint32_t Status;" + NL + " *    // ... Initializes Apps ..." + NL + " *   DAVE_Init();" + NL + " *   TimerId = RTC001_CreateTimer(100,RTC001_PERIODIC,Timer_CallBack,NULL);" + NL + " *   if(TimerId != 0)" + NL + " *   {" + NL + " *     //Timer is created successfully" + NL + " *     Status = RTC001_StartTimer(TimerId);" + NL + " *     if(Status == DAVEApp_SUCCESS)" + NL + " *     {" + NL + " *   \t //Timer started" + NL + " *     }" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_StartTimer(handle_t  Handle) ;" + NL + "" + NL + "" + NL + "/**" + NL + " * Interface to stop the software timer ." + NL + " *" + NL + " * @param[in]  Handle Timer ID obtained from RTC001_CreateTimer" + NL + " * @return     status_t" + NL + " *             DAVEApp_SUCCESS if timer is stopped successfully" + NL + " *             RTC001_INVALID_HANDLE If passed Timer Id invalid" + NL + " *             RTC001_ERROR Unknown Error" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * static volatile bool TimerExpired;" + NL + " * void Timer_CallBack(void* Temp)" + NL + " * {" + NL + " *   static uint32_t Count = 1;" + NL + " *   if(Count == 10)" + NL + " *   {" + NL + " *     TimerExpired = TRUE;" + NL + " *   }" + NL + " *   Count++;" + NL + " * }" + NL + " * int main(void)" + NL + " * {" + NL + " *   handle_t TimerId;" + NL + " *   uint32_t Status;" + NL + " *    // ... Initializes Apps ..." + NL + " *   DAVE_Init();" + NL + " *   TimerId = RTC001_CreateTimer(100,RTC001_PERIODIC,Timer_CallBack,NULL);" + NL + " *   if(TimerId != 0)" + NL + " *   {" + NL + " *     //Timer is created successfully" + NL + " *     Status = RTC001_StartTimer(TimerId);" + NL + " *     if(Status == DAVEApp_SUCCESS)" + NL + " *     {" + NL + " *       // Wait till timer is expired" + NL + " *       while(TimerExpired == FALSE)" + NL + " *       {}" + NL + " *       //stop the timer" + NL + " *       Status = RTC001_StopTimer(TimerId);" + NL + " *       if(Status == DAVEApp_SUCCESS)" + NL + " *       {" + NL + " *         //Timer stopped" + NL + " *       }" + NL + " *     }" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_StopTimer(handle_t Handle) ;" + NL + "" + NL + "" + NL + "/**" + NL + " * Delete the Timer instance." + NL + " *" + NL + " * Note : One shot timers are removed from the timer list, if it expires. To use" + NL + " * this SW timer again it have to be first deleted and then created again." + NL + " * Periodic timer will be added again to the timer list with the same periodic" + NL + " * value after it expires." + NL + " *" + NL + " * @param[in]  Handle Timer ID obtained from RTC001_CreateTimer" + NL + " * @return     status_t" + NL + " *             DAVEApp_SUCCESS : if timer is deleted successfully<BR>" + NL + " *             RTC001_INVALID_HANDLE : If passed Timer Id invalid" + NL + " *             RTC001_ERROR : Unknown Error" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * static volatile bool TimerExpired;" + NL + " * void Timer_CallBack(void* Temp)" + NL + " * {" + NL + " *   static uint32_t Count = 1;" + NL + " *   if(Count == 10)" + NL + " *   {" + NL + " *     TimerExpired = TRUE;" + NL + " *   }" + NL + " *   Count++;" + NL + " * }" + NL + " * int main(void)" + NL + " * {" + NL + " *   handle_t TimerId;" + NL + " *   uint32_t Status;" + NL + " *    // ... Initializes Apps ..." + NL + " *   DAVE_Init();" + NL + " *   TimerId = RTC001_CreateTimer(100,RTC001_PERIODIC,Timer_CallBack,NULL);" + NL + " *   if(TimerId != 0)" + NL + " *   {" + NL + " *     //Timer is created successfully" + NL + " *     Status = RTC001_StartTimer(TimerId);" + NL + " *     if(Status == DAVEApp_SUCCESS)" + NL + " *     {" + NL + " *       // Wait till timer is expired" + NL + " *    \t while(TimerExpired == FALSE)" + NL + " *       {}" + NL + " *       //stop the timer" + NL + " *    \t Status = RTC001_StopTimer(TimerId);" + NL + " *    \t if(Status == DAVEApp_SUCCESS)" + NL + " *    \t {" + NL + " *    \t   //Timer stopped" + NL + " *         RTC001_DeleteTimer(TimerId);" + NL + " *    \t }" + NL + " *     }" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_DeleteTimer(handle_t Handle) ;";
  protected final String TEXT_16 = NL + NL + "/**" + NL + " * This function configures the RTC001 Alarm." + NL + " * If the Alarm Event interrupt is connected to SCU, then optionally a call" + NL + " * back function can be registered for the interrupt." + NL + " *" + NL + " * @param[in] Handle RTC app Handle<BR>" + NL + " * @param[in] timeptr Pointer to structure which contains Alarm Time <BR>" + NL + " *           " + NL + " * @param[in] CallBack Alarm event call back function." + NL + " *            If the Alarm Event is connected to SCU, the call back will be registered with NVIC_SCU001 app." + NL + " *            If NULL is given, then call back is not registered<BR>" + NL + " * @param[in] CbArg (Optional) argument to be passed to the call back function<BR>" + NL + " *" + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS : if Alarm configuration is successful<BR>" + NL + " *             RTC001_INVALID_HANDLE: If any of the parameter is invalid<BR>" + NL + " *             RTC001_ERROR    : If any error during Alarm configuration <BR>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * static volatile bool AlarmEvent;" + NL + " * void Alarm_CallBack(uint32_t Temp)" + NL + " * {" + NL + " *   AlarmEvent = TRUE;" + NL + " * }" + NL + " * int main(void)" + NL + " * {" + NL + " *   uint32_t Status;" + NL + " *   RTC001_TimeHandle Alarm_Time;" + NL + " *    // ... Initializes Apps ..." + NL + " *   DAVE_Init();" + NL + " *   Alarm_Time.Sec = 32;" + NL + " *   Alarm_Time.Min = 30;" + NL + " *   Alarm_Time.Hours = 4;" + NL + " *   Alarm_Time.Days = 15;" + NL + " *   Alarm_Time.Month = 5;" + NL + " *   Alarm_Time.Year = 2012;" + NL + " *   Status = RTC001_ConfigAlarm(&RTC001_Handle,&Alarm_Time,Alarm_CallBack,0);" + NL + " *   if(Status == DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *     //Alarm is created successfully" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_ConfigAlarm (const RTC001_HandleType* Handle, RTC001_TimeHandle* timeptr, AlarmCallBackPtr CallBack,uint32_t CbArg) ;" + NL + "" + NL + "" + NL + "/**" + NL + " * This function gets the current time from RTC." + NL + " *" + NL + " * @param[in] timeptr Pointer to structure in which current time is returned<BR>" + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS : If RTC time is read successfully<BR>" + NL + " *             RTC001_ERROR    : If any error during reading<BR>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   RTC001_TimeHandle CurrentTime;" + NL + " *   // Initialize Apps" + NL + " *   DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *   RTC001_Enable();" + NL + " *   while(!RTC001_GetFlagStatus(HOURS_FLAG))" + NL + " *   {" + NL + " *     // Read current time" + NL + " *     RTC001_Clock_GetTime(&CurrentTime);" + NL + " *   }" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_Clock_GetTime (RTC001_TimeHandle* timeptr);" + NL + "" + NL + "/**" + NL + " * This function sets the RTC time. It is recommended to Disable RTC module before using this function." + NL + " *" + NL + " * @param[in] timeptr Pointer to structure which contains time " + NL + " * \t\t\t\t\t  values to be configured<BR>" + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS : If the RTC time is successfully configured<BR>" + NL + " *             RTC001_ERROR    : If any error during reading the time<BR>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   RTC001_TimeHandle SetTime;" + NL + " *   uint32_t Status;" + NL + " *   // Initialize Apps" + NL + " *   DAVE_Init(); // RTC001_Init() will be called within DAVE_Init()" + NL + " *   RTC001_Disable();" + NL + " *   SetTime.Sec = 32;" + NL + " *   SetTime.Min = 30;" + NL + " *   SetTime.Hours = 4;" + NL + " *   SetTime.Days = 15;" + NL + " *   SetTime.Month = 5;" + NL + " *   SetTime.Year = 2012;" + NL + " *   Status = RTC001_Clock_SetTime(&SetTime);" + NL + " *   if(Status == DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *     //Success" + NL + " *   }" + NL + " *   RTC001_Enable();" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_Clock_SetTime(RTC001_TimeHandle* timeptr);" + NL + "" + NL + "" + NL + "/**" + NL + " * This function returns the time in seconds since the epoch time(01/01/1970)." + NL + " *" + NL + " * @param[in] time_value Pointer to an object of type time_t, " + NL + " *                   for returning the time.  <BR>" + NL + " *" + NL + " * " + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS : if time value is calculated successfully<BR>" + NL + " *             RTC001_ERROR    : If any error<BR>" + NL + " *                 " + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code " + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   status_t status = RTC001_ERROR;" + NL + " *   time_t Time_Sec;" + NL + " *   // ... Initializes Apps ..." + NL + " *   DAVE_Init();" + NL + " *   status = RTC001_Time(&Time_Sec);" + NL + " *   if(status != DAVEApp_SUCCESS)" + NL + " *   {" + NL + " *\t   //error" + NL + " *   }" + NL + " *   RTC001_Disable();" + NL + " *   // ... infinite loop ..." + NL + " *   while(1)" + NL + " *   {}" + NL + " * }" + NL + " * @endcode<BR> </p> " + NL + " */" + NL + "status_t RTC001_Time(time_t* time_value) ;" + NL + "" + NL + "  " + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "" + NL + "/** Include App config file */" + NL + "#include \"RTC001_Conf.h\"" + NL + "" + NL + "#endif /* RTC001_H_ */" + NL;
  protected final String TEXT_17 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/RTC001/0";
    stringBuffer.append(TEXT_2);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_3);
     String UserFunc = null;
    stringBuffer.append(TEXT_4);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_5);
     } else {
 }
    stringBuffer.append(TEXT_6);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_7);
     } else {
 }
    stringBuffer.append(TEXT_8);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_9);
     } else {
 }
    stringBuffer.append(TEXT_10);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_11);
     } else {
 }
    stringBuffer.append(TEXT_12);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_13);
     } else {
 }
    stringBuffer.append(TEXT_14);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_15);
     } else {
 }
    stringBuffer.append(TEXT_16);
    stringBuffer.append(TEXT_17);
    return stringBuffer.toString();
  }
}
