package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class synopgmac_stack_interfacec_template
{
  protected static String nl;
  public static synchronized synopgmac_stack_interfacec_template create(String lineSeparator)
  {
    nl = lineSeparator;
    synopgmac_stack_interfacec_template result = new synopgmac_stack_interfacec_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[synopGMAC_stack_interface.c]*/" + NL + "/* =============================================================================" + NL + " * Copyright (c) <2009> Synopsys, Inc." + NL + " *" + NL + " * Permission is hereby granted, free of charge, to any person obtaining a copy" + NL + " * of this software annotated with this license and associated documentation" + NL + " * files (the \"Software\"), to deal in the Software without restriction," + NL + " * including without limitation the rights to use, copy, modify, merge, publish," + NL + " * distribute, sublicense, and/or sell copies of the Software, and to permit" + NL + " * persons to whom the Software is furnished to do so, subject to the following" + NL + " * conditions:" + NL + " *" + NL + " * The above copyright notice and this permission notice shall be included in" + NL + " * all copies or substantial portions of the Software." + NL + " *" + NL + " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR" + NL + " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY," + NL + " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE" + NL + " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER" + NL + " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM," + NL + " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE" + NL + " * SOFTWARE." + NL + " *" + NL + " *============================================================================*/" + NL + "/* =========================================================================== * " + NL + " * Copyright (c) 2011, Infineon Technologies AG                                *" + NL + " * All rights reserved.                                                        * " + NL + " *                                                                             *" + NL + " * Redistribution and use in source and binary forms, with or without          *" + NL + " * modification, are permitted provided that the following conditions are met: *" + NL + " * Redistributions of source code must retain the above copyright notice, this *" + NL + " * list of conditions and the following disclaimer. Redistributions in binary  *" + NL + " * form must reproduce the above copyright notice, this list of conditions and *" + NL + " * the following disclaimer in the documentation and/or other materials        *" + NL + " * provided with the distribution. Neither the name of the copyright holders   * " + NL + " * nor the names of its contributors may be used to endorse or promote         *" + NL + " * products derived from this software without specific prior written          * " + NL + " * permission.                                                                 *" + NL + " *                                                                             *" + NL + " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" *" + NL + " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,       *" + NL + " * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR      *" + NL + " * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR           *" + NL + " * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,       *" + NL + " * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,         * " + NL + " * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; *" + NL + " * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,    *" + NL + " * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR     *" + NL + " * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF      *" + NL + " * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                  *" + NL + " * To improve the quality of the software, users are encouraged to share       *" + NL + " * modifications, enhancements or bug fixes with                               *" + NL + " * Infineon Technologies AG (dave@infineon.com).                               *" + NL + " *                                                                             *" + NL + " * ========================================================================== *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : DAVE App Developer                                                **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [Yes/No]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Dec 12, 2012                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + " " + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** JRP          DAVE App Developer                                            **" + NL + "********************************************************************************" + NL;
  protected final String TEXT_2 = NL + " *" + NL + " * @file synopGMAC_stack_interface.c" + NL + " * " + NL + " * @App Version ETH001 <";
  protected final String TEXT_3 = ">" + NL + " *" + NL + " * @brief  Network Interface code for Synop GMAC " + NL + " *" + NL + " * Revision History" + NL + " * 12 Dec 2012  v1.0.16    Base line from version v1.0.14" + NL + " *                         dbg002 related macros are added" + NL + " *" + NL + " */";
  protected final String TEXT_4 = NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL;
  protected final String TEXT_5 = NL + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_6 = NL;
  protected final String TEXT_7 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_8 = "                  " + NL + "" + NL + "/**" + NL + " * @ingroup Ethernet_publicparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Macro Definitions                              **" + NL + "*******************************************************************************/" + NL + "#define APP_GID DBG002_GID_ETH001" + NL + "" + NL + "#ifdef CHECKSUM_BY_HARDWARE" + NL + "  #define IPC_OFFLOAD" + NL + "#endif" + NL + "#define   ETH_BASE          (ETH0_BASE + 0x1000U)  /* not defined in XMC4500 header */" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/* These are the global pointers for their respective structures */" + NL + "synopGMACdevice GMACdevice;" + NL + "synopGMACdevice *synopGMACdev;" + NL + "" + NL + "static SynopGMACPeriodicTimerCallbackType SynopGMACPeriodicTimerCallback;" + NL + "static SynopGMACDeletePeriodicTimerType SynopGMACDeletePeriodicTimer;" + NL + "" + NL + "/** Receive packet buffer list */" + NL + "extern uint8_t Eth_RxBuffer[RX_BUFFER_SIZE];" + NL + "extern uint8_t Eth_TxBuffer[RX_BUFFER_SIZE];" + NL + "" + NL + "/* Cable plug-unplug Timer Handle */" + NL + "/*handle_t Eth_TimerHandle;*/" + NL + "" + NL + "/* This global variable is used to indicate the ISR whether the interrupts" + NL + " * occurred in the process of powering down the mac or not" + NL + " */" + NL + "uint32_t GMAC_Power_down;" + NL + "extern s32 synopGMAC_set_tx_address(synopGMACdevice * gmacdev,u32 count, u32 Buffer1);" + NL + "/*******************************************************************************" + NL + "**                      Private Function Declarations                         **" + NL + "*******************************************************************************/" + NL + "" + NL + "static void Eth_lGetRMONCounters(Eth_StructRMONCountersType *Eth_IoctlParam);" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "status_t Eth_GetTxBuffer(uint8_t** Buffer)" + NL + "{" + NL + "\t*Buffer = (uint8_t*)synopGMACdev->TxNextDesc->buffer1;" + NL + "\treturn DAVEApp_SUCCESS;" + NL + "}" + NL + "status_t Eth_InitNetworkInterface(void)" + NL + "{" + NL + "  synopGMACdev = &GMACdevice;" + NL + "  /* Set Ethernet MAC interface  (RMII/MII) to one selected by user */" + NL + "  WR_REG(ETH0_CON->CON, ETH_CON_INFSEL_Msk, ETH_CON_INFSEL_Pos, ETH_MAC_SEL);" + NL + " ";
  protected final String TEXT_9 = "   " + NL + "  /* To disable clock gating for ethernet : ETH0 Clock Gating Clear */" + NL + "  /* " + NL + "   * The disabling of the clock gating is applicable only for" + NL + "   * XMC44xx devices." + NL + "   */  " + NL + "  WR_REG(SCU_CLK->CGATCLR2, SCU_CLK_CGATCLR2_ETH0_Msk, SCU_CLK_CGATCLR2_ETH0_Pos, 1U);";
  protected final String TEXT_10 = "  " + NL + "  " + NL + "  /* To Deassert */" + NL + "  RESET001_DeassertReset(PER2_ETH0);" + NL + "  /** Configure CLKSET*/" + NL + "  WR_REG(SCU_CLK->CLKSET, SCU_CLK_CLKSTAT_ETH0CST_Msk, SCU_CLK_CLKSTAT_ETH0CST_Pos, 1U);  " + NL + "  /* Pad Driver Mode settings */ ";
  protected final String TEXT_11 = " " + NL + "  /* OUT PINs used in ETH for setting Pad drive modes */";
  protected final String TEXT_12 = " ";
  protected final String TEXT_13 = " ";
  protected final String TEXT_14 = " ";
  protected final String TEXT_15 = NL + "  /* Configuration of TXD0 Pin ";
  protected final String TEXT_16 = ".";
  protected final String TEXT_17 = " based on User configuration */";
  protected final String TEXT_18 = NL + "  WR_REG(PORT";
  protected final String TEXT_19 = "->PDR0, PORT";
  protected final String TEXT_20 = "_PDR0_PD";
  protected final String TEXT_21 = "_Msk, PORT";
  protected final String TEXT_22 = "_PDR0_PD";
  protected final String TEXT_23 = "_Pos, ";
  protected final String TEXT_24 = "U);";
  protected final String TEXT_25 = "                                      " + NL + "  WR_REG(PORT";
  protected final String TEXT_26 = "->PDR1, PORT";
  protected final String TEXT_27 = "_PDR1_PD";
  protected final String TEXT_28 = "_Msk, PORT";
  protected final String TEXT_29 = "_PDR1_PD";
  protected final String TEXT_30 = "_Pos, ";
  protected final String TEXT_31 = "U);    ";
  protected final String TEXT_32 = NL + "  /* Configuration of TXD1 Pin ";
  protected final String TEXT_33 = ".";
  protected final String TEXT_34 = " based on User configuration */";
  protected final String TEXT_35 = NL + "  WR_REG(PORT";
  protected final String TEXT_36 = "->PDR0, PORT";
  protected final String TEXT_37 = "_PDR0_PD";
  protected final String TEXT_38 = "_Msk, PORT";
  protected final String TEXT_39 = "_PDR0_PD";
  protected final String TEXT_40 = "_Pos, ";
  protected final String TEXT_41 = "U);";
  protected final String TEXT_42 = "                                      " + NL + "  WR_REG(PORT";
  protected final String TEXT_43 = "->PDR1, PORT";
  protected final String TEXT_44 = "_PDR1_PD";
  protected final String TEXT_45 = "_Msk, PORT";
  protected final String TEXT_46 = "_PDR1_PD";
  protected final String TEXT_47 = "_Pos, ";
  protected final String TEXT_48 = "U);    ";
  protected final String TEXT_49 = NL + "  /* Configuration of TXD1 Pin ";
  protected final String TEXT_50 = ".";
  protected final String TEXT_51 = " based on User configuration */";
  protected final String TEXT_52 = NL + "  WR_REG(PORT";
  protected final String TEXT_53 = "->PDR0, PORT";
  protected final String TEXT_54 = "_PDR0_PD";
  protected final String TEXT_55 = "_Msk, PORT";
  protected final String TEXT_56 = "_PDR0_PD";
  protected final String TEXT_57 = "_Pos, ";
  protected final String TEXT_58 = "U);";
  protected final String TEXT_59 = "                                      " + NL + "  WR_REG(PORT";
  protected final String TEXT_60 = "->PDR1, PORT";
  protected final String TEXT_61 = "_PDR1_PD";
  protected final String TEXT_62 = "_Msk, PORT";
  protected final String TEXT_63 = "_PDR1_PD";
  protected final String TEXT_64 = "_Pos, ";
  protected final String TEXT_65 = "U);    ";
  protected final String TEXT_66 = "   " + NL + "  /* <<<DD_ETH_PORT_1>>> */" + NL + "  /* Attach the device to MAC struct. This will configure all the required base" + NL + "   * addresses such as MAC base, Configuration base, PHY base address" + NL + "   * (out of 32 possible phys )" + NL + "   */" + NL + "  synopGMAC_attach(synopGMACdev, ETH0_BASE, ETH_BASE, PHY_BASE_ADDRESS);  " + NL + "  /* Reset the GMAC */" + NL + "  synopGMAC_reset(synopGMACdev);" + NL + "  " + NL + "  DBG002_INFO(APP_GID, ETH_INIT_SUCCESS, 0, NULL);" + NL + "  return DAVEApp_SUCCESS;" + NL + "}" + NL + "" + NL + "" + NL + "void Eth_ExitNetworkInterface(void)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_2>>> */" + NL + "  /* This function is an empty function kept for uniformity */" + NL + "  DBG002_INFO(APP_GID, ETH_EXIT_SUCCESS, 0, NULL);" + NL + "}" + NL + "" + NL + "" + NL + "status_t Eth_OpenNetworkInterface(void)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_3>>> */" + NL + "  status_t Status = ETH_OPEN_ERROR;" + NL + "  uint32_t DescCount = 0;" + NL + "  int32_t DescStatus = -1;" + NL + "" + NL + "  do" + NL + "  {" + NL + "    /* Now platform dependent initialization.*/" + NL + "" + NL + "    /* Attach the device to MAC struct. This will configure all the required base" + NL + "     * addresses such as MAC base, Configuration base, PHY base address(out of 32" + NL + "     * possible PHYs)" + NL + "     */" + NL + "" + NL + "    synopGMAC_attach(synopGMACdev, ETH0_BASE, ETH_BASE, PHY_BASE_ADDRESS);" + NL + "" + NL + "    /* Lets read the version of IP in to device structure*/" + NL + "    synopGMAC_read_version(synopGMACdev);" + NL + "" + NL + "    /* Stack should use IOCTL to get the MAC Address */" + NL + "    synopGMAC_get_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low," + NL + "        synopGMACdev->MacAddress);" + NL + "" + NL + "    /* Check for PHY initialization */" + NL + "    synopGMAC_set_mdc_clk_div(synopGMACdev, GmiiCsrClk3);" + NL + "" + NL + "    synopGMACdev->ClockDivMdc = synopGMAC_get_mdc_clk_div(synopGMACdev);" + NL + "" + NL + "    /* Initialize Ethernet PHY */" + NL + "    Status = PHY_InitializeDevice();" + NL + "    if (Status != DAVEApp_SUCCESS)" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID, Status, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "" + NL + "#ifndef BUILD_UIP  /* UIP polls the packets. Hence no interrupt handler.*/" + NL + "    /* ISR will be registered via NVIC */" + NL + "    NVIC_SetPriority(";
  protected final String TEXT_67 = ", NVIC_EncodePriority(NVIC_GetPriorityGrouping()," + NL + "       \t\t\t                                    ";
  protected final String TEXT_68 = ", ";
  protected final String TEXT_69 = "));" + NL + "    NVIC_EnableIRQ(";
  protected final String TEXT_70 = ");" + NL + "#endif " + NL + "" + NL + "    /* Set up the TX descriptor queue/ring */" + NL + "    /* Configure the descriptors in RING mode */" + NL + "    synopGMAC_setup_tx_desc_queue(synopGMACdev, TRANSMIT_DESC_SIZE, RINGMODE);" + NL + "" + NL + "    /* Program the transmit descriptor base address in to DmaTxBase Address */" + NL + "    synopGMAC_init_tx_desc_base(synopGMACdev);" + NL + "" + NL + "    /* Set up the Rx descriptor queue/ring */" + NL + "    synopGMAC_setup_rx_desc_queue(synopGMACdev, RECEIVE_DESC_SIZE, RINGMODE);" + NL + "" + NL + "    /* Program the receive descriptor base address in to DmaTxBase Address */" + NL + "    synopGMAC_init_rx_desc_base(synopGMACdev);" + NL + "" + NL + "#ifdef ENH_DESC_8W" + NL + "    /* Note: Keeping the default values */" + NL + "    /* pbl32 incr with rxthreshold 128 and Desc is 8 Words */" + NL + "    synopGMAC_dma_bus_mode_init(synopGMACdev, DmaBurstLength32 |" + NL + "        DmaDescriptorSkip2 | DmaDescriptor8Words );" + NL + "" + NL + "#else" + NL + "    /* Note: Keeping the default values */" + NL + "    /* pbl32 incr with rxthreshold 128 */" + NL + "    synopGMAC_dma_bus_mode_init(synopGMACdev," + NL + "        DmaBurstLength32 | DmaDescriptorSkip2);" + NL + "#endif" + NL + "" + NL + "    /* Configure Store and forward, OSF, RX threshold control */" + NL + "    synopGMAC_dma_control_init(synopGMACdev," + NL + "        DmaStoreAndForward | DmaTxSecondFrame | DmaRxThreshCtrl128);" + NL + "\t\t " + NL + "#ifdef HALF_DUPLEX" + NL + "    synopGMACdev->DuplexMode = HALFDUPLEX;" + NL + "#else" + NL + "    synopGMACdev->DuplexMode = FULLDUPLEX;" + NL + "#endif" + NL + "" + NL + "#ifdef SPEED_100\t" + NL + "\tsynopGMAC_rmii_100mbps_enable(synopGMACdev); " + NL + "#endif" + NL + "" + NL + "#if AUTO_NEGO" + NL + "\tsynopGMAC_rmii_100mbps_enable(synopGMACdev); " + NL + "#endif" + NL + "    /* Initialize the MAC interface */" + NL + "    synopGMAC_mac_init(synopGMACdev);" + NL + "" + NL + "#ifdef ENABLE_MULTICAST    " + NL + "    /* To enable Multicast */" + NL + "    synopGMAC_multicast_enable(synopGMACdev);" + NL + "" + NL + "    synopGMAC_multicast_hash_filter_enable(synopGMACdev);" + NL + "#endif" + NL + "    " + NL + "   /* To enable Broadcast */" + NL + "   synopGMAC_broadcast_enable(synopGMACdev);" + NL + "   " + NL + "#ifdef  ENABLE_PROMISCUOUS" + NL + "   /* To enable Promiscuous Mode. */" + NL + "   synopGMAC_promisc_enable(synopGMACdev); " + NL + "#endif" + NL + "   " + NL + "#ifndef HALF_DUPLEX" + NL + "    /* This enables the pause control in Full Duplex mode of operation */" + NL + "    //synopGMAC_pause_control(synopGMACdev);" + NL + "#endif" + NL + "" + NL + "  /* Enable this when Stack allows CHECKSUM OFFLOADING */" + NL + "#ifdef IPC_OFFLOAD" + NL + "    /* <<<DD_ETH_PORT_3_1>>> */" + NL + "    /* <<<DD_ETH_PORT_3_2>>> */" + NL + "" + NL + "    /* IPC Checksum offloading is enabled for this driver. Should only be used" + NL + "     * if Full IP checksum offload engine is configured in the hardware" + NL + "     */" + NL + "" + NL + "    /* Enable the offload engine in the receive path */" + NL + "    synopGMAC_enable_rx_chksum_offload(synopGMACdev);" + NL + "" + NL + "    /* This is default configuration, DMA drops the packets if error in" + NL + "     * encapsulated Ethernet payload" + NL + "     */" + NL + "    synopGMAC_rx_tcpip_chksum_drop_enable(synopGMACdev);" + NL + "" + NL + "    /* The FEF bit in DMA control register is configured to 0 indicating DMA to" + NL + "     * drop the errored frames." + NL + "     */" + NL + "#endif" + NL + "" + NL + "    do" + NL + "    {" + NL + "      DescStatus = synopGMAC_set_rx_qptr(synopGMACdev," + NL + "                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE]," + NL + "                                 ETH_PACKET_SIZE," + NL + "                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE]," + NL + "                                 0,0,0);" + NL + "" + NL + "" + NL + "      DescStatus = synopGMAC_set_tx_address(synopGMACdev, DescCount," + NL + "                                            (uint32_t)&Eth_TxBuffer[DescCount * ETH_PACKET_SIZE]" + NL + "                                            );" + NL + "" + NL + "      DescCount++;" + NL + "    }while((DescStatus >= 0) && (DescCount < RECEIVE_DESC_SIZE));" + NL + "" + NL + "    DBG002_INFO(APP_GID, ETH_SETUP_RX_DESC, 0, NULL);" + NL + "" + NL + "\tif(NULL != SynopGMACPeriodicTimerCallback)" + NL + "\t{" + NL + "\t\tSynopGMACPeriodicTimerCallback(CABLE_STATUS_PERIOD, synopGMACdev);" + NL + "\t}" + NL + "    /* Clear all the interrupts */" + NL + "    synopGMAC_clear_interrupt(synopGMACdev);" + NL + "" + NL + "    /**" + NL + "     * Disable the interrupts generated by MMC and IPC counters." + NL + "     * If these are not disabled ISR should be modified accordingly to handle" + NL + "     * these interrupts." + NL + "     */" + NL + "    synopGMAC_disable_mmc_tx_interrupt(synopGMACdev, 0xFFFFFFFF);" + NL + "    synopGMAC_disable_mmc_rx_interrupt(synopGMACdev, 0xFFFFFFFF);" + NL + "    synopGMAC_disable_mmc_ipc_rx_interrupt(synopGMACdev, 0xFFFFFFFF);" + NL + "" + NL + "    /** Configure DMA Interrupts */" + NL + "    synopGMAC_enable_interrupt(synopGMACdev, DmaIntEnable);" + NL + "    synopGMAC_enable_dma_rx(synopGMACdev);" + NL + "    synopGMAC_enable_dma_tx(synopGMACdev);" + NL + "" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  }while (0);" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "status_t Eth_CloseNetworkInterface (void)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_4>>> */" + NL + "  status_t Status = ETH_CLOSE_ERROR;" + NL + "" + NL + "  /* Disable all the interrupts*/" + NL + "  synopGMAC_disable_interrupt_all(synopGMACdev);" + NL + "" + NL + "  DBG002_INFO(APP_GID, ETH_INTR_DISABLED, 0, NULL);" + NL + "" + NL + "  /* Disable the reception */" + NL + "  synopGMAC_disable_dma_rx(synopGMACdev);" + NL + "  synopGMAC_take_desc_ownership_rx(synopGMACdev);" + NL + "" + NL + "  DBG002_INFO(APP_GID, ETH_RX_DISABLED, 0, NULL);" + NL + "" + NL + "  /* Disable the transmission */" + NL + "  synopGMAC_disable_dma_tx(synopGMACdev);" + NL + "  synopGMAC_take_desc_ownership_tx(synopGMACdev);" + NL + "" + NL + "  DBG002_INFO(APP_GID, ETH_TX_DISABLED, 0, NULL);" + NL + "" + NL + "  /* Free the Rx Descriptor contents */" + NL + "  synopGMAC_giveup_rx_desc_queue(synopGMACdev, RINGMODE);" + NL + "" + NL + "  /* Free the Tx Descriptor contents */" + NL + "  synopGMAC_giveup_tx_desc_queue(synopGMACdev, RINGMODE);" + NL + "" + NL + "  /* Delete the Cable plug/unplug Timer*/" + NL + "  if(NULL != SynopGMACDeletePeriodicTimer)" + NL + "  {" + NL + "\tSynopGMACDeletePeriodicTimer();" + NL + "  }" + NL + "  if (Status != DAVEApp_SUCCESS)" + NL + "  {" + NL + "    DBG002_WARNING(APP_GID, ETH_CLOSE_ERROR, 0, NULL);" + NL + "  }" + NL + "  Status = DAVEApp_SUCCESS;" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "status_t Eth_TransmitFrames" + NL + "(" + NL + "  uint8_t *PacketBuffer," + NL + "  uint32_t PacketLength" + NL + ")" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_5>>> */" + NL + "  uint32_t Status = ETH_XMIT_ERROR;" + NL + "  uint32_t OffloadNeeded = 0;" + NL + "  int32_t DescStatus = -1;" + NL + "  /* extern uint8_t Eth_TxBuffer[2048]; */" + NL + "  " + NL + "  do" + NL + "  {" + NL + "\tif(NULL == PacketBuffer)" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID, ETH_NULL_PARAM, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "" + NL + "" + NL + "#ifdef IPC_OFFLOAD" + NL + "" + NL + "    /* Checksum offloading is required */" + NL + "    OffloadNeeded = 0x00000001;" + NL + "" + NL + "#endif" + NL + "" + NL + "    /*" + NL + "     * Now we have packet ready and stack invoked this function." + NL + "     * Lets make our DMA know about this" + NL + "     */" + NL + "    /*DescStatus = synopGMAC_set_tx_qptr(synopGMACdev, (uint32_t)PacketBuffer," + NL + "        PacketLength, (uint32_t)PacketBuffer,0,0,0, OffloadNeeded); */" + NL + "" + NL + "\tDescStatus = synopGMAC_set_tx_qptr(synopGMACdev, (uint32_t)PacketBuffer," + NL + "        PacketLength, (uint32_t)PacketBuffer,0,0,0, OffloadNeeded);" + NL + "" + NL + "    if(DescStatus < 0)" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID, ETH_TX_SETUP_ERROR, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "" + NL + "    /* Now force the DMA to start transmission*/" + NL + "    synopGMAC_resume_dma_tx(synopGMACdev);" + NL + "" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  } while (0);" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "#ifdef BUILD_UIP" + NL + "uint32_t Eth_ReceiveData(void *buf)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_6>>> */" + NL + "  int32_t DescIndex = 0;" + NL + "  uint32_t Data1 = 0 ;" + NL + "  uint32_t Data2 = 0;" + NL + "  uint32_t Length = 0;" + NL + "  uint32_t Status = ETH_RECV_ERROR;" + NL + "  uint32_t dma_addr1 = 0;" + NL + "  uint32_t dma_addr2 = 0;" + NL + "" + NL + "#ifdef ENH_DESC_8W" + NL + "  u32 ext_status;" + NL + "  u16 time_stamp_higher;" + NL + "  u32 time_stamp_high;" + NL + "  u32 time_stamp_low;" + NL + "#endif" + NL + "" + NL + "  /* Handle the Receive Descriptors*/" + NL + "  do */" + NL + "  {" + NL + "    DmaDesc *rxdesc = synopGMACdev->RxBusyDesc;" + NL + "" + NL + "    DescIndex = synopGMAC_get_rx_qptr(synopGMACdev," + NL + "    \t\t                          &Status," + NL + "    \t\t                          &dma_addr1," + NL + "    \t\t                          NULL," + NL + "    \t\t                          &Data1," + NL + "    \t\t                          &dma_addr2," + NL + "    \t\t                          NULL," + NL + "    \t\t                          &Data2);" + NL + "    if(DescIndex >= 0 && Data1 != 0)" + NL + "    {" + NL + "      //TR(\"Received Data at Rx Descriptor %d for skb 0x%08x whose Status is %08x\\n\",DescIndex,Data1,Status);" + NL + "" + NL + "      if(synopGMAC_is_rx_desc_valid(Status))" + NL + "      {" + NL + "    \t  /** Not interested in Ethernet CRC bytes */" + NL + "        Length =  synopGMAC_get_rx_desc_frame_length(Status) - 4;" + NL + "" + NL + "#ifdef IPC_OFFLOAD" + NL + "        /* Now lets check for the IPC offloading */" + NL + "        TR(\"Checksum Offloading will be done now\\n\");" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)" + NL + "        \t\t== RxNoChkError )" + NL + "        {" + NL + "          TR(\"Ip header and TCP/UDP payload checksum Bypassed <Chk Status = 4>\\n\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)" + NL + "        \t\t== RxIpHdrChkError )" + NL + "        {" + NL + "          TR(\"Error in 16bit IPV4 Header Checksum <Chk Status = 6>  \\n\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status) == RxLenLT600)" + NL + "        {" + NL + "          TR(\"IEEE 802.3 type frame with Length field Lesss than 0x0600 \\" + NL + "        \t\t  <Chk Status = 0>\\n\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)" + NL + "        \t\t== RxIpHdrPayLoadChkBypass )" + NL + "        {" + NL + "          TR(\"Ip header and TCP/UDP payload checksum Bypassed \\" + NL + "        \t\t  <Chk Status = 1>\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status) == RxChkBypass)" + NL + "        {" + NL + "          TR(\"Ip header and TCP/UDP payload checksum Bypassed \\" + NL + "        \t\t  <Chk Status = 3>\");" + NL + "        }" + NL + "" + NL + "        if(synopGMAC_is_rx_checksum_error(synopGMACdev, Status) ==" + NL + "        \t\tRxPayLoadChkError)" + NL + "        {" + NL + "          TR(\"TCP/UDP payload checksum Error <Chk Status = 5>\");" + NL + "        }" + NL + "" + NL + "        if(synopGMAC_is_rx_checksum_error(synopGMACdev, Status) ==" + NL + "        \t\tRxIpHdrChkError)" + NL + "        {" + NL + "          TR(\"Both IP header and Payload Checksum Error <Chk Status = 7>\");" + NL + "        }" + NL + "#endif /* IPC_OFFLOAD */" + NL + "" + NL + "        synopGMACdev->NetStatistics.RxPackets++;" + NL + "        synopGMACdev->NetStatistics.RxBytes += Length;" + NL + "" + NL + "        buf = rxdesc->buffer1;" + NL + "" + NL + "        /* Copy the packet to uIP buffer */" + NL + "        for(offset=0; rxdesc->length; offset++)       " + NL + "        {" + NL + "          (*(buf + offset)) = (*( uint8_t *)((rxdesc->Buffer1Addr) + offset));" + NL + "        }" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "    \t  synopGMACdev->NetStatistics.RxErrors++;" + NL + "        synopGMACdev->NetStatistics.Collisions     +=" + NL + "            synopGMAC_is_rx_frame_collision(Status);" + NL + "        synopGMACdev->NetStatistics.RxCrcErrors    +=" + NL + "            synopGMAC_is_rx_crc(Status);" + NL + "        synopGMACdev->NetStatistics.RxFrameErrors  +=" + NL + "            synopGMAC_is_frame_dribbling_errors(Status);" + NL + "        synopGMACdev->NetStatistics.RxLengthErrors +=" + NL + "            synopGMAC_is_rx_frame_length_errors(Status);" + NL + "      }" + NL + "" + NL + "      /* Return the descriptor back to DMA */" + NL + "      DescIndex = synopGMAC_set_rx_qptr(synopGMACdev," + NL + "    \t\t                            rxdesc->buffer1," + NL + "    \t\t                            ETH_PACKET_SIZE," + NL + "    \t\t                            rxdesc->buffer1," + NL + "    \t\t                            0,0,0);" + NL + "      if(DescIndex < 0)" + NL + "      {" + NL + "        TR(\"Cannot set Rx Descriptor\\n\");" + NL + "      }" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  }" + NL + "  /* while(DescIndex >= 0); */" + NL + "" + NL + "  /* Return the packet length */" + NL + "  return Length;" + NL + "}" + NL + "" + NL + "#else  /* BUILD_UIP */" + NL + "status_t Eth_ReceiveData(void)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_6>>> */" + NL + "  int32_t DescIndex = 0;" + NL + "  uint32_t Data1 = 0 ;" + NL + "  uint32_t Data2 = 0;" + NL + "  uint32_t Length = 0;" + NL + "  uint32_t Status = ETH_RECV_ERROR;" + NL + "  uint32_t dma_addr1 = 0;" + NL + "  uint32_t dma_addr2 = 0;" + NL + "  " + NL + "#ifdef ENH_DESC_8W" + NL + "  u32 ext_status;" + NL + "  u32 time_stamp_high;" + NL + "  u32 time_stamp_low;" + NL + "#endif" + NL + "" + NL + "  /* Handle the Receive Descriptors*/" + NL + "  do" + NL + "  {" + NL + "    DmaDesc *rxdesc = synopGMACdev->RxBusyDesc;" + NL + "" + NL + "    DescIndex = synopGMAC_get_rx_qptr(synopGMACdev," + NL + "    \t\t                          &Status," + NL + "    \t\t                          &dma_addr1," + NL + "    \t\t                          NULL," + NL + "    \t\t                          &Data1," + NL + "    \t\t                          &dma_addr2," + NL + "    \t\t                          NULL," + NL + "    \t\t                          &Data2,&ext_status,&time_stamp_high,&time_stamp_low);" + NL + "    if(DescIndex >= 0 && Data1 != 0)" + NL + "    {" + NL + "      //TR(\"Received Data at Rx Descriptor %d for skb 0x%08x whose Status is %08x\\n\",DescIndex,Data1,Status);" + NL + "" + NL + "      if(synopGMAC_is_rx_desc_valid(Status))" + NL + "      {" + NL;
  protected final String TEXT_71 = "    \t  /** Not interested in Ethernet CRC bytes */" + NL + "        Length =  synopGMAC_get_rx_desc_frame_length(Status) - 4;" + NL + "" + NL + "#ifdef IPC_OFFLOAD" + NL + "        /* Now lets check for the IPC offloading */" + NL + "        TR(\"Checksum Offloading will be done now\\n\");" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)" + NL + "        \t\t== RxNoChkError )" + NL + "        {" + NL + "          TR(\"Ip header and TCP/UDP payload checksum Bypassed <Chk Status = 4>\\n\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)" + NL + "        \t\t== RxIpHdrChkError )" + NL + "        {" + NL + "          TR(\"Error in 16bit IPV4 Header Checksum <Chk Status = 6>  \\n\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status) == RxLenLT600)" + NL + "        {" + NL + "          TR(\"IEEE 802.3 type frame with Length field Lesss than 0x0600 \\" + NL + "        \t\t  <Chk Status = 0>\\n\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)" + NL + "        \t\t== RxIpHdrPayLoadChkBypass )" + NL + "        {" + NL + "          TR(\"Ip header and TCP/UDP payload checksum Bypassed \\" + NL + "        \t\t  <Chk Status = 1>\");" + NL + "        }" + NL + "" + NL + "        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status) == RxChkBypass)" + NL + "        {" + NL + "          TR(\"Ip header and TCP/UDP payload checksum Bypassed \\" + NL + "        \t\t  <Chk Status = 3>\");" + NL + "        }" + NL + "" + NL + "        if(synopGMAC_is_rx_checksum_error(synopGMACdev, Status) ==" + NL + "        \t\tRxPayLoadChkError)" + NL + "        {" + NL + "          TR(\"TCP/UDP payload checksum Error <Chk Status = 5>\");" + NL + "        }" + NL + "" + NL + "        if(synopGMAC_is_rx_checksum_error(synopGMACdev, Status) ==" + NL + "        \t\tRxIpHdrChkError)" + NL + "        {" + NL + "          TR(\"Both IP header and Payload Checksum Error <Chk Status = 7>\");" + NL + "        }" + NL + "#endif /* IPC_OFFLOAD */" + NL + "" + NL + "        synopGMACdev->NetStatistics.RxPackets++;" + NL + "        synopGMACdev->NetStatistics.RxBytes += Length;" + NL + "" + NL + "        /* Send the packet buffer to Eth_Received_Data_Handler for processing */" + NL + "        Eth_Received_Data_Handler(rxdesc->buffer1, Length);" + NL + "" + NL + "\t\tif(synopGMAC_is_rx_desc_chained(rxdesc))" + NL + "\t\t{" + NL + "\t   \t\tsynopGMACdev->RxBusyDesc = (DmaDesc *)rxdesc->data2;" + NL + "\t\t\tsynopGMAC_rx_desc_init_chain(rxdesc);" + NL + "\t\t\t//synopGMAC_rx_desc_init_chain(rxdesc, synopGMAC_is_last_rx_desc(synopGMACdev,rxdesc),0,0);" + NL + "\t\t}" + NL + "\t\telse" + NL + "\t\t{" + NL + "\t\t\tsynopGMACdev->RxBusyDesc = synopGMAC_is_last_rx_desc(synopGMACdev,rxdesc) ? synopGMACdev->RxDesc : (rxdesc + 1);" + NL + "\t\t\tsynopGMAC_rx_desc_init_ring(rxdesc, synopGMAC_is_last_rx_desc(synopGMACdev,rxdesc));" + NL + "\t\t}" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "    \t  synopGMACdev->NetStatistics.RxErrors++;" + NL + "        synopGMACdev->NetStatistics.Collisions     +=" + NL + "            synopGMAC_is_rx_frame_collision(Status);" + NL + "        synopGMACdev->NetStatistics.RxCrcErrors    +=" + NL + "            synopGMAC_is_rx_crc(Status);" + NL + "        synopGMACdev->NetStatistics.RxFrameErrors  +=" + NL + "            synopGMAC_is_frame_dribbling_errors(Status);" + NL + "        synopGMACdev->NetStatistics.RxLengthErrors +=" + NL + "            synopGMAC_is_rx_frame_length_errors(Status);" + NL + "      }" + NL + "" + NL + "      /* Return the descriptor back to DMA */" + NL + "      DescIndex = synopGMAC_set_rx_qptr(synopGMACdev," + NL + "                                        (uint32_t)&Eth_RxBuffer[DescIndex * ETH_PACKET_SIZE]," + NL + "    \t\t                            ETH_PACKET_SIZE," + NL + "                                        (uint32_t)&Eth_RxBuffer[DescIndex * ETH_PACKET_SIZE]," + NL + "    \t\t                            0,0,0);" + NL + "      if(DescIndex < 0)" + NL + "      {" + NL + "        TR(\"Cannot set Rx Descriptor\\n\");" + NL + "      }" + NL + "    }" + NL + "    Status = DAVEApp_SUCCESS;" + NL + "  }while(DescIndex >= 0);" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "#endif  /* BUILD_UIP */" + NL + "" + NL + "void IRQ_Hdlr_";
  protected final String TEXT_72 = "(void)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_7>>> */" + NL + "  uint32_t interrupt, dma_status_reg;" + NL + "  uint32_t status;" + NL + "" + NL + "  /* Read the Dma interrupt status to know whether the interrupt got generated" + NL + "   * by our device or not" + NL + "   *  <<<DD_ETH_PORT_7_1>>>" + NL + "   */" + NL + "  dma_status_reg = synopGMACReadReg((uint32_t *)ETH_BASE, DmaStatus);" + NL + "" + NL + "  if(dma_status_reg == 0)" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, ETH_NO_INTERRUPT, 0, NULL);" + NL + "    return;" + NL + "  }" + NL + "" + NL + "  /* Disable all interrupts */" + NL + "  synopGMAC_disable_interrupt_all(synopGMACdev);" + NL + "" + NL + "  if(dma_status_reg & GmacPmtIntr)" + NL + "  {" + NL + "    TR(\"Interrupt due to PMT module\\n\");" + NL + "    synopGMAC_powerup_mac(synopGMACdev);" + NL + "  }" + NL + "" + NL + "  if(dma_status_reg & GmacMmcIntr)" + NL + "  {" + NL + "    TR(\"Interrupt due to MMC module\\n\");" + NL + " }" + NL + "" + NL + "  if(dma_status_reg & GmacLineIntfIntr)" + NL + "  {" + NL + "    TR(\"Interrupt due to GMAC LINE module\\n\");" + NL + "  }" + NL + "" + NL + "  /* Now lets handle the DMA interrupts*/" + NL + "  interrupt = synopGMAC_get_interrupt_type(synopGMACdev);" + NL + "" + NL + "  if(interrupt & synopGMACDmaError)" + NL + "  {" + NL + "    /* <<<DD_ETH_PORT_7_2>>> */" + NL + "    /* after soft reset, configure the MAC address to default value */" + NL + "    uint8_t mac_addr0[6] = DEFAULT_MAC_ADDRESS;" + NL + "" + NL + "    TR(\"Fatal Bus Error Interrupt Seen\\n\");" + NL + "" + NL + "    synopGMAC_disable_dma_tx(synopGMACdev);" + NL + "    synopGMAC_disable_dma_rx(synopGMACdev);" + NL + "" + NL + "    synopGMAC_take_desc_ownership_tx(synopGMACdev);" + NL + "    synopGMAC_take_desc_ownership_rx(synopGMACdev);" + NL + "" + NL + "    synopGMAC_init_tx_rx_desc_queue(synopGMACdev);" + NL + "" + NL + "    /* reset the DMA engine and the GMAC IP */" + NL + "    synopGMAC_reset(synopGMACdev);" + NL + "" + NL + "    synopGMAC_set_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low, mac_addr0);" + NL + "" + NL + "    synopGMAC_dma_bus_mode_init(synopGMACdev, DmaFixedBurstEnable|" + NL + "    \t\t                    DmaBurstLength8 | DmaDescriptorSkip2 );" + NL + "" + NL + "    synopGMAC_dma_control_init(synopGMACdev, DmaStoreAndForward);" + NL + "" + NL + "    synopGMAC_init_rx_desc_base(synopGMACdev);" + NL + "" + NL + "    synopGMAC_init_tx_desc_base(synopGMACdev);" + NL + "" + NL + "    synopGMAC_mac_init(synopGMACdev);" + NL + "" + NL + "    /* To enable Multicast */" + NL + "    synopGMAC_multicast_enable(synopGMACdev);" + NL + "" + NL + "    synopGMAC_multicast_hash_filter_enable(synopGMACdev);" + NL + "   /* To enable Broadcast */" + NL + "    synopGMAC_broadcast_enable(synopGMACdev);" + NL + "" + NL + "    synopGMAC_enable_dma_rx(synopGMACdev);" + NL + "" + NL + "    synopGMAC_enable_dma_tx(synopGMACdev);" + NL + "  }" + NL + "" + NL + "  if(interrupt & synopGMACDmaRxNormal)" + NL + "  {" + NL + "    TR(\"Rx Normal \\n\");" + NL + "" + NL + "    /* <<<DD_ETH_PORT_7_3>>>" + NL + "     * Send the packet to the TCP/IP stack." + NL + "     * This receive function retrieves packet from descriptor and delivers to" + NL + "     * the TCP/IP stack." + NL + "     */" + NL + "    Eth_ReceiveData();" + NL + "  }" + NL + "" + NL + "  if(interrupt & synopGMACDmaRxAbnormal)" + NL + "  {" + NL + "    TR(\"Abnormal Rx Interrupt Seen\\n\");" + NL + "" + NL + "    if(GMAC_Power_down == 0)" + NL + "    {" + NL + "      /* If Mac is not in powerdown */" + NL + "      synopGMACdev->NetStatistics.RxOverErrors++;" + NL + "" + NL + "      /* Now Descriptors have been created in synop_handle_received_data(). " + NL + "       * Just issue a poll demand to resume DMA operation" + NL + "       */" + NL + "      synopGMAC_resume_dma_rx(synopGMACdev);" + NL + "    }" + NL + "  }" + NL + "" + NL + "  if(interrupt & synopGMACDmaRxStopped)" + NL + "  {" + NL + "    /* <<<DD_ETH_PORT_7_4>>> */" + NL + "\t  uint32_t DescCount = 0;" + NL + "" + NL + "\t  /* Receiver gone in to stopped state */" + NL + "    TR(\"Receiver stopped seeing Rx interrupts\\n\");" + NL + "" + NL + "    if(GMAC_Power_down == 0)" + NL + "    {" + NL + "      /* If Mac is not in powerdown */" + NL + "      synopGMACdev->NetStatistics.RxOverErrors++;" + NL + "      do" + NL + "      {" + NL + "          /* Set Rx Q Pointer */" + NL + "          status = synopGMAC_set_rx_qptr(synopGMACdev," + NL + "        \t\t                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE]," + NL + "              \t\t             ETH_PACKET_SIZE," + NL + "              \t\t             (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE]," + NL + "              \t\t             0,0,0);" + NL + "" + NL + "          //TR(\"Set Rx Descriptor no %08x \\n\",status);" + NL + "" + NL + "          DescCount++;" + NL + "      }while(status >= 0 && (DescCount < TRANSMIT_DESC_SIZE));" + NL + "" + NL + "      synopGMAC_enable_dma_rx(synopGMACdev);" + NL + "    }" + NL + "  }" + NL + "" + NL + "  if(interrupt & synopGMACDmaTxNormal)" + NL + "  {" + NL + "    //xmit function has done its job" + NL + "    TR(\"Finished Normal Transmission \\n\");" + NL + "" + NL + "    /* Call function to update statistics. */" + NL + "    synop_handle_transmit_over(synopGMACdev);" + NL + "  }" + NL + "" + NL + "  if(interrupt & synopGMACDmaTxAbnormal)" + NL + "  {" + NL + "    TR(\"Abnormal Tx Interrupt Seen\\n\");" + NL + "" + NL + "    if(GMAC_Power_down == 0)" + NL + "    {" + NL + "      /* If Mac is not in powerdown */" + NL + "      synop_handle_transmit_over(synopGMACdev);" + NL + "    }" + NL + "  }" + NL + "" + NL + "  if(interrupt & synopGMACDmaTxStopped)" + NL + "  {" + NL + "    /* <<<DD_ETH_PORT_7_5>>> */" + NL + "    TR(\"Transmitter stopped sending the packets\\n\");" + NL + "" + NL + "    if(GMAC_Power_down == 0)" + NL + "    {" + NL + "      /* If Mac is not in powerdown */" + NL + "      synopGMAC_disable_dma_tx(synopGMACdev);" + NL + "" + NL + "      synopGMAC_take_desc_ownership_tx(synopGMACdev);" + NL + "" + NL + "      synopGMAC_enable_dma_tx(synopGMACdev);" + NL + "" + NL + "      TR(\"Transmission Resumed\\n\");" + NL + "    }" + NL + "  }" + NL + "" + NL + "  /* Enable the Interrupts before returning from ISR */" + NL + "  synopGMAC_enable_interrupt(synopGMACdev, DmaIntEnable);" + NL + "" + NL + "  return;" + NL + "}" + NL + "" + NL + "status_t Eth_PerformIoctl(uint32_t Cmd, Eth_IoctlParamType *Eth_IoctlParam)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_8_1>>> */" + NL + "  uint32_t Status = ETH_IOCTL_ERROR;" + NL + "" + NL + "  do" + NL + "  {" + NL + "    if(NULL == Eth_IoctlParam)" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID, ETH_NULL_PARAM, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "" + NL + "    /* Check the command and take action */" + NL + "    switch(Cmd)" + NL + "    {" + NL + "      case IOCTL_READ_REGISTER:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_2>>> */" + NL + "        /** IOCTL for reading IP registers : Read Registers */" + NL + "        if (Eth_IoctlParam->Unit== 0)" + NL + "        {" + NL + "          /* Read Mac Register */" + NL + "          Eth_IoctlParam->Data = synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "                                                  Eth_IoctlParam->Address);" + NL + "        }" + NL + "        else if (Eth_IoctlParam->Unit == 1)" + NL + "        {" + NL + "          /* Read DMA Register */" + NL + "          Eth_IoctlParam->Data = synopGMACReadReg((uint32_t *)ETH_BASE," + NL + "                                                  Eth_IoctlParam->Address);" + NL + "        }" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "" + NL + "      case IOCTL_WRITE_REGISTER:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_3>>> */" + NL + "        /** IOCTL for writing registers : Write Registers */" + NL + "        if (Eth_IoctlParam->Unit == 0)" + NL + "        {" + NL + "          /* Write Mac Register */" + NL + "          synopGMACWriteReg((uint32_t *)ETH0_BASE,Eth_IoctlParam->Address," + NL + "              Eth_IoctlParam->Data);" + NL + "        }" + NL + "        else if (Eth_IoctlParam->Unit == 1)" + NL + "        {" + NL + "          /* Write DMA Register */" + NL + "          synopGMACWriteReg((uint32_t *)ETH_BASE, Eth_IoctlParam->Address," + NL + "              Eth_IoctlParam->Data);" + NL + "        }" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "" + NL + "      case IOCTL_READ_IPSTRUCT:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_4>>> */" + NL + "        /** IOCTL for reading ETH0 DEVICE IP private structure */" + NL + "        if (Eth_IoctlParam->Unit == 0)" + NL + "        {" + NL + "          memcpy((synopGMACdevice *)Eth_IoctlParam->Address," + NL + "                        synopGMACdev," + NL + "                        sizeof(synopGMACdevice));" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          TR(\"IOCTL_READ_IPSTRUCT failed\");" + NL + "        }" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_READ_RXDESC:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_5>>> */" + NL + "        /** IOCTL for Reading Rx DMA DESCRIPTOR */ " + NL + "        memcpy((DmaDesc *)Eth_IoctlParam->Address," + NL + "\t\t\t\t        synopGMACdev->RxDesc," + NL + "               sizeof(DmaDesc));" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_READ_TXDESC:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_6>>> */" + NL + "        /** IOCTL for Reading Tx DMA DESCRIPTOR */" + NL + "        memcpy((DmaDesc *)Eth_IoctlParam->Address," + NL + "                synopGMACdev->TxDesc," + NL + "                sizeof(DmaDesc));" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_READ_RMON_COUNTERS:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_7>>> */" + NL + "        Eth_StructRMONCountersType *RMONCounters =" + NL + "            (Eth_StructRMONCountersType *) Eth_IoctlParam->Address;" + NL + "" + NL + "        Eth_lGetRMONCounters(RMONCounters);" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_CHANGE_MTU:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_8>>> */" + NL + "        /** IOCTL for changing the MTU size */" + NL + "        if (Eth_IoctlParam->Data > MAX_MTU_SIZE)" + NL + "        {" + NL + "          DBG002_ERROR(APP_GID, ETH_IOCTL_ERROR, sizeof(\"Invalid MTU size\"), \"Invalid MTU size\");" + NL + "          break;" + NL + "        }" + NL + "        synopGMAC_change_mtu(synopGMACdev, Eth_IoctlParam->Data);" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_SET_MAC_ADDRESS:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_9>>> */" + NL + "        /** IOCTL to set MAC Address */" + NL + "        synopGMAC_set_mac_address(synopGMACdev, (void *)Eth_IoctlParam->Address);" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_GET_MAC_ADDRESS:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_10>>> */" + NL + "        /** IOCTL to get Eth MAC Address */" + NL + "        memcpy((uint8_t *)Eth_IoctlParam->Address," + NL + "            synopGMACdev->MacAddress, MAC_ADDR_LEN);" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      case IOCTL_GET_NET_STATS:" + NL + "      {" + NL + "        /* <<<DD_ETH_PORT_8_11>>> */" + NL + "        /** IOCTL to get network statistics */" + NL + "        memcpy((void *)Eth_IoctlParam->Address, &(synopGMACdev->NetStatistics)," + NL + "            sizeof(Eth_NetStatisticsType));" + NL + "        Status  = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "      }" + NL + "      default:" + NL + "      {" + NL + "        DBG002_ERROR(APP_GID, ETH_IOCTL_ERROR, sizeof(\"INVALID option\")," + NL + "            \"INVALID option\");" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "  }while(0);" + NL + "" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "static void Eth_lGetRMONCounters(Eth_StructRMONCountersType *RMONCounters)" + NL + "{" + NL + "  /* <<<DD_ETH_PORT_14>>> */" + NL + "  RMONCounters->TXOCtetCountGB = synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "      TXFRAMECOUNTGB_OFFSET);" + NL + "" + NL + "  RMONCounters->TxFrameCountGB = synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "      TXFRAMECOUNTGB_OFFSET);" + NL + "" + NL + "  RMONCounters->TxBroadcastFramesG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXBROADCASTFRAMESG_OFFSET);" + NL + "" + NL + "  RMONCounters->TxMulticastFramesG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXMULTICASTFRAMESG_OFFSET);" + NL + "" + NL + "  RMONCounters->Tx64OctetsGB = synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "      TX64OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Tx65To127OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TX65TO127OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Tx128To255OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TX128TO255OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Tx256To511OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TX256TO511OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Tx512To1023ctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TX512TO1023CTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Tx1024ToMaxOctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TX1024TOMAXOCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->TxUnicastFramesGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXUNICASTFRAMESGB_OFFSET);" + NL + "" + NL + "  RMONCounters->TxMulticastFramesGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXMULTICASTFRAMESGB_OFFSET);" + NL + "" + NL + "  RMONCounters->TxBroadcastFramesGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXBROADCASTFRAMESGB_OFFSET);" + NL + "" + NL + "  RMONCounters->UnderFlowError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          UNDERFLOWERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->SingleCollisionG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL;
  protected final String TEXT_73 = "          SINGLECOLLISIONG_OFFSET);" + NL + "" + NL + "  RMONCounters->MultiCollisionG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          MULTICOLLISIONG_OFFSET);" + NL + "" + NL + "  RMONCounters->TxDeferred =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXDEFERRED_OFFSET);" + NL + "" + NL + "  RMONCounters->TxLateCollision =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXLATECOLLISION_OFFSET);" + NL + "" + NL + "  RMONCounters->ExcessCollision =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          EXCESSCOLLISION_OFFSET);" + NL + "" + NL + "  RMONCounters->TxCarrierError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXCARRIERERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->TxOctetCount =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXOCTETCOUNT_OFFSET);" + NL + "" + NL + "  RMONCounters->TxFrameCount =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXFRAMECOUNT_OFFSET);" + NL + "" + NL + "  RMONCounters->TxExcessDef =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXEXCESSDEF_OFFSET);" + NL + "" + NL + "  RMONCounters->TxPauseFrames =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXPAUSEFRAMES_OFFSET);" + NL + "" + NL + "  RMONCounters->TxVLANFrames =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          TXVLANFRAMES_OFFSET);" + NL + "" + NL + "  RMONCounters->RxFrameCountGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXFRAMECOUNTGB_OFFSET);" + NL + "" + NL + "  RMONCounters->RxOctetCountGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXOCTETCOUNTGB_OFFSET);" + NL + "" + NL + "  RMONCounters->RxOctetCountG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXOCTETCOUNTG_OFFSET);" + NL + "" + NL + "  RMONCounters->RxBroadcastFramesG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXBROADCASTFRAMESG_OFFSET);" + NL + "" + NL + "  RMONCounters->RxMulticastFramesG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXMULTICASTFRAMESG_OFFSET);" + NL + "" + NL + "  RMONCounters->RxCRCError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXCRCERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->RxAlignmentError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXALIGNMENTERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->RxRuntError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXRUNTERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->RxJabberError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXJABBERERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->RxUndersizeG =" + NL + "            synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "            RXUNDERSIZEG_OFFSET);" + NL + "" + NL + "  RMONCounters->RxOverSizeG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXOVERSIZEG_OFFSET);" + NL + "" + NL + "  RMONCounters->Rx64OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RX64OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Rx65To127OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RX65TO127OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Rx127To255OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RX127TO255OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Rx256To511OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RX256TO511OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Rx512To1023OctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RX512TO1023OCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->Rx1023ToMaxOctetsGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RX1023TOMAXOCTETSGB_OFFSET);" + NL + "" + NL + "  RMONCounters->RxUnicastFramesG =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXUNICASTFRAMESG_OFFSET);" + NL + "" + NL + "  RMONCounters->RxLengthError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXLENGTHERROR_OFFSET);" + NL + "" + NL + "  RMONCounters->RxOutofRangeType =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXOUTOFRANGETYPE_OFFSET);" + NL + "" + NL + "  RMONCounters->RxPauseFrames =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXPAUSEFRAMES_OFFSET);" + NL + "" + NL + "  RMONCounters->RxFifoOverflow =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXFIFOOVERFLOW_OFFSET);" + NL + "" + NL + "  RMONCounters->RxVLANFrameGB =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXVLANFRAMEGB_OFFSET);" + NL + "" + NL + "  RMONCounters->RxWatchDOGError =" + NL + "      synopGMACReadReg((uint32_t *)ETH0_BASE," + NL + "          RXWATCHDOGERROR_OFFSET);" + NL + "}" + NL + "" + NL + "void synopGMAC_RegisterPeriodicTimerCallback(SynopGMACPeriodicTimerCallbackType Callback)" + NL + "{" + NL + "\tSynopGMACPeriodicTimerCallback = Callback;" + NL + "}" + NL + "" + NL + "void synopGMAC_RegisterDeleteTimerCallback(SynopGMACDeletePeriodicTimerType Callback)" + NL + "{" + NL + "\tSynopGMACDeletePeriodicTimer = Callback;" + NL + "}" + NL + "" + NL + "void synopGMAC_periodic_check()" + NL + "{" + NL + "\tsynopGMAC_cable_unplug_function(synopGMACdev);" + NL + "}" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "/*CODE_BLOCK_END*/" + NL + NL;
  protected final String TEXT_74 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri1 = "app/eth001/0";
    stringBuffer.append(TEXT_2);
    stringBuffer.append(app.getAppVersion(AppBaseuri1) );
    stringBuffer.append(TEXT_3);
     String AppBaseuri2 = "app/eth001/";
     int appInst  = 0; 
     String NodeID = null; 
     String MappedUri = null;
     MappedUri = app.getMappedUri(AppBaseuri2 + appInst + "/nvic_node");
     if((MappedUri != null) && (MappedUri != "")) { 
  NodeID = MappedUri.substring(MappedUri.lastIndexOf('/')+ 1 );}
int intrPriority = app.getIntegerValue(AppBaseuri2 + appInst +"/eth001_interrupt_priority");
int intrSubPriority = app.getIntegerValue(AppBaseuri2 + appInst +"/eth001_interrupt_subpriority");

    stringBuffer.append(TEXT_4);
     int Is44Device = -1; 
     Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); 
    stringBuffer.append(TEXT_5);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_6);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_7);
     } 
    stringBuffer.append(TEXT_8);
    if (Is44Device==1){
    stringBuffer.append(TEXT_9);
    }
    stringBuffer.append(TEXT_10);
     String AppBaseuri = "app/eth001/0";
    stringBuffer.append(TEXT_11);
     String txd1_pinUri = app.getMappedUri(AppBaseuri + "/txd1_pin"); 
     String P = txd1_pinUri.substring(0, txd1_pinUri.indexOf("/p/")+3); 
     String txd1_portNo = txd1_pinUri.substring(P.length(), txd1_pinUri.indexOf("/pad/")); 
     String txd1_pinNo = txd1_pinUri.substring(txd1_pinUri.indexOf("/pad/")+5, txd1_pinUri.length()); 
    stringBuffer.append(TEXT_12);
    int txd1_port = Integer.parseInt(txd1_portNo);
    int txd1_pin = Integer.parseInt(txd1_pinNo);
    stringBuffer.append(TEXT_13);
     String txd0_pinUri = app.getMappedUri(AppBaseuri + "/txd0_pin"); 
     String txd0_portNo = txd0_pinUri.substring(P.length(), txd0_pinUri.indexOf("/pad/")); 
     String txd0_pinNo = txd0_pinUri.substring(txd0_pinUri.indexOf("/pad/")+5, txd0_pinUri.length()); 
    int txd0_port = Integer.parseInt(txd0_portNo);
    int txd0_pin = Integer.parseInt(txd0_pinNo);
     String txden_pinUri = app.getMappedUri(AppBaseuri + "/tx_en_pin"); 
     String txden_portNo = txden_pinUri.substring(P.length(), txden_pinUri.indexOf("/pad/")); 
     String txden_pinNo = txden_pinUri.substring(txden_pinUri.indexOf("/pad/")+5, txden_pinUri.length()); 
    int txen_port = Integer.parseInt(txden_portNo);
    int txen_pin = Integer.parseInt(txden_pinNo);
    stringBuffer.append(TEXT_14);
     int txd0_pdr = app.getIntegerValue(AppBaseuri + "/txd0_pin/pdr_pd");
   int txd1_pdr = app.getIntegerValue(AppBaseuri + "/txd1_pin/pdr_pd");
   int txen_pdr = app.getIntegerValue(AppBaseuri + "/tx_en_pin/pdr_pd");

    stringBuffer.append(TEXT_15);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(txd0_pin);
    stringBuffer.append(TEXT_17);
     if(txd0_pin < 8) {
    stringBuffer.append(TEXT_18);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_19);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_20);
    stringBuffer.append(txd0_pin);
    stringBuffer.append(TEXT_21);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_22);
    stringBuffer.append(txd0_pin);
    stringBuffer.append(TEXT_23);
    stringBuffer.append(txd0_pdr);
    stringBuffer.append(TEXT_24);
     } else {
    stringBuffer.append(TEXT_25);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_26);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_27);
    stringBuffer.append(txd0_pin);
    stringBuffer.append(TEXT_28);
    stringBuffer.append(txd0_port);
    stringBuffer.append(TEXT_29);
    stringBuffer.append(txd0_pin);
    stringBuffer.append(TEXT_30);
    stringBuffer.append(txd0_pdr);
    stringBuffer.append(TEXT_31);
    } 
    stringBuffer.append(TEXT_32);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_33);
    stringBuffer.append(txd1_pin);
    stringBuffer.append(TEXT_34);
     if(txd1_pin < 8) {
    stringBuffer.append(TEXT_35);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_36);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_37);
    stringBuffer.append(txd1_pin);
    stringBuffer.append(TEXT_38);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_39);
    stringBuffer.append(txd1_pin);
    stringBuffer.append(TEXT_40);
    stringBuffer.append(txd1_pdr);
    stringBuffer.append(TEXT_41);
     } else {
    stringBuffer.append(TEXT_42);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_43);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_44);
    stringBuffer.append(txd1_pin);
    stringBuffer.append(TEXT_45);
    stringBuffer.append(txd1_port);
    stringBuffer.append(TEXT_46);
    stringBuffer.append(txd1_pin);
    stringBuffer.append(TEXT_47);
    stringBuffer.append(txd1_pdr);
    stringBuffer.append(TEXT_48);
    } 
    stringBuffer.append(TEXT_49);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_50);
    stringBuffer.append(txen_pin);
    stringBuffer.append(TEXT_51);
     if(txen_pin < 8) {
    stringBuffer.append(TEXT_52);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_53);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_54);
    stringBuffer.append(txen_pin);
    stringBuffer.append(TEXT_55);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_56);
    stringBuffer.append(txen_pin);
    stringBuffer.append(TEXT_57);
    stringBuffer.append(txen_pdr);
    stringBuffer.append(TEXT_58);
     } else {
    stringBuffer.append(TEXT_59);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_60);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_61);
    stringBuffer.append(txen_pin);
    stringBuffer.append(TEXT_62);
    stringBuffer.append(txen_port);
    stringBuffer.append(TEXT_63);
    stringBuffer.append(txen_pin);
    stringBuffer.append(TEXT_64);
    stringBuffer.append(txen_pdr);
    stringBuffer.append(TEXT_65);
    } 
    stringBuffer.append(TEXT_66);
    stringBuffer.append(NodeID);
    stringBuffer.append(TEXT_67);
    stringBuffer.append(intrPriority);
    stringBuffer.append(TEXT_68);
    stringBuffer.append(intrSubPriority);
    stringBuffer.append(TEXT_69);
    stringBuffer.append(NodeID);
    stringBuffer.append(TEXT_70);
    stringBuffer.append(TEXT_71);
    stringBuffer.append(NodeID);
    stringBuffer.append(TEXT_72);
    stringBuffer.append(TEXT_73);
    stringBuffer.append(TEXT_74);
    return stringBuffer.toString();
  }
}
