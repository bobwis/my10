package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class sdmmc003_privateh_template
{
  protected static String nl;
  public static synchronized sdmmc003_privateh_template create(String lineSeparator)
  {
    nl = lineSeparator;
    sdmmc003_privateh_template result = new sdmmc003_privateh_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[SDMMC003_Private.h]*/" + NL + "" + NL + "/******************************************************************************" + NL + " *" + NL + " * Copyright (C) 2011 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with " + NL + " * Infineon's microcontrollers." + NL + " * This file can be freely distributed within development " + NL + " * tools that are supporting such microcontrollers. " + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR" + NL + " * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/Yes]: Yes                                      **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Oct 1, 2012                                         **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/";
  protected final String TEXT_2 = NL + NL + NL + NL + "#ifndef SDMMC003_PRIVATE_H_" + NL + "#define SDMMC003_PRIVATE_H_" + NL + "" + NL + "" + NL + "/**" + NL + " * @file SDMMC003_Private.h" + NL + " *" + NL + " * @App Version SDMMC003 <";
  protected final String TEXT_3 = ">" + NL + " *" + NL + " * @brief  This file contains all the private functions prototypes and type " + NL + " * declarations in Non-Rtos Environment." + NL + " *" + NL + " * Revision History" + NL + " * 22 March 2012  v1.0.0    Initial version" + NL + " * 3 Aug 2012     v1.0.12   Erase optimizations introduced." + NL + " *                          Make File System(MKFS) through software issue fixed. " + NL + " * 1 Oct 2012     v1.0.14   Delays reduced." + NL + " *                          Removed RTOS specific code. " + NL + " */" + NL + "" + NL + "" + NL + "#include <DAVE3.h>" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "" + NL + "/**" + NL + " * @ingroup SDMMC003_privateparam" + NL + " * @{" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                       Macro Definitions                                    **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/** All Normal Interrupt Status Enable & Error Int Status Enable bit fields" + NL + " * except Auto Cmd Error,Block Gap Event, DMA Int, Card Interrupt, ADMA Error," + NL + " *  Vendor specific" + NL + " */" + NL + "#define SDMMC003_NORMAL_INT_STATUS_ENABLE                     (0x00F3U)" + NL + "#define SDMMC003_ERROR_INT_STATUS_ENABLE                      (0xE0FFU)" + NL + "" + NL + "#define SDMMC003_NORMAL_INT_STATUS_BITS            (0x7fffU)" + NL + "/* Command line Interrupt errors status bitmask    */" + NL + "#define SDMMC003_ERROR_CMD_STATUS_BITMASK                     (0x000FU)" + NL + "/* Data line Error status  bitmask      */" + NL + "#define SDMMC003_ERROR_DATA_STATUS_BITMASK                    (0x0070U)" + NL + "" + NL + "/*All Data lines High Status Value in Present State Register */" + NL + "#define SDMMC003_ALL_DATA_LINES_HIGH                      (0xFU)" + NL + "/* Error Interrupt Status Bitmask         */" + NL + "#define SDMMC003_ALL_ERROR_STATUS_BITMASK                 (0xFFFFU)" + NL + "" + NL + "" + NL + "/* All Normal Interrupt Signal Enable & Error Int Signal Enable bit fields" + NL + " * except Block Gap Event, DMA Int, Card Interrupt, ADMA Error, Vendor specific" + NL + " */" + NL + "/* Enable this macro if card detection feature available */" + NL + "#if SDMMC_CARD_DETECTION_SUPPORT" + NL + "#define SDMMC003_NORMAL_INT_SIGNAL_ENABLE                     (0x00F3U)" + NL + "#else" + NL + "#define SDMMC003_NORMAL_INT_SIGNAL_ENABLE                     (0x0033U)" + NL + "#endif" + NL + "#define SDMMC003_ERROR_INT_SIGNAL_ENABLE                      (0xE0FFU)" + NL + "" + NL + "" + NL + "" + NL + "/* SDCLK frequency Select value in ClockControl Register */" + NL + "#define SDMMC003_CTRL_SDCLK_FREQ_SEL_VALUE                   (0x1U)" + NL + "" + NL + "/* Data Timeout counter value in Timeout Control Register */" + NL + "#define SDMMC003_CTRL_DAT_TIMEOUT_CNT_VAL_VALUE               (0xeU)" + NL + "" + NL + "/* SD Bus Voltage value in Power Control Register */" + NL + "#define SDMMC003_CTRL_SD_BUS_VOLTAGE_SEL_VALUE                (0x07U)" + NL + "" + NL + "" + NL + "/* Switch function bitmask */" + NL + "#define SDMMC003_SWITCH_FUNC_GRP1_STATUS_BITMASK           (0x0000000FU)" + NL + "#define SDMMC003_SWITCH_FUNC_GRP1_STATUS_BITPOS            (0x0U)" + NL + "" + NL + "/* Transfer Block Register */" + NL + "#define SDMMC003_TX_BLOCK_SIZE_VALUE                       (0x0200U)" + NL + "" + NL + "/* Card's OCR register  */" + NL + "#define SDMMC003_OCR_POWER_STATUS_BITMASK                  (0x80000000U)" + NL + "#define SDMMC003_OCR_CCS_BITMASK                           (0x40000000U)" + NL + "#define SDMMC003_MMC_OCR_ACCESS_MODE_BITMASK               (0x60000000U)" + NL + "#define SDMMC003_MMC_OCR_ACCESS_MODE_BITPOS                (0x1DU)" + NL + "" + NL + "/* Response Register */" + NL + "#define SDMMC003_HC_RESPONSE1_BITPOS                       (0x10U)" + NL + "" + NL + "/*  SD Card's CMD8 response R7 bit positions */" + NL + "#define SDMMC003_SD_CMD8_CHECK_PATTERN_VALUE               (0xAAU)" + NL + "#define SDMMC003_SD_CMD8_CHECK_PATTERN_BITMASK             (0xFFU)" + NL + "#define SDMMC003_SD_CMD8_CHECK_PATTERN_BITPOS              (0x00U)" + NL + "#define SDMMC003_SD_CMD8_VHS_BITPOS                        (0x8U)" + NL + "#define SDMMC003_SD_CMD8_VHS_BITMASK                       (0xFU)" + NL + "#define SDMMC003_SD_VHS_PATTERN_2_7_3_6_VALUE              (0x1U)" + NL + "" + NL + "/* RCA Register */" + NL + "#define SDMMC003_MMC_DEFAULT_RCA                           (0x0001U)" + NL + "#define SDMMC003_ARG_RCA_BITPOS                            (0x10U)" + NL + "" + NL + "/* SD Status */" + NL + "#define SDMMC003_SD_CARD_TYPE_BITMASK                      (0xFFFFU)" + NL + "" + NL + "/* SCR Register Bitmask */" + NL + "#define SDMMC003_SCR_BUS_WIDTH4_BITMASK                    (0x4U)" + NL + "" + NL + "/* Start of Card Status Register i.e CSR Error Bits Bitmask */" + NL + "#define SDMMC003_CSR_OUT_OF_RANGE_BITMASK                  (0x80000000U)" + NL + "#define SDMMC003_CSR_ADDRESS_ERROR_BITMASK                 (0x40000000U)" + NL + "#define SDMMC003_CSR_BLOCK_LEN_ERROR_BITMASK               (0x20000000U)" + NL + "#define SDMMC003_CSR_ERASE_SEQ_ERROR_BITMASK               (0x10000000U)" + NL + "#define SDMMC003_CSR_ERASE_PARAM_BITMASK                   (0x08000000U)" + NL + "#define SDMMC003_CSR_WP_VIOLATION_BITMASK                  (0x04000000U)" + NL + "#define SDMMC003_CSR_LOCK_UNLOCK_FAILED_BITMASK            (0x01000000U)" + NL + "#define SDMMC003_CSR_COM_CRC_ERROR_BITMASK                 (0x00800000U)" + NL + "#define SDMMC003_CSR_ILLEGAL_COMMAND_BITMASK               (0x00400000U)" + NL + "#define SDMMC003_CSR_CARD_ECC_FAILED_BITMASK               (0x00200000U)" + NL + "#define SDMMC003_CSR_CC_ERROR_BITMASK                      (0x00100000U)" + NL + "#define SDMMC003_CSR_ERROR_BITMASK                         (0x00080000U)" + NL + "#define SDMMC003_CSR_CSD_OVERWRITE_BITMASK                 (0x00010000U)" + NL + "#define SDMMC003_CSR_WP_ERASE_SKIP_BITMASK                 (0x00008000U)" + NL + "#define SDMMC003_SWITCH_ERROR_BITMASK                      (0x00000080U)" + NL + "#define SDMMC003_CSR_ASK_SEQ_ERROR_BITMASK                 (0x00000008U)" + NL + "#define SDMMC003_CSR_CARD_IS_LOCKED_BITMASK                (0x02000000U)" + NL + "#define SDMMC003_CSR_CURRENT_STATE_BITMASK                 (0x00001D00U)" + NL + "#define SDMMC003_CSR_CURRENT_STATE_BITPOS                  (0x9U)" + NL + "#define SDMMC003_CSR_CURRENT_STATE_TRANS_VALUE             (0x4U)" + NL + "#define SDMMC003_CSR_CARD_IS_LOCKED_BITMASK                (0x02000000U)" + NL + "/* End of Card Status Register i.e CSR Error Bits */" + NL + "" + NL + "" + NL + "/* Some Command's static Arguments */" + NL + "#define SDMMC003_ARGUMENT0                                 (0x00000000U)" + NL + "#define SDMMC003_SD_CMD8_ARG                               (0x000001AAU)" + NL + "#define SDMMC003_SD_ACMD41_F80_ARG                         (0x00100000U)" + NL + "#define SDMMC003_SD_ACMD41_F81_ARG                         (0x40100000U)" + NL + "#define SDMMC003_MMC_CMD1_ARG                              (0x40FF8000U)" + NL + "#define SDMMC003_MMC_4BUS_WIDTH_ARG                        (0x03B70100U)" + NL + "#define SDMMC003_SD_4BUS_WIDTH_ARG                         (0x00000002U)" + NL + "#define SDMMC003_MMC_HIGH_SPEED_ARG                        (0x03B90100U)" + NL + "#define SDMMC003_SD_HIGH_SPEED_ARG                         (0x80000001U)" + NL + "" + NL + "/**" + NL + " * Delay Macros" + NL + " */" + NL + "#define SDMMC003_CARD_POWER_DELAY                                \t 20" + NL + "#define SDMMC003_DELAY_IN_TRANSFER                                1000" + NL + "#define SDMMC003_RESET_In_DATA_TRANSFER                           1000" + NL + "#define SDMMC003_DELAY_IN_COMMAND                                 1000" + NL + "#define SDMMC003_RESET_DELAY                                      500" + NL + "#define SDMMC003_CLOCK_STABLE_DELAY                               1000" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "/* This macro is is used to  enable the signal bits in" + NL + " * Normal Signal Enable register*/" + NL + "#define SDMMC003_ENABLE_INT_SIGNAL(Mask)\\" + NL + "{ \\" + NL + "  (SDMMC->EN_INT_SIGNAL &= ~Mask ); \\" + NL + "  (SDMMC->EN_INT_SIGNAL |= Mask ); \\" + NL + "}" + NL + "/* This macro is is used to  disable the signal bits in" + NL + " * Normal Signal Enable register*/" + NL + "#define SDMMC003_DISABLE_INT_SIGNAL(Mask)  (SDMMC->EN_INT_SIGNAL &= ~Mask)" + NL + "" + NL + "/* Number of Reset retries during card initialization */" + NL + "#define SDMMC003_NUM_CARD_RESET_RETRIES     2" + NL + "/* Block Size in bytes */" + NL + "#define SDMMC003_BLOCK_SIZE                 512UL" + NL + "/* Block size in Quad bytes.  */" + NL + "#define SDMMC003_NUM_QUADLETS_IN_BLOCK      SDMMC003_BLOCK_SIZE >> 2" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                STRUCTURES                                  **" + NL + " ******************************************************************************/" + NL + "/**" + NL + " * @brief This structure stores the command register fields." + NL + " */" + NL + "typedef struct SDMMC003_CommandType" + NL + "{" + NL + "  /**" + NL + "   * This variable determine Response types" + NL + "   *  00 No Response" + NL + "   *  01 Response Length 136" + NL + "   *  10 Response Length 48" + NL + "   *  11 Response Length 48,  check Busy after response" + NL + "   */" + NL + "   uint16_t ResponseTypeSelect : 2;" + NL + "" + NL + "  /**" + NL + "   * Reserved bits" + NL + "   */" + NL + "   uint16_t  Rsvd1 : 1;" + NL + "" + NL + "  /**" + NL + "   * If this variable stores value 1, the Host Controller shall check the CRC" + NL + "   * field in the response. If an error is detected, it is reported as a" + NL + "   * Command CRC Error.If this bit is set to 0, the CRC field is not checked" + NL + "   */" + NL + "  uint16_t CrcCheckEnable : 1;" + NL + "  /**" + NL + "   * If this variable stores value 1, the Host Controller shall check the Index" + NL + "   * field in the response to see if it has the same value as the command index." + NL + "   * If it is not, it is reported as a Command Index Error. If this bit is set" + NL + "   * to 0,the Index field is not checked." + NL + "   */" + NL + "  uint16_t IndexCheckEnable : 1 ;" + NL + "  /**" + NL + "   * This variable stores the value 0 or  1 to indicate that data is present and" + NL + "   * shall be transferred using the DAT line or not" + NL + "   */" + NL + "  uint16_t DataPresentSelect : 1 ;" + NL + "  /**" + NL + "   * There are three types of special commands: Suspend, Resume and Abort. 11b Abort" + NL + "   * 10b Resume 01b Suspend 00b Normal" + NL + "   */" + NL + "  uint16_t CommandType : 2;" + NL + "  /**" + NL + "   * These variable shall be set to the command number (CMD0-63, ACMD0-63) which" + NL + "   * describes the command to be issued" + NL + "   */" + NL + "  uint16_t CommandIndex : 6 ;" + NL + "  /**" + NL + "   * Reserved" + NL + "   */" + NL + "  uint16_t  Rsvd2 : 2;" + NL + "} SDMMC003_CommandType;" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the card's register content information." + NL + " */" + NL + "typedef struct SDMMC003_CardInfoType" + NL + "{" + NL + "  /**" + NL + "   * This variable stores Card's  OCR register contents" + NL + "   */" + NL + "  uint32_t Ocr;" + NL + "  /**" + NL + "   * This structure variable stores Card's CID Register contents" + NL + "   */" + NL + "  uint32_t CidArray[4];" + NL + "  /**" + NL + "   * This structure variable stores Card's CSD register contents" + NL + "   */" + NL + "  uint32_t CsdArray[4];" + NL + "  /**" + NL + "   * This  variable stores Card's SCR register contents" + NL + "   */" + NL + "  SDMMC003_SCRType Scr;" + NL + "  /**" + NL + "   * This  variable stores Card's Relative address" + NL + "   */" + NL + "  uint16_t Rca;" + NL + "} SDMMC003_CardInfoType;" + NL + "" + NL + "/**" + NL + " * @brief This structure stores the Interrupt Context Information." + NL + " */" + NL + "typedef struct SDMMC003_InterruptContext" + NL + "{" + NL + "  /** InterruptStatusShadow stores the  Interrupt status register status bits*/" + NL + "  uint16_t InterruptStatusShadow;" + NL + "  /** CmdFlag is set when any command related interrupt occurs.*/" + NL + "  uint8_t CmdFlag;" + NL + "  /** DataFlag is set when any data transfer error interrupt occurs.  */" + NL + "  uint8_t DataFlag;" + NL + "  /** TransferFlag is set when Transfer complete interrupt occurs . */" + NL + "  uint8_t TransferFlag;" + NL + "} SDMMC003_InterruptContext;" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                ENUMERATIONS                                **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @brief This enumerates the Response Types." + NL + " */" + NL + "typedef enum SDMMC003_ResponseType" + NL + "{" + NL + "  /**" + NL + "   * No Response" + NL + "   */" + NL + "  SDMMC003_NO_RESPONSE," + NL + "  /**" + NL + "   * Response Type R1" + NL + "   */" + NL + "  SDMMC003_RESPONSE_R1," + NL + "  /**" + NL + "   * Response Type R1b" + NL + "   */" + NL + "  SDMMC003_RESPONSE_R1b," + NL + "  /**" + NL + "   * Response Type 2" + NL + "   */" + NL + "  SDMMC003_RESPONSE_R2," + NL + "  /**" + NL + "   * Response Type 3" + NL + "   */" + NL + "  SDMMC003_RESPONSE_R3," + NL + "  /**" + NL + "   * Response Type 6" + NL + "   */" + NL + "  SDMMC003_RESPONSE_R6," + NL + "  /**" + NL + "   * Response Type R7" + NL + "   */" + NL + "  SDMMC003_RESPONSE_R7" + NL + "} SDMMC003_ResponseType;" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * @ingroup SDMMC003_privatefunc" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @brief This function will Set the bit in Software Reset register to reset the" + NL + " * Host Controller Registers." + NL + " * @param[in]  Reset Bitmask of the field to be set in the SW Reset Register" + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If reset fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lReset(uint8_t Reset);" + NL + "" + NL + "/**" + NL + " * @brief This function sends the command to the SD/MMC card." + NL + " * @param[in] CommandPtr Command to issue." + NL + " * @param[in] Argument  Argument to the command" + NL + " * @param[in] ResponseType Type of the response expected." + NL + " * @param[out] ResponsePtr Pointer to store response received." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If send command fails.<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lSendCommand" + NL + "(" + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  uint32_t Argument," + NL + "  SDMMC003_ResponseType ResponseType," + NL + "  void *ResponsePtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function  reads the response as per the response type." + NL + " * @param[in]  CommandPtr Command whose response to read." + NL + " * @param[in]  ResponseType Type of the response expected." + NL + " * @param[out] ResponsePtr Pointer to store response received." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t  SDMMC003_lReadResponse" + NL + "( " + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  SDMMC003_ResponseType ResponseType," + NL + "  void *ResponsePtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function checks for the errors in the response." + NL + " * @param[in]  CardStatusPtr Status to check errors in." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t  SDMMC003_lCheckErrorInResponse( const uint32_t  *CardStatusPtr );" + NL + "" + NL + "/**" + NL + " * @brief This function will initialize the SD card." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lInitializeCard(void);" + NL + "" + NL + "#if SDMMC003_MMC_CARD" + NL;
  protected final String TEXT_4 = "/**" + NL + " * @brief This function will initialize the MMC card." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lInitializeMmcCard(void);" + NL + "#endif /* SDMMC003_MMC_CARD */" + NL + "" + NL + "/**" + NL + " * @brief This function configures the registers for Single Block Transfer." + NL + " * @param[in] CommandPtr Single Transfer Command" + NL + " * @param[in] Argument Argument to the command" + NL + " * @param[in] BlockSize Block Size in Bytes." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lConfigureForSingleTransfer" + NL + "(" + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  uint32_t Argument," + NL + "  uint16_t BlockSize" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function configures the registers for Multi Block Transfer." + NL + " * @param[in] TmpAddrPtr Address to be set in the Argument resgister" + NL + " * @param[in] NumberOfBlocks Number of Blocks." + NL + " * @param[in] CommandPtr Multi Block Transfer Command" + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lConfigureRegForMultiTransfer" + NL + "(" + NL + "  uint32_t *TmpAddrPtr," + NL + "  uint32_t NumberOfBlocks," + NL + "  const SDMMC003_CommandType *CommandPtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function queries the voltage operating condition from the card." + NL + " * i.e Send CMD8 and checks the response" + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lQueryOperatingCond(void);" + NL + "" + NL + "/**" + NL + " * @brief This function queries the card's voltage window" + NL + " * i.e Send ACMD41 and checks the response" + NL + " * @param[in] Argument Rca in the Argument." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lQueryVoltage(uint32_t Argument);" + NL + "" + NL + "/**" + NL + " * @brief This function identifies the card type information and update it" + NL + " * accordingly in the  Handle structure ." + NL + " * @return <b>void</b><BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lWriteCardType(void);" + NL + "" + NL + "/**" + NL + " * @brief This function reads the card registers like  CSD, SCR and write" + NL + " * protection info. " + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails.<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lReadCardRegisters(void);" + NL + "" + NL + "/**" + NL + " * @brief This function checks for Argument related errors like Out of Range," + NL + " * Address Error, Block length error, Write Protection" + NL + " * @param[in] CardStatusPtr Status in which error to Check" + NL + " * @param[in] ErrorPtr Flag to set to 1, if any error detected." + NL + " * @return <b>void</b><BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lCheckArgumentError" + NL + "(" + NL + "  const uint32_t  *CardStatusPtr," + NL + "  uint8_t *ErrorPtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function checks for Erase related errors like Erase Sequence," + NL + " * Erase Skip error, Erase Param error" + NL + " * @param[in] CardStatusPtr Status in which error to Check" + NL + " * @param[in] ErrorPtr Flag to set to 1, if any error detected." + NL + " * @return <b>void</b><BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lCheckEraseError" + NL + "(" + NL + "  const uint32_t *CardStatusPtr," + NL + "  uint8_t *ErrorPtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function checks response error types in card's internal" + NL + " *  error category" + NL + " * @param[in] CardStatusPtr Status in which error to Check" + NL + " * @param[in] ErrorPtr Flag to set to 1, if any error detected." + NL + " * @return <b>void</b><BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lCheckCardError" + NL + "(" + NL + "  const uint32_t *CardStatusPtr," + NL + "  uint8_t *ErrorPtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function sets the voltage window in OCR register." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails. <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t  SDMMC003_lSetVoltageWindow(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function reads the  Relative card address of the card." + NL + " * @return <b>status_t</b><BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails <BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lReadRca(void);" + NL + "" + NL + "/**" + NL + " * @brief This function finds out the Write protection status of the card." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails <BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lSetWriteProtect(void);" + NL + "" + NL + "/**" + NL + " * @brief This function checks whether the CMD and DATA lines are free before" + NL + " *  issuing any command." + NL + " * @param[in] CommandPtr Command for which CMD and DATA  lines needs to check." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails <BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lCheckDatCmdline ( const SDMMC003_CommandType *CommandPtr);" + NL + "" + NL + "/**" + NL + " * @brief This function clears the card related structures and stops the SD clock." + NL + " * @return void <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lCardCleanUp(void);" + NL + "" + NL + "/**" + NL + " * @brief This function switches the bus width to 4-bit if is supported." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lSwitchBusWidth(void);" + NL + "" + NL + "/**" + NL + " * @brief This function is use to switch the card state to transferring state" + NL + " * if the card is not in the transferring state." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No</b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lSwitchToTransferState(void);" + NL + "" + NL + "/**" + NL + " * @brief This function switches the card speed to high speed if is supported." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t  SDMMC003_lSwitchSpeed(void);" + NL + "" + NL + "/**" + NL + " * @brief This function reads the card registers after the card is initialized." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: if the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lAfterCardInitialize(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function checks the Lock Status." + NL + " * @param[in] OperationMode Lock or Unlock Status to verify" + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lCheckLockStatus(SDMMC003_CardLockMode OperationMode);" + NL + "" + NL + "/**" + NL + " * @brief This function handles the Interrupt in Normal Interrupt Status" + NL + " * Register." + NL + " * @param[in] IntStatus Interrupt Status in the Status register" + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lNormalInterruptHandler(uint16_t IntStatus);" + NL + "/**" + NL + " * @brief This function handles the Interrupt in Error Interrupt Status Register." + NL + " * @param[in] IntStatus Interrupt Status in the Normal Interrupt Status register" + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lErrorInterruptHandler(uint16_t IntStatus);" + NL + "" + NL + "/**" + NL + " * @brief This function performs the recovery task if any error interrupt occurs." + NL + " * @param[in] InterruptStatus Interrupt Status in the Error Interrupt Status register" + NL + " * @return status_t<BR>" + NL + " * SDMMC003_RECOVERABLE_ERROR: If the error is recoverable <BR>" + NL + " * SDMMC003_NONRECOVERABLE_ERROR: Non recoverable error <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lErrorInterruptRecovery(uint16_t InterruptStatus, uint8_t IssueAbort);" + NL + "" + NL + "/**" + NL + " * @brief This function performs the data transfer to/from the card ." + NL + " * @param[in] BufferPtr Buffer to read into or write data from." + NL + " * @param[in] TransferMode Direction of data transfer." + NL + " * @param[in] QuadBytes Number of Quad bytes." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lDataTransfer" + NL + "(" + NL + "  uint32_t *BufferPtr,\\" + NL + "  SDMMC003_DataTrasferType TransferMode, \\" + NL + "  uint32_t QuadBytes" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function performs the ACMD 12 error Recovery." + NL + " * @return void<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "" + NL + "void SDMMC003_lAcmdErrorRecovery(void);" + NL + "" + NL + "/**" + NL + " * @brief This function performs the  Multiple Block Transfer." + NL + " * @param[in] AddrPtr Card Address from where to read or write data into" + NL + " * @param[in] NumberOfBlocks Number of blocks to transfer" + NL + " * @param[in] CommandPtr Multi Block Transfer Command." + NL + " * @param[in] BufferPtr Buffer to read into or write data from." + NL + " * @param[in] TransferMode Transfer direction ." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lMultiBlockTransfer" + NL + "(" + NL + "  uint32_t *AddrPtr,\\" + NL + "  uint32_t NumberOfBlocks,\\" + NL + "  const SDMMC003_CommandType *CommandPtr, \\" + NL + "  uint32_t *BufferPtr,SDMMC003_DataTrasferType TransferMode " + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function performs the  Single Block Transfer." + NL + " * @param[in] CommandPtr Single Block Transfer Command." + NL + " * @param[in] Argument Card Address from where to read or write data into" + NL + " * @param[in] BlockSize Number of bytes to transfer" + NL + " * @param[in] BufferPtr Buffer to read into or write data from." + NL + " * @param[in] TransferMode Transfer direction ." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lSingleBlockTransfer" + NL + "(" + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  uint32_t Argument," + NL + "  uint16_t BlockSize," + NL + "  uint32_t *BufferPtr," + NL + "  SDMMC003_DataTrasferType TransferMode" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function is used to put some delay wherever required ." + NL + " * @param[in] DelayTime Delay Time in Mili seconds." + NL + " * @return void" + NL + " */" + NL + "void SDMMC003_lDelay(uint32_t DelayTime);" + NL + "/**" + NL + " * @brief This function is SDMMC Interrupt Handler function." + NL + " * @return void" + NL + " */" + NL + "void SDMMC0_0_IRQHandler(void);" + NL + "/**" + NL + " * @brief This function is SDMMC Interrupt Handler function." + NL + " * @return status_t<BR>" + NL + " * osOK: correct execution: operation completed<BR>" + NL + " * osEventSignal:signal event occured<BR>" + NL + " * osEventMessage: message event occured<BR>" + NL + " * osEventMail: mail event occured<BR>" + NL + " * osEventTimeout: timeout occured<BR>" + NL + " * osErrorParameter:parameter error: A mandantory parameter was missing, out of range, or specified an incorrect object.<BR>" + NL + " * osErrorResource: resource not available: a specified resource was not available.<BR>" + NL + " * osErrorTimeoutResource: resource not available within given time: a specified resource was not available within the timeout period.<BR>" + NL + " * osErrorIRQ: not allowed in IRQ context: the function cannot be called from interrrupt service routines.<BR>" + NL + " * osErrorNoMemory: system is out of memory: it was impossible to allocate or reserve memory for the operation.<BR> " + NL + " */" + NL + "status_t SDMMC003_lCreateOSResources(void);" + NL + "" + NL + "/**" + NL + " * @brief  This function performs the card initialization and identification operation." + NL + " * @return  status_t <BR>" + NL + " * DAVEApp_SUCCESS: If card initialization and identification  is success.<BR>" + NL + " * SDMMC003_ERROR: If error occurs.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lCardIdentificationProcess(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief  This function stops and delete the timer in NON-RTOS environment." + NL + " * @return  void <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lStopTimer(handle_t TimerId);" + NL + "/**" + NL + " * @brief  This function creates and starts the timer for the DelayTime time in " + NL + " * miliseconds in NON-RTOS environment." + NL + " * @param[in] DelayTime Timer time period in miliseconds." + NL + " * @return  handle_t <BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "handle_t SDMMC003_lStartTimer(uint32_t DelayTime);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function is used to check the sector address is out of bound or not." + NL + " * @param[in] SectorNumberParam Sector Number." + NL;
  protected final String TEXT_5 = " * @param[in] SectorCountParam Sector Count." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS: If the function is successful<BR>" + NL + " * SDMMC003_SECTOR_OUT_OF_BOUND: If Sector number is out of bound.<BR>" + NL + " * SDMMC003_ERROR: If function fails<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lCheckSectorBound(uint32_t SectorNumberParam, \\" + NL + "                                             uint32_t SectorCountParam);" + NL + "" + NL + "/**" + NL + " * @brief This is the local function which does the actual erase operation on the card." + NL + " * @param[in] StartAddr Start Erase Sector Address " + NL + " * @param[in] EndAddr Erase Sector Address." + NL + " * @param[in] TimeoutVal Erase Timeout Value for AU chunk in one Erase Operation." + NL + " * @return status_t<BR>" + NL + " * DAVEApp_SUCCESS:  If erase is successful.<BR>" + NL + " * SDMMC003_ERROR: If erase fails.<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lLocalErase" + NL + "(" + NL + "  uint32_t StartAddr," + NL + "  uint32_t EndAddr," + NL + "  uint32_t TimeoutVal" + NL + ");" + NL + "/**" + NL + " * @brief This is the local function which updates the handle with the lock/unlock state of the card" + NL + " * @param[in] CardStatus 32-bit Card Status response recieved." + NL + " * @param[in] CommandIndex Command Index." + NL + " * @return void<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_lGetCardLockState(uint32_t CardStatus, uint16_t CommandIndex);" + NL + "" + NL + "/**" + NL + " * @brief This is the local function to introduce the delay in data transfer." + NL + " * @param[in] DelayTime Delay Time in miliseconds." + NL + " * @return void<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lTransferDelay(uint32_t DelayTime);" + NL + "" + NL + "/**" + NL + " * @brief This is the local function to introduce the delay in command transfer." + NL + " * @param[in] DelayTime Delay Time in miliseconds." + NL + " * @return void<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "status_t SDMMC003_lCommandDelay(uint32_t DelayTime);" + NL + "" + NL + "/**" + NL + " * @brief This function checks the PCMD flag." + NL + " * @param[in] PCMDFlag of ACMD register." + NL + " * @return void<BR>" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void SDMMC003_CheckPCMDFlag(status_t PCMDFlag);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function is the call back function for System timer to be used in" + NL + " * the Non-RTOS enviroment." + NL + " * @param[in] Temp Argument pointer." + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " */" + NL + "void Timer_CallBack(void* Temp);" + NL + "" + NL + "#endif /* SDMMC003_PRIVATE_H_ */" + NL + "" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*CODE_BLOCK_END*/" + NL + NL + NL + NL;
  protected final String TEXT_6 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/sdmmc003/"; 
     int appInst = 0; 
     int RTOS = app.getIntegerValue(AppBaseuri + appInst + "/sdmmc003_rtos_present");
   String  Module_Name = "SDMMC003";

    stringBuffer.append(TEXT_2);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_3);
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    return stringBuffer.toString();
  }
}
