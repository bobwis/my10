package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class sdmmc003c_template
{
  protected static String nl;
  public static synchronized sdmmc003c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    sdmmc003c_template result = new sdmmc003c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/* CODE_BLOCK_BEGIN[SDMMC003.c]*/" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Oct 1, 2012                                         **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/";
  protected final String TEXT_2 = NL + NL + "/**" + NL + " * @file   SDMMC003.c" + NL + " *" + NL + " * @App Version SDMMC003 <";
  protected final String TEXT_3 = ">" + NL + " *" + NL + " * @brief  This file contains of all public function definations of SDMMC LLD App." + NL + " *" + NL + " * Revision History" + NL + " * 22 March 2012  v1.0.0    Initial version" + NL + " * 3 Aug 2012     v1.0.12   Erase optimizations introduced." + NL + " *                          Make File System(MKFS) through software issue fixed. " + NL + " * 1 Oct 2012     v1.0.14   Delays reduced." + NL + " *                          Removed RTOS specific code. " + NL + " */" + NL + "" + NL + "" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " *                            INCLUDE FILES                                   **" + NL + " ******************************************************************************/" + NL + "" + NL + "#include \"../../inc/SDMMC003/SDMMC003_Conf.h\"" + NL + "#include <DAVE3.h>" + NL + "#include \"../../inc/SDMMC003/SDMMC003_Private.h\"" + NL + "" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "#if SDMMC_UVP_TEST" + NL + "extern Test_TriggerInterruptType Test_TriggerInterrupt;" + NL + "#endif" + NL + "" + NL + "/** Handle Structure containing all the run-time card information  */" + NL + "volatile SDMMC003_HandleType SDMMC003_Handle = {0};" + NL + "" + NL + "extern SDMMC003_CardInfoType SDMMC003_CardInfo ;" + NL + " " + NL + "extern const SDMMC003_CommandType SDMMC003_Command[40];" + NL + "extern const uint8_t  SDMMC003_SDHashTable[65];" + NL + "" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "extern const uint8_t SDMMC003_MMCHashTable[64] ;" + NL + "#endif /* SDMMC_SUPPORT_MMC_CARD */" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*<<<DD_SDMMC_API_1>>> */" + NL + "/*" + NL + " * The function initializes the Host Controller with the reset values and" + NL + " * configure values in the Host Controller registers." + NL + " */" + NL + "status_t SDMMC003_HostControllerInit(void)" + NL + "{" + NL + "  status_t Status = (uint32_t) DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "/*<<<DD_SDMMC_API_1_1>>> */" + NL + "    /* Check Host Controller is initialized or not */" + NL + "    if ((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) != 0)" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_HOST_CONTROLLER_INITIALIZED;" + NL + "      break;" + NL + "    }" + NL + "    /* 1. Reset the registers to default values in Software Reset Control" + NL + "     * Register" + NL + "     */" + NL + "/*<<<DD_SDMMC_API_1_2>>> */" + NL + "    Status  = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_ALL_Msk );" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Set Clock Control  register */" + NL + "    SDMMC->CLOCK_CTRL |= ((SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL_Msk & \\" + NL + "                          (SDMMC003_CTRL_SDCLK_FREQ_SEL_VALUE << \\" + NL + "                          SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL_Pos)) | \\" + NL + "                          (SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_EN_Msk) \\" + NL + "    );" + NL + "    /* Set Normal Interrupt Status Enable & Error Interrupt Status Enable register */" + NL + "    SDMMC->EN_INT_STATUS_NORM = SDMMC003_NORMAL_INT_STATUS_ENABLE;" + NL + "    SDMMC->EN_INT_STATUS_ERR = SDMMC003_ERROR_INT_STATUS_ENABLE ;" + NL + "" + NL + "    /* Set Interrupt Signal Enable & Error Interrupt Signal Enable register*/" + NL + "    SDMMC->EN_INT_SIGNAL_NORM = SDMMC003_NORMAL_INT_SIGNAL_ENABLE;" + NL + "    SDMMC->EN_INT_SIGNAL_ERR = SDMMC003_ERROR_INT_SIGNAL_ENABLE;" + NL + "" + NL + "    /* Set Timeout Control Register */" + NL + "    SDMMC->TIMEOUT_CTRL |= ( SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL_Msk &\\" + NL + "                                 ( SDMMC003_CTRL_DAT_TIMEOUT_CNT_VAL_VALUE << \\" + NL + "                                    SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL_Pos )\\" + NL + "                                 );" + NL + "   /* Set bus voltage in the Power Control Register */" + NL + "    SDMMC->POWER_CTRL |= ( SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL_Msk &\\" + NL + "                           (SDMMC003_CTRL_SD_BUS_VOLTAGE_SEL_VALUE  << \\" + NL + "                            SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL_Pos )" + NL + "                          );" + NL + "    /* Update the state status to card initialized  */" + NL + "    SDMMC003_Handle.State |= (SDMMC003_STATE_HC_INITIALIZED | SDMMC003_STATE_NO_CARD) ;" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_2 >>> */" + NL + "/*" + NL + " * The function de-initialize the Host Controller to the reset values." + NL + " */" + NL + "status_t  SDMMC003_HostControllerDeInit(void)" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_SDMMC_API_2_1>>> */" + NL + "    /* Check the host controller is initialized or not */" + NL + "    if((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) == 0)" + NL + "    {" + NL + "      break;" + NL + "    }/*End of\"if((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED)== 0)\"*/" + NL + "    /* Cleanup the card. */" + NL + "    SDMMC003_lCardCleanUp();" + NL + "    /* Reset the Host Controller registers */" + NL + "/* <<<DD_SDMMC_API_2_2>>> */" + NL + "    Status = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_ALL_Msk );" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_3>>> */" + NL + "/*" + NL + " * The function is used to read multiple blocks of data from the card." + NL + " */" + NL + "status_t SDMMC003_CardReadMultipleBlocks" + NL + "(" + NL + "  uint32_t  *ReadBufPtr," + NL + "  uint32_t  ReadAddr," + NL + "  uint32_t  NumberOfBlocks" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_READ_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;" + NL + "    SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;" + NL + "/* <<<DD_SDMMC_API_3_1>>> */    " + NL + "    /*Check Whether Initialization Process is successful */" + NL + "    if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_INIT_FAIL;     " + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_API_3_2>>> */" + NL + "    /* Check Sector number is not out of bound */" + NL + "    Status = SDMMC003_lCheckSectorBound(ReadAddr,NumberOfBlocks);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Set transfer direction select in the Transfer Mode Register */" + NL + "    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "/* <<<DD_SDMMC_API_3_3>>> */" + NL + "    /* Send Multiple Block  Read Command i.e CMD18 */" + NL + "    Status = SDMMC003_lMultiBlockTransfer( &ReadAddr, \\" + NL + "                                           NumberOfBlocks, \\" + NL + "                                           &(SDMMC003_COMMON_COMMAND(18)), \\" + NL + "                                           ReadBufPtr, \\" + NL + "                                           SDMMC003_READ_FROM_BUFF);" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_4>>> */" + NL + "/*" + NL + " * The function is used to read single block of data from the card." + NL + " */" + NL + "status_t SDMMC003_CardReadSingleBlock" + NL + "(" + NL + "  uint32_t *ReadBufPtr," + NL + "  uint32_t  ReadAddr" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_READ_ERROR;" + NL + "  uint32_t SectorCount = 1UL;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_SDMMC_API_4_1>>> */" + NL + "    /*Check Whether Initialization Process is successful */" + NL + "    if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_API_4_2>>> */" + NL + "    /* Check Sector number is not out of bound */" + NL + "    Status = SDMMC003_lCheckSectorBound(ReadAddr,SectorCount);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_API_4_3>>> */" + NL + "    /* Block Addressing or Byte Addressing */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)" + NL + "    {" + NL + "      ReadAddr *= 512UL;" + NL + "    } /*End of \"if((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING)== 0UL)\"*/" + NL + "    /* Set Direction select in transfer mode register */" + NL + "    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "    /* Perform the Single block transfer operation */" + NL + "/* <<<DD_SDMMC_API_4_4>>> */" + NL + "    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_COMMON_COMMAND(17)), \\" + NL + "                                            ReadAddr, \\" + NL + "                                            SDMMC003_BLOCK_SIZE, \\" + NL + "                                            ReadBufPtr, \\" + NL + "                                            SDMMC003_READ_FROM_BUFF  );" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_5>>> */" + NL + "/*" + NL + " * The function is used to write multiple blocks of data on the card." + NL + " */" + NL + "status_t SDMMC003_CardWriteMultipleBlocks" + NL + "(" + NL + "  const uint32_t *WriteBufPtr," + NL + "  uint32_t WriteAddr," + NL + "  uint32_t NumberOfBlocks" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_WRITE_ERROR; " + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;" + NL + "    SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;" + NL + "/* <<<DD_SDMMC_API_5_1>>> */    " + NL + "    /*Check Whether Initialization Process is successfull */" + NL + "    if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_API_5_2>>> */       " + NL + "    /* Check Sector number is not out of bound */" + NL + "    Status = SDMMC003_lCheckSectorBound(WriteAddr,NumberOfBlocks);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* Clear transfer direction select in Transfer Mode Register */" + NL + "    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "" + NL + "/* Send Multiple Block  Write  Command i.e CMD25 */" + NL + "/* <<<DD_SDMMC_API_5_3>>> */" + NL + "    Status = SDMMC003_lMultiBlockTransfer( &WriteAddr, \\" + NL + "                                           NumberOfBlocks,\\" + NL + "                                           &(SDMMC003_COMMON_COMMAND(25)),\\" + NL + "                                           (uint32_t *)WriteBufPtr,\\" + NL + "                                           SDMMC003_WRITE_INTO_BUFF);" + NL + "    } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_6>>> */" + NL + "/*" + NL + " * The function is used to write single block of data on the card." + NL + " */" + NL + "status_t SDMMC003_CardWriteSingleBlock" + NL + "(" + NL + "  const uint32_t *WriteBufPtr," + NL + "  uint32_t WriteAddr" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_WRITE_ERROR;" + NL + "  uint32_t SectorCount = 1UL;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_SDMMC_API_6_1>>> */    " + NL + "    /*Check Whether Initialization Process is successful */" + NL + "    if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_API_6_2>>> */    " + NL + "    /* Check Sector number is not out of bound */" + NL + "    Status = SDMMC003_lCheckSectorBound(WriteAddr,SectorCount);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* If not Block Addressing then multiply by 512 bytes. */" + NL + "/* <<<DD_SDMMC_API_6_3>>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)" + NL + "    {" + NL + "      WriteAddr *= 512UL;" + NL + "    } /*End of \"if((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)\"*/" + NL + "    /* Clear Transfer Direction Select bit in Transfer Mode Register */" + NL + "    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "    /* Single Block Transfer function */" + NL + "/* <<<DD_SDMMC_API_6_4>>> */" + NL + "    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_COMMON_COMMAND(24)), \\" + NL + "                                            WriteAddr, \\" + NL + "                                            SDMMC003_BLOCK_SIZE, \\" + NL + "                                            (uint32_t *)WriteBufPtr, \\" + NL + "                                            SDMMC003_WRITE_INTO_BUFF);" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_7>>> */" + NL + "/*" + NL + " * The function is used to erase data from the card." + NL + " */" + NL + "status_t SDMMC003_EraseBlock" + NL + "(" + NL + "  uint32_t StartAddr," + NL + "  uint32_t EndAddr" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  uint32_t NumOfSectors = 0;" + NL + " /* Alocation Unit to No. of Sectors in 1 AU table mapping*/" + NL + "  uint32_t AuToSectors[10] = { 0,   32,  64,  128,  256," + NL + "                               512, 1024, 2048, 4096, 8192" + NL + "                             };" + NL + "  uint16_t EraseSize = 0;" + NL + "  uint8_t EraseOffset = 0;" + NL + "  uint8_t EraseTimeout = 0;" + NL + "  uint8_t AUSize = 0;" + NL + "  uint32_t SectorsInAu = 0;" + NL + "  uint32_t SectorsInEraseCluster = 0;" + NL + "  /* Read SD Status  */" + NL + "  uint32_t SdStatus[16] = {0};" + NL + "  uint32_t EraseTimeoutPerCluster = 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;" + NL + "  SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;" + NL + "  SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_SDMMC_API_7_1>>> */" + NL + "    /*Check Whether Initialization Process is successful */" + NL + "    if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "      break;" + NL + "    }" + NL + "    NumOfSectors = EndAddr - StartAddr;" + NL + "/* <<<DD_SDMMC_API_7_2>>> */    " + NL + "    /* Check Sector number is not out of bound */" + NL + "    Status = SDMMC003_lCheckSectorBound(StartAddr,NumOfSectors);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* Erase Timeout Calculation */" + NL + "/* Get SD Status */" + NL + "    Status  = SDMMC003_GetSdStatus((void*)&(SdStatus[0]));" + NL + "/* <<<DD_SDMMC_API_7_3>>> */" + NL + "    if (Status != DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Bits 400-401 in SD status is Erase Offset */" + NL;
  protected final String TEXT_4 = "    EraseOffset =  ((SdStatus[3] & 0x00000300)) >> 8;" + NL + "    /* Bits 402-407 in SD status is Erase Timeout */" + NL + "    EraseTimeout = ((SdStatus[3] & 0x0000FC00)) >> 10;" + NL + "    /* Bits 408-423 in SD status is Erase Size */" + NL + "    EraseSize = ( (((SdStatus[2] & 0xFF000000) >> 24) << 8) | \\" + NL + "                   (SdStatus[3] & 0x000000FF) );" + NL + "    /* Bits 428-431 in SD status is Allocation unit Size*/              " + NL + "    AUSize  =    (( SdStatus[2] & 0x00F00000) >> 20);" + NL + "    /* Erase Timeout Calculations */" + NL + "    EraseTimeoutPerCluster = (EraseTimeout/EraseSize) +  EraseOffset  ;" + NL + "    /* Number of Sectors in 1AU */" + NL + "    SectorsInAu = AuToSectors[AUSize];" + NL + "    SectorsInEraseCluster = SectorsInAu * EraseSize;" + NL + "#if SDMMC_UVP_TEST" + NL + "  if (Test_TriggerInterrupt.Trigger_TC23_1Error == TRUE)" + NL + "  {" + NL + "    Test_TriggerInterrupt.Trigger_EraseStartError = TRUE;" + NL + "  }" + NL + "  if (Test_TriggerInterrupt.Trigger_TC23_1Error == TRUE)" + NL + "  {" + NL + "    Test_TriggerInterrupt.Trigger_EraseEndError = TRUE;" + NL + "  }" + NL + "#endif" + NL + "    while (NumOfSectors > SectorsInEraseCluster)" + NL + "    {" + NL + "      Status = SDMMC003_lLocalErase(StartAddr,(StartAddr + SectorsInEraseCluster), \\" + NL + "                                    EraseTimeoutPerCluster);" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      StartAddr  = StartAddr + SectorsInEraseCluster;" + NL + "      NumOfSectors = NumOfSectors - SectorsInEraseCluster;" + NL + "    }" + NL + "    if (NumOfSectors != 0 )" + NL + "    {" + NL + "      Status = SDMMC003_lLocalErase(StartAddr,EndAddr,EraseTimeoutPerCluster);" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_8 >>> */" + NL + "/*" + NL + " * The function is used to perform the security operations on the card i.e Set," + NL + " * clear password, lock/unlock card" + NL + " */" + NL + "status_t  SDMMC003_LockUnlockCard" + NL + "(" + NL + "  SDMMC003_LocalLockStructType  *LockPtr," + NL + "  SDMMC003_CardLockMode OperationMode" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /*  Select the Card before proceeding */" + NL + "    Status = SDMMC003_lSwitchToTransferState();" + NL + "/* <<< DD_SDMMC_API_8_1 >>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }/* End of \"if(Status != DAVEApp_SUCCESS)\" */" + NL + "/*  Send Cmd42 and write the Lock data structure */" + NL + "/*  Set Transfer Mode Register */" + NL + "    CLR_BIT( SDMMC->TRANSFER_MODE, SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_COMMON_COMMAND(42)),\\" + NL + "                                            SDMMC003_ARGUMENT0, 512, \\" + NL + "                                            (uint32_t *)LockPtr,\\" + NL + "                                            SDMMC003_WRITE_INTO_BUFF);" + NL + "/* <<< DD_SDMMC_API_8_2 >>> */" + NL + "    if(Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      Status = SDMMC003_lCheckLockStatus(OperationMode);" + NL + "    }/* End of \"if(Status == DAVEApp_SUCCESS)\" */" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_9 >>> */" + NL + "/*" + NL + " * The function is used to get the lock status from the card." + NL + " */" + NL + "status_t  SDMMC003_GetLockStatus( uint32_t *LockStatusPtr)" + NL + "{" + NL + "  uint32_t CardStatus = 0UL;" + NL + "  uint32_t Argument = 0;" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {      " + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_LockStatusError == TRUE)" + NL + "    {" + NL + "      /* Forcefully trigger the Command Timeout Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0001 ;" + NL + "      /* Disable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "      /* Disable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "    }" + NL + "#endif" + NL + "    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "    /* Send Cmd13 to read card status  */" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)), Argument, \\" + NL + "                                    SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "/* <<< DD_SDMMC_API_9_1 >>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<< DD_SDMMC_API_9_2 >>> */" + NL + "    /* Lock/Unlock Status bit in the CSR Register */" + NL + "    if ((CardStatus & SDMMC003_CSR_CARD_IS_LOCKED_BITMASK) != 0)" + NL + "    {" + NL + "      *LockStatusPtr = (uint32_t)SDMMC003_CARD_IS_LOCKED;" + NL + "    }/* End of \"if ((CardStatus & SDMMC003_CSR_CARD_IS_LOCKED_BITMASK) != 0)\"*/" + NL + "/* <<< DD_SDMMC_API_9_3 >>> */" + NL + "    else" + NL + "    {" + NL + "      *LockStatusPtr = (uint32_t)SDMMC003_CARD_UNLOCKED;" + NL + "    }" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_10 >>> */" + NL + "/*" + NL + " * This function is use to  get card's current state." + NL + " */" + NL + "status_t SDMMC003_GetCurrentState()" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_STATE_NO_CARD;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x,(uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<<DD_SDMMC_API_10_1>>> */" + NL + "  if ((SDMMC003_Handle.State & SDMMC003_STATE_CARD_INITIALIZED))" + NL + "  {" + NL + "    Status &= ~(SDMMC003_STATE_NO_CARD);" + NL + "    Status |= SDMMC003_STATE_CARD_INITIALIZED;" + NL + "  }" + NL + "/* <<<DD_SDMMC_API_10_2>>> */" + NL + "  if ((SDMMC003_Handle.State & SDMMC003_STATE_CARD_WRITE_PROTECT) != 0)" + NL + "  {" + NL + "    Status |= SDMMC003_STATE_CARD_WRITE_PROTECT;" + NL + "  }" + NL + "/* <<<DD_SDMMC_API_10_3>>> */" + NL + "  if ((SDMMC003_Handle.State & SDMMC003_STATE_CARD_LOCKED) != 0)" + NL + "  {" + NL + "    Status |= SDMMC003_STATE_CARD_LOCKED;" + NL + "  }" + NL + "/* <<<DD_SDMMC_API_10_4>>> */" + NL + "  if ((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) != 0)" + NL + "  {" + NL + "    Status |= SDMMC003_STATE_HC_INITIALIZED;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* <<< DD_SDMMC_API_11 >>> */" + NL + "/*" + NL + " * This function is use to  get card type information" + NL + " */" + NL + "status_t SDMMC003_GetCardType(uint32_t* CardTypePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<< DD_SDMMC_API_11_1 >>> */  " + NL + "  /*Check Whether Initialization Process is successful */" + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "/* <<< DD_SDMMC_API_11_2 >>> */  " + NL + "  else" + NL + "  {" + NL + "    *CardTypePtr = SDMMC003_Handle.CardType;" + NL + "  } " + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_12 >>> */" + NL + "/* This function is use to Get CID register information of card */" + NL + "status_t SDMMC003_GetCid (void *Buffer)" + NL + "{" + NL + "  SDMMC003_SDCIDType* Tmp = (SDMMC003_SDCIDType*)Buffer;" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<< DD_SDMMC_API_12_1 >>> */" + NL + "  /*Check Whether Initialization Process is successful */" + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "/* <<< DD_SDMMC_API_12_2 >>> */  " + NL + "  else" + NL + "  {" + NL + "    Tmp->ManufacturingDate = (SDMMC003_CardInfo.CidArray[0])&0xFFF;" + NL + "    Tmp->ProductSerialNum =  (SDMMC003_CardInfo.CidArray[1]<<16)| \\" + NL + "                             (SDMMC003_CardInfo.CidArray[0]>>16);" + NL + "    Tmp->ProductRev =  (SDMMC003_CardInfo.CidArray[1]>>16)&0xff;" + NL + "    Tmp->ProductName[0] =  (SDMMC003_CardInfo.CidArray[2]>>24)&0xff;" + NL + "    Tmp->ProductName[1] =  (SDMMC003_CardInfo.CidArray[2]>>16)&0xff;" + NL + "    Tmp->ProductName[2] =  (SDMMC003_CardInfo.CidArray[2]>>8)&0xff;" + NL + "    Tmp->ProductName[3] =  (SDMMC003_CardInfo.CidArray[2]>>0)&0xff;" + NL + "    Tmp->ProductName[4] =  (SDMMC003_CardInfo.CidArray[1]>>24)&0xff;" + NL + "    Tmp->AppOEMId[0] = (SDMMC003_CardInfo.CidArray[3]>>8)&0xff;" + NL + "    Tmp->AppOEMId[1] = (SDMMC003_CardInfo.CidArray[3])&0xff;" + NL + "    Tmp->ManufacturerId = (SDMMC003_CardInfo.CidArray[3]>>16)&0xff;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_13>>> */" + NL + "/*" + NL + " * This function is use to  Get OCR information on the card" + NL + " */" + NL + "status_t SDMMC003_GetOcr (void *Buffer)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<< DD_SDMMC_API_13_1>>> */  " + NL + "  /*Check Whether Initialization Process is successful */" + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "/* <<< DD_SDMMC_API_13_2>>> */  " + NL + "  else" + NL + "  {" + NL + "    *(uint32_t *)Buffer = SDMMC003_CardInfo.Ocr;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_14>>> */" + NL + "/* This function is use to get CSD information on the card */" + NL + "status_t SDMMC003_GetCsd (void *Buffer)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /*Check Whether Initialization Process is successful */" + NL + "/* <<< DD_SDMMC_API_14_1>>> */    " + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "/* <<< DD_SDMMC_API_14_2>>> */    " + NL + "  else" + NL + "  {" + NL + "    /* Csd Structure includes 7-bit CRC  1-bit fixed bit which is not sent by the card." + NL + "     So while copying skip one byte and copy in the structure*/" + NL + "    memcpy(((uint8_t *)Buffer + 1),(void *)SDMMC003_CardInfo.CsdArray,15);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_15 >>> */" + NL + "/*" + NL + " * This function is use to get number of sectors present on the card." + NL + " */" + NL + "status_t SDMMC003_GetSectorCount( void *Buffer )" + NL + "{" + NL + "  uint32_t Mult = 0;" + NL + "  status_t Status ;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "" + NL + "  do" + NL + "  {" + NL + "/*<<<DD_SDMMC_API_15_1>>> */    " + NL + "    /*Check Whether Initialization Process is successful */" + NL + "    if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "      break;" + NL + "    }" + NL + "/* <<< DD_SDMMC_API_15_2 >>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_SD_HIGH_CAPACITY)!= 0)" + NL + "    {" + NL + "      SDMMC003_CSDV2Type TmpCsdV2 = {0};" + NL + "      /*Get CSD function */" + NL + "      Status = SDMMC003_GetCsd((void *)&TmpCsdV2);" + NL + "/* <<< DD_SDMMC_API_15_3 >>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      } /* End of \"if( Status != DAVEApp_SUCCESS)\" */" + NL + "      /* For High Capacity SD card, (C_SIZE field value + 1) * 1024" + NL + "        gives the sector count*/" + NL + "      *(uint32_t *)Buffer = (((TmpCsdV2.DeviceSizeHigh << 16UL) |   \\" + NL + "                               (TmpCsdV2.DeviceSizeLower ) )+ 1 ) << 10;" + NL + "    }/* End of \"if((SDMMC003_Handle.CardType & SDMMC003_SD_HIGH_CAPACITY)!= 0)\"*/" + NL + "" + NL + "    /* For Standard SD card & MMC card  ," + NL + "     * Sector Count =  (Device Size + 1) * Mult, where Mult =  2 ^ C_SIZE_MULT*/" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "/* <<< DD_SDMMC_API_15_4 >>> */" + NL + "    else if( (uint8_t)(SDMMC003_Handle.CardType == SDMMC003_MMC) != 0)" + NL + "    {" + NL + "      SDMMC003_MMCCSDType TmpMmcCsd = {0};" + NL + "      /*Get csd function */" + NL + "      Status = SDMMC003_GetCsd((void *)&TmpMmcCsd);" + NL + "/* <<< DD_SDMMC_API_15_5 >>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* As per Specs Sector Count is:" + NL + "       * BLOCKNR = (C_SIZE+1) * MULT  , where MULT = 2^C_SIZE_MULT+2 (C_SIZE_MULT < 8)*/" + NL + "      Mult = 1 << (TmpMmcCsd.DeviceSizeMult + 2) ;" + NL + "      *(uint32_t *)Buffer = (((TmpMmcCsd.DeviceSizeHigh << 10UL) |  \\" + NL + "                              (TmpMmcCsd.DeviceSizeLower ))+ 1) * Mult ;" + NL + "    }" + NL + "#endif" + NL + "    /* Standard SD card */" + NL + "/* <<< DD_SDMMC_API_15_6 >>> */" + NL + "    else" + NL + "    {" + NL + "      SDMMC003_CSDV1Type TmpCsdV1 = {0};" + NL + "      /*Get csd function */" + NL + "      Status = SDMMC003_GetCsd((void *)&TmpCsdV1);" + NL + "/* <<< DD_SDMMC_API_15_7 >>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Left Shift evaluates 1* 2^(TmpMmcCsd.DeviceSizeMult + 2)*/" + NL + "      Mult = (TmpCsdV1.DeviceSizeMult + TmpCsdV1.ReadBlkLen - 7);" + NL + "      /* Sector Count = Device_size * Mult.*/" + NL + "      *(uint32_t *)Buffer = (((TmpCsdV1.DeviceSizeHigh << 2) |   \\" + NL + "                                  (TmpCsdV1.DeviceSizeLower ))+ 1) <<  Mult;" + NL + "    } /* End of \"Else SD card \" */" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_16 >>> */" + NL + "/*" + NL + " * This function is use to get Sector Size info from the card" + NL + " */" + NL + "status_t SDMMC003_GetSectorSize(void *Buffer)" + NL + "{" + NL + "  status_t Status = (uint32_t) DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<< DD_SDMMC_API_16_1 >>> */  " + NL + "  /*Check Whether Initialization Process is successfull */" + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "/* <<< DD_SDMMC_API_16_2 >>> */  " + NL + "  else" + NL + "  {" + NL + "    /* Sector Size is fixed to 512bytes.*/" + NL + "    *(uint16_t *)Buffer = 512UL;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_17 >>> */" + NL + "/*" + NL + " *  This function returns erase block size of the card in unit of sector into" + NL + " *  the DWORD variable pointed by Buffer" + NL + " */" + NL + "" + NL + "status_t SDMMC003_GetBlockSize(void *Buffer)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<< DD_SDMMC_API_17_1 >>> */  " + NL + "  /*Check Whether Initialization Process is successful */" + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "  /* SD High capacity card i.e. CSD V2*/" + NL + "/* <<< DD_SDMMC_API_17_2 >>> */" + NL + "  else if ((SDMMC003_Handle.CardType & SDMMC003_SD_HIGH_CAPACITY) != 0)" + NL;
  protected final String TEXT_5 = "  {" + NL + "    SDMMC003_CSDV2Type TmpCsdV2 = {0};" + NL + "    /*Get CSD function */" + NL + "    Status = SDMMC003_GetCsd((void *)&TmpCsdV2);" + NL + "    *(uint32_t *)Buffer = TmpCsdV2.EraseSectorSize + 1;" + NL + "  }" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "  /* SDMMC_MMC card */" + NL + "/* <<< DD_SDMMC_API_17_3 >>> */" + NL + "  else if ((SDMMC003_Handle.CardType & SDMMC003_MMC )!= 0)" + NL + "  {" + NL + "    SDMMC003_MMCCSDType TmpMmcCsd = {0};" + NL + "    /*Get csd function */" + NL + "    Status = SDMMC003_GetCsd((void *)&TmpMmcCsd);" + NL + "    *(uint32_t *)Buffer =  (TmpMmcCsd.EraseGrpSize + 1) *   \\" + NL + "                   (TmpMmcCsd.EraseGrpMult + 1);" + NL + "  }" + NL + "#endif" + NL + "  /* SD standard capacity card i.e. CSD V1*/" + NL + "/* <<< DD_SDMMC_API_17_4 >>> */" + NL + "  else" + NL + "  {" + NL + "    SDMMC003_CSDV1Type TmpCsdV1  = {0};" + NL + "    /*Get csd function */" + NL + "    Status = SDMMC003_GetCsd((void *)&TmpCsdV1);" + NL + "    *(uint32_t *)Buffer = TmpCsdV1.EraseSectorSize + 1;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + " return  Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_18 >>> */" + NL + "/*" + NL + " *  This function Flushes Disk Cache from the card" + NL + " */" + NL + "status_t SDMMC003_FlushDiskWriteCache()" + NL + "{" + NL + "  status_t Status  = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<< DD_SDMMC_API_18_1 >>> */  " + NL + "  /*Check Whether Initialization Process is successful */" + NL + "  if (SDMMC003_Handle.InitializeFlag != 1 )" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_INIT_FAIL;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_API_19>>> */" + NL + "/*" + NL + " * This function is use to Get SD Status Information" + NL + " */" + NL + "status_t SDMMC003_GetSdStatus(void *Buffer)" + NL + "{" + NL + "  uint32_t Argument = 0;" + NL + "  uint32_t CardStatus = 0;" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_CommandErrorInterrupt== TRUE)" + NL + "    {" + NL + "      /* Disable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "      /* Disable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "    }" + NL + "#endif" + NL + "    /* Select the card ie.cmd7 */" + NL + "    Status = SDMMC003_lSwitchToTransferState();" + NL + "/* <<<DD_SDMMC_API_19_1>>> */" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Send the Application Specific Command i.e. Command 55.*/" + NL + "#if SDMMC_UVP_TEST" + NL + "   if (Test_TriggerInterrupt.Trigger_Cmd55_TC54 == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_Cmd55Error = TRUE;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Cmd55Error == TRUE)" + NL + "    {" + NL + "      /* Disable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "      /* Disable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "    }" + NL + "#endif" + NL + "    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "    Status = SDMMC003_lSendCommand(&(SDMMC003_COMMON_COMMAND(55)),Argument, \\" + NL + "                                    SDMMC003_RESPONSE_R1,&CardStatus);" + NL + "/* <<<DD_SDMMC_API_19_2>>> */" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /*  Set Transfer Mode Register */" + NL + "    SET_BIT( SDMMC->TRANSFER_MODE, SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "    /* Read the SD status from the data line */" + NL + "/* <<<DD_SDMMC_API_19_3>>> */" + NL + "    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(59)),\\" + NL + "                                            SDMMC003_ARGUMENT0,64,\\" + NL + "                                            (uint32_t*)Buffer,\\" + NL + "                                            SDMMC003_READ_FROM_BUFF);" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_20 >>> */" + NL + "/*" + NL + " * This function is use to  de-activate the  Card" + NL + " */" + NL + "status_t SDMMC003_EjectCard()" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  uint32_t Argument = 0;" + NL + "  do" + NL + "  {" + NL + "/* <<< DD_SDMMC_API_20_1 >>> */" + NL + "    if (SDMMC003_Handle.State & SDMMC003_STATE_NO_CARD )" + NL + "    {" + NL + "      break;" + NL + "    }/* End of \"if ((SDMMC003_Handle.State & SDMMC003_STATE_NO_CARD )!= 1)\" */" + NL + "    /* Send Command 15 to de-activate the card */" + NL + "    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(15)), Argument, \\" + NL + "                                    SDMMC003_NO_RESPONSE,  NULL);" + NL + "/* <<< DD_SDMMC_API_20_2 >>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Card Cleanup */" + NL + "    SDMMC003_lCardCleanUp();" + NL + "    SDMMC003_Handle.InitializeFlag = 0;" + NL + "  } while(0);" + NL + "  /* Debug Log message .*/" + NL + "  INFO(GID_SDMMC00x,Status,0,0);" + NL + "  return Status; " + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_22 >>> */" + NL + "/*" + NL + " * This function brings the SDMMC peripheral out of reset." + NL + " */" + NL + "void SDMMC003_Init()" + NL + "{" + NL + "  RESET001_DeassertReset(PER1_MMC);" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_23 >>> */" + NL + "/*" + NL + " * This function performs the SDMMC LLD App Initialization which includes Host Controller Initialization," + NL + " * Card Initialization and Reading Card Registers." + NL + " */" + NL + "status_t SDMMC003_Start()" + NL + "{" + NL + "  status_t Status =  (uint32_t)SDMMC003_HOST_CONTROLLER_INITIALIZED;" + NL + "/* <<< DD_SDMMC_API_23_1 >>> */  " + NL + "  /* Check If Host controller is already Initialized */" + NL + "  if ( (SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) == 0)" + NL + "  {" + NL + "    /* Enable Interrupt */" + NL + "    NVIC_SetPriority(SDMMC0_0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), \\" + NL + "                                                        SDMMC_PREEMPTION_PRIORITY,\\" + NL + "                                                        SDMMC_SUB_PRIORITY));" + NL + "    NVIC_ClearPendingIRQ(SDMMC0_0_IRQn);" + NL + "    NVIC_EnableIRQ(SDMMC0_0_IRQn);" + NL + "/* <<< DD_SDMMC_API_23_1 >>> */" + NL + "    /* Host Controller Initialize */" + NL + "    Status = SDMMC003_HostControllerInit();" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_API_24 >>> */" + NL + "/*" + NL + " * This function performs the SDMMC LLD App Initialization which includes Host Controller Initialization," + NL + " * Card Initialization and Reading Card Registers." + NL + " */" + NL + "status_t SDMMC003_CardDetectionSupport()" + NL + "{" + NL + "  status_t Status;" + NL + "/* <<< DD_SDMMC_API_24_1 >>> */" + NL + "  Status = SDMMC003_lCardIdentificationProcess();" + NL + "  if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    SDMMC003_Handle.InitializeFlag = 1;  " + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "#if SDMMC_CARD_DETECTION_SUPPORT" + NL + "/* <<< DD_SDMMC_API_25 >>> */" + NL + "/*" + NL + " * This function registers the call back function of upper layer which will be " + NL + " * invoked from low-level driver if card is inserted or removed in the kit" + NL + " * supporting Card detection mechanism." + NL + " */ " + NL + "status_t SDMMC003_RegisterCallBack(SDMMC003_PtrToCallBackFunction \\" + NL + "                                            CallbackFunction)" + NL + "{" + NL + "  status_t Status = SDMMC003_ERROR;" + NL + "  do" + NL + "  {" + NL + "/* Check Function Pointer is Not Null */" + NL + "/* <<< DD_SDMMC_API_25_1 >>> */" + NL + "    if (CallbackFunction == NULL )" + NL + "    {  " + NL + "      break;" + NL + "    }" + NL + "    SDMMC003_Handle.CallBackPtr = CallbackFunction; " + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "#endif" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL + NL + NL;
  protected final String TEXT_6 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/sdmmc003/"; 
     int appInst = 0; 
     int RTOS = app.getIntegerValue(AppBaseuri + appInst + "/sdmmc003_rtos_present");
  String  Module_Name = "SDMMC003";

    stringBuffer.append(TEXT_2);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_3);
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    return stringBuffer.toString();
  }
}
