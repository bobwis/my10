package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class fatfs004h_template
{
  protected static String nl;
  public static synchronized fatfs004h_template create(String lineSeparator)
  {
    nl = lineSeparator;
    fatfs004h_template result = new fatfs004h_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[FATFS004.h]*/" + NL + "/******************************************************************************" + NL + " *" + NL + " * Copyright (C) 2011 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with " + NL + " * Infineon's microcontrollers." + NL + " * This file can be freely distributed within development" + NL + " * tools that are supporting such microcontrollers. " + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR" + NL + " * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : July 31, 2012                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/" + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = NL + NL + NL + "/**" + NL + " * @file  ";
  protected final String TEXT_4 = ".h" + NL + " *" + NL + " * @brief This file contains all public data structures,enums and function" + NL + " *        prototypes for Device Abstraction Layer App." + NL + " *" + NL + " */" + NL + "" + NL + "#ifndef  ";
  protected final String TEXT_5 = "_H_" + NL + "#define  ";
  protected final String TEXT_6 = "_H_" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "#include \"diskio.h\"" + NL + "" + NL + "" + NL + "/**" + NL + " * @ingroup  ";
  protected final String TEXT_7 = "_publicparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "/**" + NL + " *  Combination of Status Flags indicating No Disk & No Initialization" + NL + " */" + NL + "#define  ";
  protected final String TEXT_8 = "_NODISK_NOINIT \t\t\t\t\t\t\t\t3" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       ENUMERATIONS                                         **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * This enumerates the error codes of Device Abstraction Layer App" + NL + " */" + NL + "typedef enum ";
  protected final String TEXT_9 = "_ErrorCodesType" + NL + "{" + NL + "  /**" + NL + "   * ";
  protected final String TEXT_10 = " Module Error  (1)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #19" + NL + "  MODULENAME = Device Abstraction Layer App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = ";
  protected final String TEXT_11 = "_ERROR" + NL + "  STRCODESTRING = Error in SDMMC001 App." + NL + "  */";
  protected final String TEXT_12 = NL + "  ";
  protected final String TEXT_13 = "_ERROR = 1," + NL + "  /**" + NL + "   * SDMMC Block Layer Module Error  (1)" + NL + "   */" + NL + "  /*" + NL + "  GROUPID  #19" + NL + "  MODULENAME = Device Abstraction Layer App" + NL + "  */" + NL + "  /*" + NL + "  ERRCODESTRING = ";
  protected final String TEXT_14 = "_";
  protected final String TEXT_15 = "_ERROR" + NL + "  STRCODESTRING = Error in Sdmmc Block Layer App. Error is propagated to FAT FS" + NL + "  so is returned in FAT FS error format" + NL + "  */";
  protected final String TEXT_16 = NL + "  ";
  protected final String TEXT_17 = "_";
  protected final String TEXT_18 = "_ERROR," + NL + "  /**" + NL + "   * Debug log codes starts here  (0)" + NL + "   */" + NL + "  /**" + NL + "   * DebugLog Message Id for Function Entry" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = ";
  protected final String TEXT_19 = "_FUNCTION_ENTRY" + NL + "  STRCODESTRING = Function Entered %s" + NL + "  */" + NL + "\t";
  protected final String TEXT_20 = "_FUNCTION_ENTRY," + NL + "  /**" + NL + "   * DebugLog Message Id for Function Exit (1)" + NL + "   */" + NL + "  /*" + NL + "  ERRCODESTRING = ";
  protected final String TEXT_21 = "_FUNCTION_EXIT" + NL + "  STRCODESTRING = Function Exited %s" + NL + "  */" + NL + "\t";
  protected final String TEXT_22 = "_FUNCTION_EXIT" + NL + "} ";
  protected final String TEXT_23 = "_ErrorCodesType;" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * Function Pointer pointing to the Block Layer's disk initialize function. " + NL + " */" + NL + "typedef uint8_t (*InitializeFunc) (void);" + NL + "/**" + NL + " * Function Pointer pointing to the Block Layer's  get disk status function. " + NL + " */" + NL + "typedef uint8_t (*GetStatusFunc) (void);" + NL + "/**" + NL + " * Function Pointer pointing to the Block Layer's read block function." + NL + " */" + NL + "typedef uint32_t (*ReadBlkFunc) (uint8_t*, uint32_t, uint8_t);" + NL + "/**" + NL + " * Function Pointer pointing to the Block Layer's write block function. " + NL + " */" + NL + "typedef uint32_t (*WriteBlkFunc)(const uint8_t*, uint32_t, uint8_t);" + NL + "/**" + NL + " * Function Pointer pointing to the Block Layer's IOCTL function. " + NL + " */" + NL + "typedef uint32_t (*IoctlFunc) (uint8_t, void * );" + NL + "/*******************************************************************************" + NL + "**                       STRUCTURES                                           **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * This structure holds the block layers' devices' function pointers data type " + NL + " * as member fields" + NL + " */" + NL + "typedef struct ";
  protected final String TEXT_24 = "_DeviceFuncType" + NL + "{" + NL + "/**" + NL + " * Disk Initialize function pointer" + NL + " */" + NL + "  InitializeFunc InitializePtr;" + NL + "/**" + NL + " * Get Disk Status function pointer" + NL + " */" + NL + "  GetStatusFunc GetStatusPtr;" + NL + "/**" + NL + " * Read Blocks of data from disk  function pointer" + NL + " */" + NL + "  ReadBlkFunc ReadBlkPtr;" + NL + "/**" + NL + " * Write Blocks of data on disk Function Pointer" + NL + " */" + NL + "  WriteBlkFunc WriteBlkPtr;" + NL + "/**" + NL + " * Ioctl Function Pointer" + NL + " */" + NL + "  IoctlFunc IoctlPtr;" + NL + "} ";
  protected final String TEXT_25 = "_DeviceFuncType;" + NL + "" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/**" + NL + " * @ingroup ";
  protected final String TEXT_26 = "_apidoc" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + " **\t\t\t\t\t\t\tFUNCTION PROTOTYPES                 **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief This function initializes a physical drive and put it" + NL + " * ready to read/write. Application program should not call this function, or" + NL + " * FAT structure on the volume can be collapted. To re-initialize the file system," + NL + " * use f_mount function.This function is called on volume mount process in the" + NL + " * FatFs module to manage the media change." + NL + " * @param[in] Drive Specifies the physical drive number to initialize. " + NL + " * @return DSTATUS\\n" + NL + " * Returns Disk status as the result.\\n" + NL + " * Refer disk_status function for details of status flags.\\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   DSTATUS DStatus;" + NL + " *   // DAVE Initialization." + NL + " *   DAVE_Init();" + NL + " *   // SDMMC drive number will be at '0' drive " + NL + " *   DStatus =  disk_initialize(0);" + NL + " *   if (DStatus == (STA_NODISK | STA_NOINIT))" + NL + " *   {" + NL + " *     //No card Present;" + NL + " *   }" + NL + " *   if (DStatus == STA_NOINIT)" + NL + " *   {" + NL + " *    //Card Present but not initialized." + NL + " *   }" + NL + " *   if (DStatus == STA_PROTECT)" + NL + " *   {" + NL + " *     //Card is Write Protected ." + NL + " *   } " + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "DSTATUS disk_initialize(BYTE Drive);" + NL + "" + NL + "/**" + NL + " * @brief The disk_status function returns the current disk status." + NL + " * @param[in] Drive Specifies the physical drive number to be confirmed." + NL + " * @return DSTATUS\\n" + NL + " * Returns disk status as the result.\\n" + NL + " * <b>STA_NOINIT:</b> Indicates that the disk drive has not been initialized. " + NL + " * This flag is set on: system reset, disk removal and disk_initialize function failed," + NL + " * and cleared on: disk_initialize function succeeded. \\n" + NL + " * <b>STA_NODISK:</b>Indicates that no medium in the drive. This is always cleared on fixed disk drive.\\n" + NL + " * <b>STA_PROTECTED:</b>Indicates that the medium is write protected. This is always " + NL + " * cleared on the drive that does not support write protect notch. Not valid when STA_NODISK is set. \\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   DSTATUS DStatus;" + NL + " *   // DAVE Initialization." + NL + " *   DAVE_Init();" + NL + " *   // SDMMC drive number will be at '0' drive  " + NL + " *   DStatus =  disk_status(0);" + NL + " *   if (DStatus == (STA_NODISK | STA_NOINIT))" + NL + " *   {" + NL + " *     //No card Present;" + NL + " *   }" + NL + " *   if (DStatus == STA_NOINIT)" + NL + " *   {" + NL + " *     //Card Present but not initialized." + NL + " *   }" + NL + " *   if (DStatus == STA_PROTECT)" + NL + " *   {" + NL + " *     //Card is Write Protected ." + NL + " *   } " + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "DSTATUS disk_status(BYTE Drive);" + NL + "" + NL + "/**" + NL + " * @brief The disk_read function reads sector(s) from the disk drive. Note that " + NL + " * the specified memory address to store read data is not that always aligned to word boundary." + NL + " * If the hardware does not support misaligned data transfer, it must be solved" + NL + " * in this function. " + NL + " * @param[in] Drive Physical drive number " + NL + " * @param[in] Buffer Pointer to the byte array to store the read data." + NL + " * The buffer size of number of bytes to be read, sector size * sector count, is required. " + NL + " * @param[in] SectorNumber Specifies the start sector number in logical block address (LBA). " + NL + " * @param[in] SectorCount Specifies number of sectors to read. The value can be 1 to 128. " + NL + " * Generally, a multiple sector transfer request must not be split into single " + NL + " * sector transactions to the device, or you may not get good read performance. " + NL + " * @return DRESULT \\n" + NL + " * RES_OK The function succeeded.\\n" + NL + " * RES_ERROR Any hard error occurred during the read operation and could" + NL + " * not recover it.\\n" + NL + " * RES_PARERR Invalid parameter\\n" + NL + " * RES_NOTRDY The disk drive has not been initialized.\\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   uint32_t Counter = 0;" + NL + " *   uint32_t Count = 0;" + NL + " *   DRESULT DResult;" + NL + " *    // NOTE: This buffer has to be aligned to 4-byte boundary !!!!!!!" + NL + " *   uint32_t ReadData[256] = {0};" + NL + " *   uint32_t WriteData[256] = {0};" + NL + " *   // DAVE Initialization." + NL + " *   DAVE_Init();" + NL + " *   // Write some data to be written on the card " + NL + " *   for(Counter=0;Counter<256;Counter++)" + NL + " *   {" + NL + " *     WriteData[Counter] = Counter * 10;" + NL + " *   }" + NL + " *   // Write functionality " + NL + " *   DResult =  disk_write(0,(uint8_t*)WriteData,200, 2);" + NL + " *   if(DResult == RES_OK)" + NL + " *   {" + NL + " *     // Read functionality " + NL + " *     DResult =  disk_read(0, (uint8_t*)ReadData, 200, 2);" + NL + " *     // Write and Read data validation" + NL + " *     for( Count=0; Count<256; Count++)" + NL + " *     {" + NL + " *       if( ReadData[Count] != WriteData[Count])" + NL + " *       {" + NL + " *         // Read and Write Data doesn't match." + NL + " *       }" + NL + " *     }" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "DRESULT disk_read" + NL + "(" + NL + "  BYTE Drive," + NL + "  BYTE *Buffer," + NL + "  DWORD SectorNumber," + NL + "  BYTE SectorCount" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief The disk_write writes sector(s) to the disk.Note that the specified memory " + NL + " * address from where to write data is not that always aligned to word boundary. " + NL + " * If the hardware does not support misaligned data transfer, it must be solved" + NL + " * in this function.This function is not required in read only configuration." + NL + " * @param[in] Drive Specifies the physical drive number" + NL + " * @param[in] Buffer Pointer to the byte array to be written. " + NL + " * @param[in] SectorNumber Specifies the start sector number in logical block address (LBA). " + NL + " * @param[in] SectorCount Specifies the number of sectors to write. The value can" + NL + " * be 1 to 128. Generally, a multiple sector transfer request must not be split" + NL + " * into single sector transactions to the device, or you will never get good " + NL + " * write performance." + NL + " * @return" + NL + " * RES_OK The function succeeded.\\n" + NL + " * RES_ERROR Any hard error occured during the write operation and could not recover it.\\n" + NL + " * RES_PARERR Invalid parameter\\n" + NL + " * RES_NOTRDY The disk drive has not been initialized.\\n" + NL + " * RES_WRPRT The medium is write protected.\\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   DRESULT DResult;" + NL + " *   uint32_t Counter = 0;" + NL + " *   uint32_t Count = 0;" + NL + " *    // NOTE: This buffer has to be aligned to 4-byte boundary !!!!!!!" + NL + " *   uint32_t ReadData[256] = {0};" + NL + " *   uint32_t WriteData[256] = {0};" + NL + " *   // DAVE Initialization." + NL + " *   DAVE_Init();" + NL + " *   for(Counter=0;Counter<256;Counter++)" + NL + " *   {" + NL + " *     WriteData[Counter] = Counter * 10;" + NL + " *   }" + NL + " *   // Write functionality " + NL + " *   DResult =  disk_write(0,(uint8_t*)WriteData,200, 2);" + NL + " *   if(DResult == RES_OK)" + NL + " *   {" + NL + " *     // Read data from card to verify the data written. " + NL + " *     DResult =  disk_read(0, (uint8_t*)ReadData, 200, 2);" + NL + " *     for( Count=0; Count<256; Count++)" + NL + " *     {" + NL + " *       if( ReadData[Count] != WriteData[Count])" + NL + " *       {" + NL + " *         // Read and Write Data doesn't match." + NL + " *       }" + NL + " *     }" + NL + " *   }" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "DRESULT disk_write" + NL + "(" + NL + "  BYTE Drive," + NL + "  const BYTE*  Buffer," + NL + "  DWORD SectorNumber," + NL + "  BYTE  SectorCount" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief  The disk_ioctl function controls device specified features and" + NL + " * miscellaneous functions other than disk read/write. The FatFs module uses" + NL + " * only device independent commands described below. Any device dependent function is not used." + NL + " * @param[in] Drive Specifies the drive number (0-9). " + NL + " * @param[in] Command Specifies the command code. " + NL + " * @param[in] Buffer Pointer to the parameter buffer depends on the command code. " + NL + " * When it is not used, specify a NULL pointer.  " + NL + " * @return DRESULT \\n" + NL + " * RES_OK The function succeeded.\\n" + NL + " * RES_ERROR Any error occurred.\\n" + NL + " * RES_PARERR Invalid command code.\\n" + NL + " * RES_NOTRDY The disk drive has not been initialized.\\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * <BR><P ALIGN=\"LEFT\">" + NL + " * <b>Generic command (defined for FatFs)  </b>\\n" + NL + " * <p> CTRL_SYNC: Flush disk cache (for write functions) \\n" + NL + " *  GET_SECTOR_COUNT: Get media size (for only f_mkfs())  \\n" + NL + " *  GET_SECTOR_SIZE: Get sector size (for multiple sector size (_MAX_SS >= 1024)) \\n" + NL + " *  GET_BLOCK_SIZE: Get erase block size (for only f_mkfs()) \\n" + NL + " *  CTRL_ERASE_SECTOR:  Force erased a block of sectors (for only _USE_ERASE) \\n" + NL + " *  </p> \\n" + NL + " * <b> Generic command </b> \\n" + NL + " * <p> CTRL_EJECT: Eject media </p>\\n" + NL + " * <b> MMC/SDC specific ioctl commands </b> \\n" + NL + " * <p> MMC_GET_TYPE: Get card type \\n" + NL + " *  MMC_GET_CSD: Get CSD \\n" + NL + " *  MMC_GET_CID: Get CID \\n" + NL + " *  MMC_GET_OCR: Get OCR \\n" + NL + " *  MMC_GET_SDSTAT:  Get SD status \\n" + NL + " * </p>" + NL + " * </p>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   DRESULT Result;" + NL + " *   uint32_t Buffer;" + NL + " *   // Get Sector Count" + NL + " *   Result = disk_ioctl(0,GET_SECTOR_COUNT,(void *)&Buffer);" + NL + " *   if (Result == RES_OK)" + NL + " *   {" + NL + " *     // Get Card Type" + NL + " *     Result = disk_ioctl( 0,MMC_GET_TYPE,(void *)&Buffer);" + NL + " *     if (Result == RES_OK )" + NL + " *     {" + NL + " *       if( Buffer & SDMMC003_SD_STANDARD_CAPACITY_V2)" + NL + " *       {" + NL + " *         // Standard Capacity Card version2" + NL + " *       }" + NL + " *       if( Buffer & SDMMC003_SD_STANDARD_CAPACITY_V1x)" + NL + " *       {" + NL + " *         // Standard Capacity Card version1." + NL + " *       } " + NL + " *       if( Buffer & SDMMC003_SD_HIGH_CAPACITY)" + NL + " *       {" + NL + " *         // High Capacity Card." + NL + " *       }" + NL + " *     }" + NL + " *   }" + NL + " *   // Eject card //" + NL + " *   Result = disk_ioctl(0,CTRL_EJECT,NULL);" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "DRESULT  disk_ioctl(BYTE Drive, BYTE Command, void * Buffer);" + NL + "" + NL + "/**" + NL + " * @brief  The get_fattime function gets current time.The get_fattime function " + NL + " * must return any valid time even if the system does not support a real time clock. " + NL + " * If a zero is returned, the file will not have a valid time. This fucntion is" + NL + " * not required in read only configuration." + NL + " * @return Current time is returned with packed into a DWORD value. The bit" + NL + " * field is as follows:\\n" + NL + " * bit31:25: Year from 1980 (0..127)\\n" + NL + " * bit24:21: Month (1..12)\\n" + NL + " * bit20:16: Day in month(1..31)\\n" + NL + " * bit15:11: Hour (0..23)\\n" + NL + " * bit10:5: Minute (0..59)\\n" + NL + " * bit4:0: Second / 2 (0..29)\\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   uint32_t Time;" + NL + " *   Time = get_fattime();" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode" + NL + " */" + NL + "DWORD get_fattime(void);" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "#endif /* ";
  protected final String TEXT_27 = "_H_ */" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL + NL;
  protected final String TEXT_28 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/fatfs004/"; 
     int appInst = 0; 
     int  RTOS = app.getIntegerValue(AppBaseuri + appInst + "/fatfs004_rtos_present");
   String  Module_Name = "FATFS004";
   String  Sub_Module_Name = "SDMMC001";

    stringBuffer.append(TEXT_2);
     
  if (RTOS == 1)
  {
  	 Module_Name = "FATFS005";
 	 Sub_Module_Name = "SDMMC002";
  }
  else
  {
    Module_Name = "FATFS004";
    Sub_Module_Name = "SDMMC001";
  }

    stringBuffer.append(TEXT_3);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_4);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_5);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_6);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_7);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_8);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_9);
    stringBuffer.append( Sub_Module_Name);
    stringBuffer.append(TEXT_10);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_11);
    stringBuffer.append(TEXT_12);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_13);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_14);
    stringBuffer.append( Sub_Module_Name);
    stringBuffer.append(TEXT_15);
    stringBuffer.append(TEXT_16);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_17);
    stringBuffer.append( Sub_Module_Name);
    stringBuffer.append(TEXT_18);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_19);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_20);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_21);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_22);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_23);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_24);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_25);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_26);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_27);
    stringBuffer.append(TEXT_28);
    return stringBuffer.toString();
  }
}
