package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class sdmmc001c_template
{
  protected static String nl;
  public static synchronized sdmmc001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    sdmmc001c_template result = new sdmmc001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/* CODE_BLOCK_BEGIN[SDMMC001.c] */" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : July 31, 2012                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/";
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = NL + NL + "/**" + NL + " * @file   ";
  protected final String TEXT_4 = ".c" + NL + " *" + NL + " * @brief  This file contains definitions of all private and public functions" + NL + " *         of SDMMC Block Layer App in Non-RTOS environment" + NL + " *" + NL + " */" + NL + " " + NL + "" + NL + "/*******************************************************************************" + NL + "**                      INCLUDE FILES                                         **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup ";
  protected final String TEXT_5 = "_privateparam" + NL + " * @{" + NL + " */" + NL + "/**" + NL + " * Global variable to hold SDMMC device initialization status. It is set to 1 if" + NL + " * SDMMC device is initialized." + NL + " */" + NL + "static uint8_t ";
  protected final String TEXT_6 = "_InitializeFlag;" + NL + "/**" + NL + " * Global variable to hold SDMMC device lock flag status. It is set to 1 if" + NL + " * SDMMC device is initialized but is locked." + NL + " */" + NL + "static uint8_t ";
  protected final String TEXT_7 = "_LockFlag;" + NL + "#ifdef ";
  protected final String TEXT_8 = "_UVP_TEST" + NL + "  bool  CardNotInit = FALSE;" + NL + "#endif" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "/**" + NL + " * @ingroup ";
  protected final String TEXT_9 = "_privatefunc" + NL + " * @{" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                     Private Function Declarations                           **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief This function gets the Current Disk Status." + NL + " * @return uint8_t \\n" + NL + " * STA_NOINIT: Not Initialized\\n" + NL + " * STA_NODISK: No card\\n" + NL + " * STA_PROTECT: Card is write protected\\n" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * <b>Sync/Async: Synchronous</b>" + NL + " * @return <b>uint8_t</b><BR>" + NL + " */" + NL + "uint8_t ";
  protected final String TEXT_10 = "_lFindDiskStatus(void);" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                     Private Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "/*<<<DD_";
  protected final String TEXT_11 = "_nonAPI_1>>>*/" + NL + "uint8_t ";
  protected final String TEXT_12 = "_lFindDiskStatus()" + NL + "{" + NL + "  status_t Status;" + NL + "  uint8_t DiskStatus = 0;" + NL + "/* Get the Status Information */" + NL + "  do" + NL + "  {" + NL + " /* Get the Current State information . */" + NL + "    Status = ";
  protected final String TEXT_13 = "_GetCurrentState();" + NL + "/*<<<DD_";
  protected final String TEXT_14 = "_nonAPI_1_1>>>*/" + NL + "    if (Status & (uint32_t)";
  protected final String TEXT_15 = "_STATE_NO_CARD )" + NL + "    {" + NL + "      DiskStatus = (";
  protected final String TEXT_16 = "_STA_NOINIT | ";
  protected final String TEXT_17 = "_STA_NODISK);" + NL + "      break;" + NL + "    }/* End of \"if ((Status & ";
  protected final String TEXT_18 = "_STATE_CARD_INSERTED) == 0)\"\t\t*/" + NL + "/*<<<DD_";
  protected final String TEXT_19 = "_nonAPI_1_2>>>*/" + NL + "    if ((Status & (uint32_t)";
  protected final String TEXT_20 = "_STATE_CARD_INITIALIZED) == 0)" + NL + "    {" + NL + "      DiskStatus |= ";
  protected final String TEXT_21 = "_STA_NOINIT;" + NL + "      break;" + NL + "    }/* End of \"if ((Status & ";
  protected final String TEXT_22 = "_STATE_CARD_INITIALIZED) == 0)\"\t*/" + NL + "    if (( Status & (uint32_t)";
  protected final String TEXT_23 = "_STATE_CARD_LOCKED) != 0 )" + NL + "    {";
  protected final String TEXT_24 = NL + "      ";
  protected final String TEXT_25 = "_LockFlag = 1;" + NL + "      DiskStatus |= ";
  protected final String TEXT_26 = "_STA_NOINIT;" + NL + "      break;" + NL + "    }/* End of \"if ((Status & (uint32_t)";
  protected final String TEXT_27 = "_STATE_CARD_LOCKED) == 0)\" */" + NL + "/*<<<DD_";
  protected final String TEXT_28 = "_nonAPI_1_3>>>*/" + NL + "    if ((Status & (uint32_t)";
  protected final String TEXT_29 = "_STATE_CARD_WRITE_PROTECT) != 0)" + NL + "    {" + NL + "      DiskStatus |= ";
  protected final String TEXT_30 = "_STA_PROTECT;" + NL + "    }/* End of \"if ((Status & ";
  protected final String TEXT_31 = "_STATE_CARD_WRITE_PROTECT) != 0)\"\t*/" + NL + "  } while(0);" + NL + "  return DiskStatus;" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                     Public Function Definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_32 = "_API_1>>>*/" + NL + "/*" + NL + " * The function checks and returns the initialization status of the card ." + NL + " */" + NL + "uint8_t ";
  protected final String TEXT_33 = "_Initialize(void)" + NL + "{" + NL + "  status_t Status;" + NL + "  uint8_t DiskStatus ;" + NL + "  FUNCTION_ENTRY(GID_";
  protected final String TEXT_34 = ", (uint32_t)";
  protected final String TEXT_35 = "_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "#ifdef ";
  protected final String TEXT_36 = "_UVP_TEST" + NL + "    if (CardNotInit == TRUE)" + NL + "    {";
  protected final String TEXT_37 = NL + "      ";
  protected final String TEXT_38 = "_InitializeFlag =1 ;" + NL + "    }" + NL + "#endif" + NL + "    /* Check the device initialization status. If SDMMC device is" + NL + "     * already initialized, Skip this step else initialize Sdmmc device */" + NL + "    if ( ";
  protected final String TEXT_39 = "_InitializeFlag == 0)" + NL + "    {" + NL + "      Status = ";
  protected final String TEXT_40 = "_Start();" + NL + "      if ( (Status != (uint32_t)DAVEApp_SUCCESS) &&  \\" + NL + "           (Status != (uint32_t)";
  protected final String TEXT_41 = "_HOST_CONTROLLER_INITIALIZED))" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      Status = ";
  protected final String TEXT_42 = "_CardDetectionSupport();" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "      {" + NL + "        if (Status == (uint32_t)";
  protected final String TEXT_43 = "_INITIALIZED_BUT_LOCKED)" + NL + "        {";
  protected final String TEXT_44 = NL + "          ";
  protected final String TEXT_45 = "_LockFlag = 1;" + NL + "        }" + NL + "        break;" + NL + "      }";
  protected final String TEXT_46 = NL + "      ";
  protected final String TEXT_47 = "_InitializeFlag = 1; " + NL + "    }" + NL + "  } while(0);" + NL + "/* Debug Log Message */" + NL + "  DiskStatus =  ";
  protected final String TEXT_48 = "_lFindDiskStatus();" + NL + "  ERROR(GID_";
  protected final String TEXT_49 = ",Status,0,0);" + NL + "  FUNCTION_EXIT(GID_";
  protected final String TEXT_50 = ", (uint32_t)";
  protected final String TEXT_51 = "_FUNCTION_EXIT);" + NL + "  return DiskStatus;" + NL + "}" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_52 = "_API_2>>>*/" + NL + "/*" + NL + " * The function gets the status of the card whether the card is initialized," + NL + " * inserted or write protected." + NL + " */" + NL + "uint8_t ";
  protected final String TEXT_53 = "_GetStatus(void)" + NL + "{" + NL + "  uint8_t  DiskStatus;" + NL + "  FUNCTION_ENTRY(GID_";
  protected final String TEXT_54 = ",(uint32_t)";
  protected final String TEXT_55 = "_FUNCTION_ENTRY);" + NL + "  DiskStatus  = ";
  protected final String TEXT_56 = "_Initialize();" + NL + "  FUNCTION_EXIT(GID_";
  protected final String TEXT_57 = ", (uint32_t)";
  protected final String TEXT_58 = "_FUNCTION_EXIT);" + NL + "  return DiskStatus;" + NL + "}" + NL + "" + NL + "/* <<<DD_";
  protected final String TEXT_59 = "_API_3>>>*/" + NL + "/*" + NL + " * The function reads the data from the card." + NL + " */" + NL + "uint32_t ";
  protected final String TEXT_60 = "_ReadBlock" + NL + "(" + NL + "  uint8_t *ReadBuf," + NL + "  uint32_t SectorNumber," + NL + "  uint8_t  SectorCount" + NL + ")" + NL + "{" + NL + "  status_t Status;" + NL + "  uint8_t DiskStatus;" + NL + "  uint32_t Result;" + NL + "  FUNCTION_ENTRY(GID_";
  protected final String TEXT_61 = ", (uint32_t)";
  protected final String TEXT_62 = "_FUNCTION_ENTRY);" + NL + "/* Check the status before reading data */" + NL + "  DiskStatus = ";
  protected final String TEXT_63 = "_GetStatus();" + NL + "/*<<<DD_";
  protected final String TEXT_64 = "_API_3_1>>>*/" + NL + "  if ((DiskStatus & (uint8_t)";
  protected final String TEXT_65 = "_STA_NOINIT) != 0)" + NL + "  {" + NL + "    Result = ";
  protected final String TEXT_66 = "_RES_NOTRDY;" + NL + "    ERROR(GID_";
  protected final String TEXT_67 = ",Result,0,0);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "/*Check for single block read or multiple block read based on sector count */" + NL + "/*<<<DD_";
  protected final String TEXT_68 = "_API_3_2>>>*/" + NL + "    if (SectorCount == 1)" + NL + "    {" + NL + "      Status = ";
  protected final String TEXT_69 = "_CardReadSingleBlock( (uint32_t *)ReadBuf, SectorNumber);" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_70 = "_API_3_3>>>*/" + NL + "    else" + NL + "    {" + NL + "      Status = ";
  protected final String TEXT_71 = "_CardReadMultipleBlocks((uint32_t *)ReadBuf,SectorNumber, \\" + NL + "                                                SectorCount);" + NL + "    }/*End of \"if (SectorCount == 1)\"*/" + NL + "/*<<<DD_";
  protected final String TEXT_72 = "_API_3_4>>>*/" + NL + "    if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      Result = ";
  protected final String TEXT_73 = "_RES_OK;" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_74 = "_API_3_5>>>*/" + NL + "    else" + NL + "    {" + NL + "      Result = ";
  protected final String TEXT_75 = "_RES_ERROR;" + NL + "      ERROR(GID_";
  protected final String TEXT_76 = ",";
  protected final String TEXT_77 = "_SDMMC00x_ERROR,sizeof(int),Status);" + NL + "    }/* End of \"if (Status == (uint32_t)DAVEApp_SUCCESS)\"*/" + NL + "  }/* End of \" if ((DiskStatus & (uint8_t)STA_NOINIT) != 0)\"*/" + NL + "  FUNCTION_EXIT(GID_";
  protected final String TEXT_78 = ", (uint32_t)";
  protected final String TEXT_79 = "_FUNCTION_EXIT);" + NL + "  return Result;" + NL + "}" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_80 = "_API_4>>>*/" + NL + "/*" + NL + " * The function writes the data on the card." + NL + " */" + NL + "uint32_t ";
  protected final String TEXT_81 = "_WriteBlock" + NL + "(" + NL + "  const uint8_t *WriteBuf," + NL + "  uint32_t SectorNumber," + NL + "  uint8_t SectorCount" + NL + ")" + NL + "{" + NL + "  status_t Status ;" + NL + "  uint8_t DiskStatus;" + NL + "  uint32_t Result;" + NL + "  FUNCTION_ENTRY(GID_";
  protected final String TEXT_82 = ", (uint32_t)";
  protected final String TEXT_83 = "_FUNCTION_ENTRY);" + NL + "" + NL + "  do" + NL + "  {" + NL + "    DiskStatus = ";
  protected final String TEXT_84 = "_GetStatus ();" + NL + "/*<<<DD_";
  protected final String TEXT_85 = "_API_4_1>>>*/" + NL + "/* If the card is not initialized */" + NL + "    if ((DiskStatus & ";
  protected final String TEXT_86 = "_STA_NOINIT) != 0)" + NL + "    {" + NL + "      Result = ";
  protected final String TEXT_87 = "_RES_NOTRDY;" + NL + "      ERROR(GID_";
  protected final String TEXT_88 = ",Result,0,0);" + NL + "      break;" + NL + "    }/* End of \"if ((DiskStatus & ";
  protected final String TEXT_89 = "_STA_NOINIT) != 0)\"*/" + NL + "/* If the card is read only or write protected */" + NL + "/*<<<DD_";
  protected final String TEXT_90 = "_API_4_2>>>*/" + NL + "    if ((DiskStatus & ";
  protected final String TEXT_91 = "_STA_PROTECT) != 0)" + NL + "    {" + NL + "      Result = ";
  protected final String TEXT_92 = "_RES_WRPRT;" + NL + "      ERROR(GID_";
  protected final String TEXT_93 = ",Result,0,0);" + NL + "      break;" + NL + "    }/* End of \"if ((DiskStatus & ";
  protected final String TEXT_94 = "_STA_PROTECT) != 0)\"*/" + NL + "/*Check for single block write or multiple block write.*/" + NL + "/*<<<DD_";
  protected final String TEXT_95 = "_API_4_3>>>*/" + NL + "    if (SectorCount == 1)" + NL + "    {" + NL + "      Status = ";
  protected final String TEXT_96 = "_CardWriteSingleBlock((uint32_t *)WriteBuf, SectorNumber);" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_97 = "_API_4_4>>>*/" + NL + "    else" + NL + "    {" + NL + "      Status = ";
  protected final String TEXT_98 = "_CardWriteMultipleBlocks((uint32_t *)WriteBuf,\\" + NL + "                                                 SectorNumber, SectorCount );" + NL + "    } /* End of \"if (SectorCount == 1)\"*/" + NL + "/*<<<DD_";
  protected final String TEXT_99 = "_API_4_5>>>*/" + NL + "    if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      Result = ";
  protected final String TEXT_100 = "_RES_OK;" + NL + "    }" + NL + "/*<<<DD_";
  protected final String TEXT_101 = "_API_4_6>>>*/" + NL + "    else" + NL + "    {" + NL + "      Result = ";
  protected final String TEXT_102 = "_RES_ERROR;" + NL + "      ERROR(GID_";
  protected final String TEXT_103 = ",";
  protected final String TEXT_104 = "_SDMMC00x_ERROR,0,0);" + NL + "    } /* End of \"if (Status == (uint32_t)DAVEApp_SUCCESS)\"*/" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_";
  protected final String TEXT_105 = ", (uint32_t)";
  protected final String TEXT_106 = "_FUNCTION_EXIT);" + NL + "  return Result;" + NL + "}" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_107 = "_API_5>>>*/" + NL + "/*" + NL + " * The function performs the various IOCTL operation." + NL + " */" + NL + "uint32_t ";
  protected final String TEXT_108 = "_Ioctl" + NL + "(" + NL + "  uint8_t Command," + NL + "  void *Buffer" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)";
  protected final String TEXT_109 = "_ERROR;" + NL + "  uint8_t DiskStatus;" + NL + "  uint32_t Result;";
  protected final String TEXT_110 = NL + "  ";
  protected final String TEXT_111 = "_EraseAddrType *ErasePtr;" + NL + "  const ";
  protected final String TEXT_112 = "_PasswdType *PasswdPtr;";
  protected final String TEXT_113 = NL + "  ";
  protected final String TEXT_114 = "_LocalLockStructType LockStruct = {0};" + NL + "  FUNCTION_ENTRY(GID_";
  protected final String TEXT_115 = ", (uint32_t)";
  protected final String TEXT_116 = "_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    DiskStatus = ";
  protected final String TEXT_117 = "_GetStatus();" + NL + "/*<<<DD_";
  protected final String TEXT_118 = "_API_5_1>>>*/" + NL + "/* If card is not initialized or inserted */" + NL + "    if ((DiskStatus & (uint8_t)";
  protected final String TEXT_119 = "_STA_NOINIT) != 0)" + NL + "    {" + NL + "      if (";
  protected final String TEXT_120 = "_LockFlag == 1UL)" + NL + "      {" + NL + "        Status = (uint32_t)";
  protected final String TEXT_121 = "_DISK_LOCKED;" + NL + "        if ( (Command != ";
  protected final String TEXT_122 = "_MMC_UNLOCK_CARD) &&" + NL + "           (Command != ";
  protected final String TEXT_123 = "_MMC_SET_PASSWD) &&" + NL + "           (Command != ";
  protected final String TEXT_124 = "_MMC_CLEAR_PASSWD) &&" + NL + "           (Command != ";
  protected final String TEXT_125 = "_MMC_SET_LOCK) &&" + NL + "           (Command != ";
  protected final String TEXT_126 = "_MMC_READ_LOCK_STATUS) &&" + NL + "           (Command != ";
  protected final String TEXT_127 = "_MMC_FORCE_ERASE) &&" + NL + "           (Command != ";
  protected final String TEXT_128 = "_CTRL_EJECT) )" + NL + "        {" + NL + "          ERROR(GID_SDMMC001,Status,0,0);" + NL + "          break;" + NL + "        }" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        Status = (uint32_t)";
  protected final String TEXT_129 = "_RES_NOTRDY;" + NL + "        ERROR(GID_SDMMC001,Status,0,0);" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "/* Switch to the respective IOCTL command */" + NL + "    switch (Command)" + NL + "    {" + NL + "/*<<<DD_";
  protected final String TEXT_130 = "_API_5_2>>>*/" + NL + "      case ";
  protected final String TEXT_131 = "_CTRL_SYNC:" + NL + "        Status = ";
  protected final String TEXT_132 = "_FlushDiskWriteCache();" + NL + "        break;" + NL + "" + NL + "      case ";
  protected final String TEXT_133 = "_GET_SECTOR_SIZE:" + NL + "        Status = ";
  protected final String TEXT_134 = "_GetSectorSize(Buffer);" + NL + "\t\tbreak;" + NL + "\t\t " + NL + "/*<<<DD_";
  protected final String TEXT_135 = "_API_5_3>>>*/" + NL + "      case ";
  protected final String TEXT_136 = "_GET_SECTOR_COUNT:" + NL + "        Status = ";
  protected final String TEXT_137 = "_GetSectorCount( Buffer );" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_138 = "_API_5_4>>>*/" + NL + "      case ";
  protected final String TEXT_139 = "_CTRL_ERASE_SECTOR:" + NL + "        ErasePtr = (";
  protected final String TEXT_140 = "_EraseAddrType *) Buffer;" + NL + "        Status = ";
  protected final String TEXT_141 = "_EraseBlock( (ErasePtr->StartAddress)," + NL + "                                      (ErasePtr->EndAddress));" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_142 = "_API_5_5>>>*/" + NL + "      case ";
  protected final String TEXT_143 = "_GET_BLOCK_SIZE:" + NL + "        Status = ";
  protected final String TEXT_144 = "_GetBlockSize(Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_145 = "_API_5_6>>>*/" + NL + "      case ";
  protected final String TEXT_146 = "_MMC_GET_TYPE:" + NL + "        Status = ";
  protected final String TEXT_147 = "_GetCardType(Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_148 = "_API_5_7>>>*/" + NL + "      case ";
  protected final String TEXT_149 = "_MMC_GET_CSD:" + NL + "        Status = ";
  protected final String TEXT_150 = "_GetCsd(Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_151 = "_API_5_8>>>*/" + NL + "      case ";
  protected final String TEXT_152 = "_MMC_GET_CID:" + NL + "        Status = ";
  protected final String TEXT_153 = "_GetCid(Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_154 = "_API_5_8>>>*/" + NL + "      case ";
  protected final String TEXT_155 = "_MMC_GET_OCR:" + NL + "        Status = ";
  protected final String TEXT_156 = "_GetOcr(Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_157 = "_API_5_10>>>*/" + NL + "      case ";
  protected final String TEXT_158 = "_MMC_GET_SDSTAT:" + NL + "        Status = ";
  protected final String TEXT_159 = "_GetSdStatus(Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_160 = "_API_5_11>>>*/" + NL + "      case ";
  protected final String TEXT_161 = "_MMC_LOCK_CARD:" + NL + "        LockStruct.Mode = 0x04UL;" + NL + "        PasswdPtr = (const ";
  protected final String TEXT_162 = "_PasswdType *)Buffer;" + NL + "        /* Check password length doesn't exceeds the permitted length */" + NL + "        /*<<<DD_";
  protected final String TEXT_163 = "_API_5_11_1>>>*/" + NL + "        if( PasswdPtr->OldPwdLength > ";
  protected final String TEXT_164 = "_MAX_PASSWD_LEN )" + NL + "        {" + NL + "          break;" + NL + "        }" + NL + "        LockStruct.PwdLen = PasswdPtr->OldPwdLength;" + NL + "        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \\" + NL + "               (uint32_t)LockStruct.PwdLen);" + NL + "        Status = ";
  protected final String TEXT_165 = "_LockUnlockCard(&LockStruct, ";
  protected final String TEXT_166 = "_LOCK);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_167 = "_API_5_12>>>*/" + NL + "      case ";
  protected final String TEXT_168 = "_MMC_UNLOCK_CARD:" + NL + "        LockStruct.Mode = 0x00UL;" + NL + "        PasswdPtr = (const ";
  protected final String TEXT_169 = "_PasswdType *)Buffer;" + NL + "        /* Check password length doesn't exceeds the permitted length */" + NL + "        /*<<<DD_";
  protected final String TEXT_170 = "_API_5_12_1>>>*/" + NL + "        if( PasswdPtr->OldPwdLength > ";
  protected final String TEXT_171 = "_MAX_PASSWD_LEN )" + NL + "        {" + NL + "          break;" + NL + "        }" + NL + "        LockStruct.PwdLen = PasswdPtr->OldPwdLength;" + NL + "        memcpy(LockStruct.PwdData,PasswdPtr->OldPassword, LockStruct.PwdLen);" + NL + "        Status  = ";
  protected final String TEXT_172 = "_LockUnlockCard(&LockStruct,  \\";
  protected final String TEXT_173 = NL + "                                          ";
  protected final String TEXT_174 = "_UNLOCK);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_175 = "_API_5_13>>>*/" + NL + "      case ";
  protected final String TEXT_176 = "_MMC_SET_PASSWD:" + NL + "/*Fill the local lock structure with the information provided*/" + NL + "        LockStruct.Mode  = 0x01UL;" + NL + "        PasswdPtr = (const ";
  protected final String TEXT_177 = "_PasswdType *)Buffer;" + NL + "        /* Check password length doesn't exceeds the permitted length */" + NL + "        /*<<<DD_";
  protected final String TEXT_178 = "_API_5_13_1>>>*/" + NL + "        if( (PasswdPtr->OldPwdLength > ";
  protected final String TEXT_179 = "_MAX_PASSWD_LEN) ||" + NL + "            (PasswdPtr->NewPwdLength > ";
  protected final String TEXT_180 = "_MAX_PASSWD_LEN ))" + NL + "        {" + NL + "          break;" + NL + "        }" + NL + "        LockStruct.PwdLen = PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;" + NL + "" + NL + "        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \\" + NL + "                PasswdPtr->OldPwdLength );" + NL + "        memcpy(LockStruct.PwdData + PasswdPtr->OldPwdLength, \\" + NL + "               PasswdPtr->NewPassword, PasswdPtr->NewPwdLength );" + NL + "" + NL + "        Status = ";
  protected final String TEXT_181 = "_LockUnlockCard(&LockStruct, \\";
  protected final String TEXT_182 = NL + "                                          ";
  protected final String TEXT_183 = "_UNLOCK);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_184 = "_API_5_14>>>*/" + NL + "      case ";
  protected final String TEXT_185 = "_MMC_CLEAR_PASSWD:" + NL + "        LockStruct.Mode  = 0x02UL;" + NL + "        PasswdPtr = (const ";
  protected final String TEXT_186 = "_PasswdType *)Buffer;" + NL + "        /* Check password length doesn't exceeds the permitted length */" + NL + "        /*<<<DD_";
  protected final String TEXT_187 = "_API_5_14_1>>>*/" + NL + "        if( PasswdPtr->OldPwdLength > ";
  protected final String TEXT_188 = "_MAX_PASSWD_LEN )" + NL + "        {" + NL + "          break;" + NL + "        }" + NL + "        LockStruct.PwdLen =  PasswdPtr->OldPwdLength;" + NL + "        memcpy(LockStruct.PwdData, PasswdPtr ->OldPassword, \\" + NL + "               LockStruct.PwdLen);" + NL + "        Status = ";
  protected final String TEXT_189 = "_LockUnlockCard(&LockStruct,";
  protected final String TEXT_190 = "_UNLOCK);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_191 = "_API_5_15>>>*/" + NL + "      case ";
  protected final String TEXT_192 = "_MMC_SET_LOCK:" + NL + "        LockStruct.Mode  = 0x05UL;" + NL + "        PasswdPtr = (const ";
  protected final String TEXT_193 = "_PasswdType *)Buffer;" + NL + "        /*<<<DD_";
  protected final String TEXT_194 = "_API_5_15_1>>>*/" + NL + "        /* Check password length doesn't exceeds the permitted length */" + NL + "        if( PasswdPtr->OldPwdLength > ";
  protected final String TEXT_195 = "_MAX_PASSWD_LEN )" + NL + "        {" + NL + "          break;" + NL + "        }" + NL + "        LockStruct.PwdLen =  PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;" + NL + "        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword,PasswdPtr->OldPwdLength );" + NL + "        memcpy(LockStruct.PwdData + PasswdPtr->OldPwdLength, \\" + NL + "                       PasswdPtr->NewPassword, PasswdPtr->NewPwdLength );" + NL + "        Status  = ";
  protected final String TEXT_196 = "_LockUnlockCard(&LockStruct, ";
  protected final String TEXT_197 = "_LOCK);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_198 = "_API_5_16>>>*/" + NL + "      case ";
  protected final String TEXT_199 = "_MMC_READ_LOCK_STATUS:" + NL + "        Status = ";
  protected final String TEXT_200 = "_GetLockStatus((uint32_t *)Buffer);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_201 = "_API_5_17>>>*/" + NL + "      case ";
  protected final String TEXT_202 = "_MMC_FORCE_ERASE:" + NL + "        LockStruct.Mode = 0x08UL;" + NL + "        Status = ";
  protected final String TEXT_203 = "_LockUnlockCard(&LockStruct, ";
  protected final String TEXT_204 = "_UNLOCK);" + NL + "        break;" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_205 = "_API_5_18>>>*/" + NL + "      case ";
  protected final String TEXT_206 = "_CTRL_EJECT:" + NL + "        Status = ";
  protected final String TEXT_207 = "_EjectCard();" + NL + "        break;" + NL + "" + NL + "      default:" + NL + "        Result = ";
  protected final String TEXT_208 = "_RES_PARERR;" + NL + "        break;" + NL + "     }" + NL + "  } while (0);" + NL + "" + NL + "/*<<<DD_";
  protected final String TEXT_209 = "_API_5_18>>>*/" + NL + "  if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    Result = ";
  protected final String TEXT_210 = "_RES_OK;" + NL + "  }" + NL + "/*<<<DD_";
  protected final String TEXT_211 = "_API_5_19>>>*/" + NL + "  else" + NL + "  {" + NL + "    Result = ";
  protected final String TEXT_212 = "_RES_ERROR;" + NL + "    ERROR(GID_";
  protected final String TEXT_213 = ",";
  protected final String TEXT_214 = "_SDMMC00x_ERROR,sizeof(int),Status);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_";
  protected final String TEXT_215 = ", (uint32_t)";
  protected final String TEXT_216 = "_FUNCTION_EXIT);" + NL + "  return Result;" + NL + "}" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL + NL + NL + NL;
  protected final String TEXT_217 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/sdmmc001/"; 
     int appInst = 0; 
     int RTOS = app.getIntegerValue(AppBaseuri + appInst + "/sdmmc001_rtos_present");
   String  Module_Name = "SDMMC001";
   String  Lld_Module_Name = "SDMMC003";

    stringBuffer.append(TEXT_2);
     
  if (RTOS == 1)
  {
  	Lld_Module_Name = "SDMMC004";
    Module_Name = "SDMMC002";
  }
  else
  {
    Module_Name = "SDMMC001";
    Lld_Module_Name = "SDMMC003";
  }

    stringBuffer.append(TEXT_3);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_4);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_5);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_6);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_7);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_8);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_9);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_10);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_11);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_12);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_13);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_14);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_15);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_16);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_17);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_18);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_19);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_20);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_21);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_22);
    stringBuffer.append( Lld_Module_Name);
    stringBuffer.append(TEXT_23);
    stringBuffer.append(TEXT_24);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_25);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_26);
    stringBuffer.append( Lld_Module_Name);
    stringBuffer.append(TEXT_27);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_28);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_29);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_30);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_31);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_32);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_33);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_34);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_35);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_36);
    stringBuffer.append(TEXT_37);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_38);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_39);
    stringBuffer.append( Lld_Module_Name);
    stringBuffer.append(TEXT_40);
    stringBuffer.append( Lld_Module_Name);
    stringBuffer.append(TEXT_41);
    stringBuffer.append( Lld_Module_Name);
    stringBuffer.append(TEXT_42);
    stringBuffer.append( Lld_Module_Name);
    stringBuffer.append(TEXT_43);
    stringBuffer.append(TEXT_44);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_45);
    stringBuffer.append(TEXT_46);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_47);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_48);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_49);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_50);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_51);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_52);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_53);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_54);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_55);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_56);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_57);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_58);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_59);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_60);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_61);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_62);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_63);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_64);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_65);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_66);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_67);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_68);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_69);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_70);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_71);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_72);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_73);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_74);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_75);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_76);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_77);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_78);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_79);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_80);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_81);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_82);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_83);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_84);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_85);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_86);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_87);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_88);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_89);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_90);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_91);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_92);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_93);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_94);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_95);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_96);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_97);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_98);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_99);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_100);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_101);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_102);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_103);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_104);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_105);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_106);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_107);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_108);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_109);
    stringBuffer.append(TEXT_110);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_111);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_112);
    stringBuffer.append(TEXT_113);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_114);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_115);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_116);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_117);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_118);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_119);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_120);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_121);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_122);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_123);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_124);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_125);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_126);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_127);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_128);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_129);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_130);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_131);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_132);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_133);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_134);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_135);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_136);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_137);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_138);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_139);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_140);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_141);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_142);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_143);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_144);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_145);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_146);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_147);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_148);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_149);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_150);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_151);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_152);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_153);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_154);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_155);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_156);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_157);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_158);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_159);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_160);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_161);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_162);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_163);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_164);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_165);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_166);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_167);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_168);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_169);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_170);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_171);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_172);
    stringBuffer.append(TEXT_173);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_174);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_175);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_176);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_177);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_178);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_179);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_180);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_181);
    stringBuffer.append(TEXT_182);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_183);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_184);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_185);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_186);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_187);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_188);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_189);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_190);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_191);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_192);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_193);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_194);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_195);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_196);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_197);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_198);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_199);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_200);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_201);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_202);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_203);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_204);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_205);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_206);
    stringBuffer.append(Lld_Module_Name);
    stringBuffer.append(TEXT_207);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_208);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_209);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_210);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_211);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_212);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_213);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_214);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_215);
    stringBuffer.append( Module_Name);
    stringBuffer.append(TEXT_216);
    stringBuffer.append(TEXT_217);
    return stringBuffer.toString();
  }
}
