package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class rtc001c_template
{
  protected static String nl;
  public static synchronized rtc001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    rtc001c_template result = new rtc001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[RTC001.c]*/" + NL + "" + NL + " /*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without**" + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Feb 12, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Author(s) Identity                                    **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** RP        App Developer                                                    **" + NL + "**                                                                            **" + NL + "*******************************************************************************/";
  protected final String TEXT_2 = " " + NL;
  protected final String TEXT_3 = NL + NL + "/**" + NL + " * @file RTC001.c" + NL + " *" + NL + " * @App Version RTC001 <";
  protected final String TEXT_4 = ">" + NL + " *" + NL + " * @brief  Real Time Clock App Implementation." + NL + " *" + NL + " */" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL;
  protected final String TEXT_5 = NL + "/* Inclusion of header file */" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_6 = NL;
  protected final String TEXT_7 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_8 = "                  " + NL + " " + NL + "#define APP_GID DBG002_GID_RTC001" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/";
  protected final String TEXT_9 = NL + "/** " + NL + " * Note: This part of the code will be generated if Software Timer is" + NL + " *       enabled. This part is not reviewed and tested" + NL + " **/" + NL + "/**" + NL + " * This enumerates the timer state." + NL + " */" + NL + "typedef enum RTC001_TimerStateType{" + NL + "/**" + NL + " * The timer is in running state" + NL + " */" + NL + "  TIMER_STATE_RUNNING," + NL + "/**" + NL + "  * The timer is stopped" + NL + " */" + NL + "  TIMER_STATE_STOPPED " + NL + "}RTC001_TimerStateType;";
  protected final String TEXT_10 = NL + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/";
  protected final String TEXT_11 = "\t\t" + NL + " /** " + NL + "  * Note: This part of the code will be generated if Software Timer is" + NL + "  *       enabled. This part is not reviewed and tested" + NL + "  **/" + NL + "/*" + NL + " * This function is called to insert a timer into the timer list.  " + NL + " *        " + NL + " * @param[in]  Index Timer ID" + NL + " * @return     none" + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static void  RTC001_lInsertTimerList (uint32_t Index);" + NL + "" + NL + "" + NL + "/*" + NL + " * This function is called to remove a timer from the timer list. " + NL + " *              " + NL + " * @param[in]  Index Timer ID" + NL + " * @return     none" + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static void  RTC001_lRemoveTimerList(uint32_t Index);" + NL + "" + NL + "/*" + NL + " * Handler function called from Seconds event handler. " + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static void  RTC001_lTimerHandler (void);" + NL + " " + NL + "/*" + NL + " * Time event handler " + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static void RTC001_SecondsEvent_Handler(uint32_t CbArg);";
  protected final String TEXT_12 = NL + NL + "/*" + NL + " * Function to check whether the date is valid" + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static uint32_t RTC001_ldatevalid(uint16_t m, uint16_t d, uint16_t y);" + NL + "" + NL + "" + NL + "/*" + NL + " * Function to calculate day of the week" + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static uint32_t RTC001_lweekday(uint16_t m, uint16_t d, uint16_t y);" + NL + "" + NL + "/*" + NL + " *  Initialization function for the app. Configures the registers" + NL + " *  based on options selected in UI." + NL + " *" + NL + " * @return     void" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " */" + NL + "static void  RTC001_lInit(const RTC001_HandleType* Handle);" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/";
  protected final String TEXT_13 = NL + "/** " + NL + " * Note: This part of the code will be generated if Software Timer is" + NL + " *       enabled. This part is not reviewed and tested" + NL + " **/" + NL + "/** Table which save timer control block. */" + NL + "RTC001_TimerObject    RTC001_TimerTbl[RTC001_CFG_MAX_TMR] = {{0}};" + NL + "" + NL + "/** The header of the TimerCtrl list.      */" + NL + "RTC001_TimerObject*  RTC001_TimerList = 0; " + NL + "" + NL + "/**   Timer ID Tracker  */" + NL + "uint32_t       RTC001_TimerTracker = 0;";
  protected final String TEXT_14 = NL + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "const uint32_t RTC001_DAYS_IN_MONTH[13] =" + NL + "{" + NL + "   /* Index from 1, hence skip 0*/" + NL + "    0U," + NL + "    /*Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec*/" + NL + "       31U,28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U" + NL + "};" + NL + "#define RTC001_DAYS_IN_AN_YEAR     (365U)" + NL + "#define RTC001_SECONDS_IN_A_DAY    (24U * 60U * 60U)" + NL + "#define RTC001_SECONDS_IN_AN_HOUR  (60U * 60U)" + NL + "#define RTC001_SECONDS_IN_A_MINUTE (60U)" + NL + "#define RTC001_EPOCH_YEAR          (1970U)" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + " ";
  protected final String TEXT_15 = "\t\t\t\t\t" + NL + " /** " + NL + "  * Note: This part of the code will be generated if Software Timer is" + NL + "  *       enabled. This part is not reviewed and tested" + NL + "  **/" + NL + "/*" + NL + " * This function is called to insert a timer into the timer list." + NL + " */" + NL + "static void  RTC001_lInsertTimerList (uint32_t Index)" + NL + "{" + NL + "  /* <<<DD_RTC001_PRIV_API_1>>> */" + NL + "  RTC001_TimerObject* TmrObjPtr;" + NL + "  int32_t DeltaTicks;" + NL + "  uint32_t TempTmrCnt;" + NL + "   /* Get timer time */" + NL + "  TempTmrCnt = RTC001_TimerTbl[Index].TimerCount;" + NL + "  /* Check if timer count is zero */" + NL + "  /* <<<DD_RTC001_PRIV _API_1>>> */" + NL + "  do" + NL + "  {" + NL + "    if(TempTmrCnt == 0)                  " + NL + "    {" + NL + "      break;                                          " + NL + "    }" + NL + "    /* Check if Timer list is NULL */" + NL + "    if(RTC001_TimerList == NULL)                " + NL + "    {" + NL + "      /* Set this as first Timer */" + NL + "        RTC001_TimerList = &RTC001_TimerTbl[Index];       " + NL + "    }" + NL + "    /* IF Not, find the correct place ,and insert the specified timer */" + NL + "    else                  " + NL + "    {\t\t\t\t\t\t\t\t    " + NL + "      TmrObjPtr = RTC001_TimerList; " + NL + "      /* Get timer tick */" + NL + "      DeltaTicks = (int32_t)TempTmrCnt;           " + NL + "      /* Find correct place for inserting the timer */" + NL + "      while(TmrObjPtr != NULL)" + NL + "      {\t\t\t\t    " + NL + "        /* Get timer Count Difference  */" + NL + "        DeltaTicks -= (int32_t)TmrObjPtr->TimerCount;" + NL + "        /* Is delta ticks<0? */" + NL + "        if(DeltaTicks < 0)            " + NL + "        {\t" + NL + "          /*  Check If head item */" + NL + "          if(TmrObjPtr->TimerPrev!= NULL)" + NL + "          {\t" + NL + "            /* If Insert to list */" + NL + "            TmrObjPtr->TimerPrev->TimerNext = &RTC001_TimerTbl[Index]; " + NL + "            RTC001_TimerTbl[Index].TimerPrev = TmrObjPtr->TimerPrev;" + NL + "            RTC001_TimerTbl[Index].TimerNext = TmrObjPtr;" + NL + "            TmrObjPtr->TimerPrev = &RTC001_TimerTbl[Index];" + NL + "          }" + NL + "          else                    \t" + NL + "          { " + NL + "            /* Set Timer as first item */" + NL + "            RTC001_TimerTbl[Index].TimerNext = RTC001_TimerList;" + NL + "            RTC001_TimerList->TimerPrev = &RTC001_TimerTbl[Index];" + NL + "            RTC001_TimerList = &RTC001_TimerTbl[Index];" + NL + "          }" + NL + "          RTC001_TimerTbl[Index].TimerCount = RTC001_TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;  " + NL + "          RTC001_TimerTbl[Index].TimerNext->TimerCount  -= RTC001_TimerTbl[Index].TimerCount; " + NL + "          break;\t" + NL + "        }" + NL + "        /* Is last item in list? */\t\t\t\t\t\t\t\t\t" + NL + "        else " + NL + "        {\t" + NL + "          if((DeltaTicks >= 0) && (TmrObjPtr->TimerNext == NULL))" + NL + "          {" + NL + "            /* Yes,insert into */" + NL + "            RTC001_TimerTbl[Index].TimerPrev = TmrObjPtr;" + NL + "            TmrObjPtr->TimerNext = &RTC001_TimerTbl[Index];\t" + NL + "            RTC001_TimerTbl[Index].TimerCount = (uint32_t)DeltaTicks;" + NL + "            break;" + NL + "          }" + NL + "        }" + NL + "        /* Get the next item in timer list    */\t" + NL + "        TmrObjPtr = TmrObjPtr->TimerNext;      " + NL + "      }" + NL + "    }" + NL + "  }while(0);" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is called to remove a timer from the timer list. " + NL + " */" + NL + "static void  RTC001_lRemoveTimerList(uint32_t Index)" + NL + "{" + NL + "  /* <<<DD_RTC001_PRIV_API_2>>> */" + NL + "  RTC001_TimerObject* TmrObjPtr;" + NL + "  TmrObjPtr = &RTC001_TimerTbl[Index];" + NL + "  /* Check whether only one timer available */" + NL + "  /* <<<DD_RTC001_PRIV _API_2>>> */" + NL + "  if((TmrObjPtr->TimerPrev == NULL) && (TmrObjPtr->TimerNext == NULL))" + NL + "  {\t\t" + NL + "    /* set timer list as NULL */ " + NL + "    RTC001_TimerList = NULL;                 \t" + NL + "  }" + NL + "   /* Check if the first item in timer list   */" + NL + "  else if(TmrObjPtr->TimerPrev == NULL)     " + NL + "  {   " + NL + "    /* Remove timer from list,and reset timer list */" + NL + "    RTC001_TimerList  = TmrObjPtr->TimerNext;" + NL + "    RTC001_TimerList->TimerPrev = NULL;" + NL + "    TmrObjPtr->TimerNext->TimerCount += TmrObjPtr->TimerCount;" + NL + "    TmrObjPtr->TimerNext    = NULL;  " + NL + "  }" + NL + "  /* Check if the last item in timer list   */" + NL + "  else if(TmrObjPtr->TimerNext == NULL)      " + NL + "  {" + NL + "    /* Remove timer from list */" + NL + "    TmrObjPtr->TimerPrev->TimerNext = NULL;\t" + NL + "    TmrObjPtr->TimerPrev = NULL;" + NL + "  }" + NL + "  else                                /*  remove timer from list         */" + NL + "  {" + NL + "    /*  Remove timer from list */" + NL + "    TmrObjPtr->TimerPrev->TimerNext  =  TmrObjPtr->TimerNext;" + NL + "    TmrObjPtr->TimerNext->TimerPrev  =  TmrObjPtr->TimerPrev;" + NL + "    TmrObjPtr->TimerNext->TimerCount  += TmrObjPtr->TimerCount;" + NL + "    TmrObjPtr->TimerNext = NULL;" + NL + "    TmrObjPtr->TimerPrev = NULL;" + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " * Handler function  called from RTC event handler. " + NL + " */" + NL + "static void  RTC001_lTimerHandler (void)" + NL + "{" + NL + "  /* <<<DD_RTC001_PRIV_API_3>>> */" + NL + "  RTC001_TimerObject* TmrObjPtr;" + NL + "   /* Get first item of timer list       */" + NL + "  TmrObjPtr = RTC001_TimerList;         " + NL + "  /* <<<DD_RTC001_PRIV _API_3>>> */  " + NL + "  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0) )" + NL + "  {\t" + NL + "    /* Check whether timer is a one shot timer */" + NL + "    if(TmrObjPtr->TimerType == RTC001_ONE_SHOT)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list */" + NL + "      RTC001_lRemoveTimerList(TmrObjPtr->TimerID);" + NL + "      /* Set timer status as TIMER_STATE_STOPPED */" + NL + "      TmrObjPtr->TimerState = TIMER_STATE_STOPPED;" + NL + "      /* Call timer callback function */" + NL + "      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);" + NL + "    }" + NL + "    /* Check whether timer is RTC001_PERIODIC */" + NL + "    else if(TmrObjPtr->TimerType == RTC001_PERIODIC)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list */" + NL + "      RTC001_lRemoveTimerList(TmrObjPtr->TimerID);" + NL + "      /* Reset timer tick             */" + NL + "      TmrObjPtr->TimerCount = TmrObjPtr->TimerReload;" + NL + "      /* Insert timer into timer list */" + NL + "      RTC001_lInsertTimerList(TmrObjPtr->TimerID);" + NL + "      /* Call timer callback function */" + NL + "      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Get first item of timer list */" + NL + "      TmrObjPtr = RTC001_TimerList;\t                      " + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Event Handler " + NL + " */" + NL + "" + NL + "static void RTC001_SecondsEvent_Handler(uint32_t CbArg)" + NL + "{ " + NL + "  /* <<<DD_RTC001_PRIV_API_4>>> */" + NL + "  RTC001_TimerObject* TmrObjPtr;" + NL + "" + NL + "  TmrObjPtr = RTC001_TimerList;" + NL + "  /* <<<DD_RTC001_PRIV _API_4>>> */" + NL + "  do" + NL + "  {" + NL + "    if(TmrObjPtr == NULL)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      if(TmrObjPtr->TimerCount >= 1)" + NL + "      {" + NL + "        TmrObjPtr->TimerCount--;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        RTC001_lTimerHandler();" + NL + "      }" + NL + "    }" + NL + "  }while(0);" + NL + "}";
  protected final String TEXT_16 = NL + NL + "/*" + NL + " *  Initialization function for the app. Configures the registers" + NL + " *  based on options selected in UI." + NL + " */ " + NL + "" + NL + "static void  RTC001_lInit(const RTC001_HandleType* Handle)" + NL + "{" + NL + "" + NL + "  status_t status = (uint32_t) DAVEApp_SUCCESS;  ";
  protected final String TEXT_17 = NL + "  uint32_t DelayCount = 0x3FFUL;";
  protected final String TEXT_18 = "\t  " + NL + "   /* <<<DD_RTC001_API_1>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY); " + NL + "   ";
  protected final String TEXT_19 = NL + "  /* To disable gating for RTC : RTC Gating Clear  */ " + NL + "  WR_REG(SCU_CLK->CLKCR,SCU_CLK_CLKCR_CNTADJ_Msk,SCU_CLK_CLKCR_CNTADJ_Pos,DelayCount);" + NL + "  SCU_GENERAL->PASSWD = 0x000000C0UL;" + NL + "  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_RTC_Pos);" + NL + "  while(SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk);" + NL + "  SCU_GENERAL->PASSWD = 0x000000C3UL;";
  protected final String TEXT_20 = "\t  ";
  protected final String TEXT_21 = "\t\t\t\t\t   " + NL + "  /* Initialize the header of the list */" + NL + "  RTC001_TimerList     = NULL; " + NL + "  /*   Initialize timer tracker  */" + NL + "  RTC001_TimerTracker = 0;";
  protected final String TEXT_22 = NL + NL + "  /* Clear Mirror register update status of RTC registers in SCU*/" + NL + "  SCU_INTERRUPT->SRCLR = \\" + NL + "      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \\" + NL + "  \t\tSCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\\" + NL + "  \t\tSCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);" + NL + "  " + NL + "  if ((((RTC->CTR & RTC_CTR_ENB_Msk) >> RTC_CTR_ENB_Pos) == 0U ) ||\\" + NL + "    (Handle->RTCInitOnce != 1U))" + NL + "  {" + NL + "     /* RTC disabled to set the time */" + NL + "     status = RTC001_Disable();" + NL + "     /*assert status = DAVEApp_SUCCESS*/" + NL + "     DBG002_I (status = DAVEApp_SUCCESS);" + NL + "     /* Calendar time and date set in RTC registers */" + NL + "     status |= RTC001_Clock_SetTime(&timeptr1);" + NL + "     /*assert status = DAVEApp_SUCCESS*/" + NL + "     DBG002_I (status = DAVEApp_SUCCESS);" + NL + "" + NL + "  }" + NL;
  protected final String TEXT_23 = "  " + NL + "  /* Enable the RTC module */" + NL + "  RTC->CTR |= ((uint32_t)(RTC_CTR_ENB_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;\t" + NL + "  " + NL + "\t";
  protected final String TEXT_24 = "\t";
  protected final String TEXT_25 = NL + "\t  ";
  protected final String TEXT_26 = "  " + NL + "\t  /*Enable wake up from hibernate mode on an RTC alarm event*/" + NL + "\t  RTC->CTR |= ((uint32_t)(RTC_CTR_TAE_Msk));  " + NL + "\t  /* Wait for Mirror register update and clear the update indication */" + NL + "\t  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "\t  {}" + NL + "\t  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;   " + NL + "\t  ";
  protected final String TEXT_27 = "    " + NL + "" + NL + "\t  /* Enable interrupt on alarm event  */" + NL + "\t  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MAI_Pos) & RTC_MSKSR_MAI_Msk);" + NL + "\t  ";
  protected final String TEXT_28 = " " + NL + "\t  ";
  protected final String TEXT_29 = "    " + NL + "" + NL + "\t  /* Enable interrupt on alarm event  */" + NL + "\t  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MAI_Pos) & RTC_MSKSR_MAI_Msk); " + NL + "\t  ";
  protected final String TEXT_30 = NL + "     ";
  protected final String TEXT_31 = " " + NL + "  /* Enable RTC alarm interrupt in SCU */" + NL + "  SCU_INTERRUPT->SRMSK |= SCU_INTERRUPT_SRMSK_AI_Msk;";
  protected final String TEXT_32 = " " + NL + "    ";
  protected final String TEXT_33 = " \t" + NL + "\t";
  protected final String TEXT_34 = "  " + NL + "  /*Enable wake up from hibernate mode on periodic second event*/" + NL + "  RTC->CTR |=((uint32_t)(RTC_CTR_ESEC_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;" + NL + "\t";
  protected final String TEXT_35 = NL + "  /*Enable wake up from hibernate mode on periodic minute event*/" + NL + "  RTC->CTR |=((uint32_t)(RTC_CTR_EMIC_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;" + NL + "\t";
  protected final String TEXT_36 = NL + "  /*Enable wake up from hibernate mode on periodic hour event*/" + NL + "  RTC->CTR |=((uint32_t)(RTC_CTR_EHOC_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;" + NL + "\t";
  protected final String TEXT_37 = NL + "  /*Enable wake up from hibernate mode on periodic day event*/" + NL + "  RTC->CTR |=((uint32_t)(RTC_CTR_EDAC_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;" + NL + "\t";
  protected final String TEXT_38 = NL + "  /*Enable wake up from hibernate mode on periodic month event*/" + NL + "  RTC->CTR |=((uint32_t)(RTC_CTR_EMOC_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;" + NL + "\t";
  protected final String TEXT_39 = NL + "  /*Enable wake up from hibernate mode on periodic year event*/" + NL + "  RTC->CTR |=((uint32_t)(RTC_CTR_EYEC_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;" + NL + "\t";
  protected final String TEXT_40 = NL + "  /*configure RTC prescaler*/" + NL + "  WR_REGHIB(RTC->CTR, RTC_CTR_DIV_Msk, RTC_CTR_DIV_Pos, \\" + NL + "           (uint32_t)Handle->DividerValue, SCU_INTERRUPT_SRRAW_RTC_CTR_Msk);\t   ";
  protected final String TEXT_41 = " \t    ";
  protected final String TEXT_42 = " " + NL + "  /*configure RTC prescaler*/ " + NL + "  WR_REG(RTC->CTR, RTC_CTR_DIV_Msk, RTC_CTR_DIV_Pos,(uint32_t)Handle->DividerValue);";
  protected final String TEXT_43 = " " + NL;
  protected final String TEXT_44 = "\t\t\t\t\t     " + NL + "\t/* Enable seconds when Software timer is enabled */" + NL + "  if(Handle->SoftwareTimerSel == SOFTWARE_TIMER_ENABLE)" + NL + "  {" + NL + "\t  RTC->MSKSR |= (((uint32_t)1U << RTC_MSKSR_MPSE_Pos) & RTC_MSKSR_MPSE_Msk);" + NL + "\t  ";
  protected final String TEXT_45 = " " + NL + "\t   NVIC_SCU001_RegisterCallback(NVIC_SCU001_PI,RTC001_SecondsEvent_Handler,0);" + NL + "\t  ";
  protected final String TEXT_46 = " " + NL + "\t   NVIC_SR101_RegisterCallback(NVIC_SR101_PI,RTC001_SecondsEvent_Handler,0);" + NL + "\t  ";
  protected final String TEXT_47 = NL + "  } " + NL + "  else" + NL + "  {" + NL + "\t";
  protected final String TEXT_48 = "\t\t\t\t\t" + NL + "  " + NL + "  /* Enable periodic seconds interrupt */" + NL + "  RTC->MSKSR |= (((uint32_t)1U << RTC_MSKSR_MPSE_Pos) & RTC_MSKSR_MPSE_Msk);";
  protected final String TEXT_49 = NL + "  " + NL + "  /* Enable periodic minutes interrupt */" + NL + "  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPMI_Pos) & RTC_MSKSR_MPMI_Msk);";
  protected final String TEXT_50 = NL + "  " + NL + "  /* Enable periodic hours interrupt */" + NL + "  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPHO_Pos) & RTC_MSKSR_MPHO_Msk);";
  protected final String TEXT_51 = NL + "  " + NL + "  /* Enable periodic days interrupt */" + NL + "  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPDA_Pos) & RTC_MSKSR_MPDA_Msk);";
  protected final String TEXT_52 = NL + "  " + NL + "  /* Enable periodic months interrupt */" + NL + "  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPMO_Pos) & RTC_MSKSR_MPMO_Msk);";
  protected final String TEXT_53 = NL + "  " + NL + "  /* Enable periodic years interrupt */" + NL + "  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPYE_Pos) & RTC_MSKSR_MPYE_Msk);";
  protected final String TEXT_54 = " \t";
  protected final String TEXT_55 = "  ";
  protected final String TEXT_56 = " " + NL + "  /* Enable RTC periodic interrupt in SCU */" + NL + "  SCU_INTERRUPT->SRMSK |= (uint32_t)SCU_INTERRUPT_SRMSK_PI_Msk;  ";
  protected final String TEXT_57 = "  ";
  protected final String TEXT_58 = " " + NL + "    " + NL + "  /* Register User defined Event Handler for Timer function */  ";
  protected final String TEXT_59 = " " + NL + "  NVIC_SCU001_RegisterCallback(NVIC_SCU001_PI,";
  protected final String TEXT_60 = ",0U);";
  protected final String TEXT_61 = " " + NL + "  NVIC_SR101_RegisterCallback(NVIC_SR101_PI,";
  protected final String TEXT_62 = ",0U);";
  protected final String TEXT_63 = NL + "  ";
  protected final String TEXT_64 = NL + "  }";
  protected final String TEXT_65 = NL + "      " + NL + "  /* Configure RTC alarm and register the call back function */  " + NL + "  status |= RTC001_ConfigAlarm(&RTC001_Handle,&Alarmptr1,";
  protected final String TEXT_66 = ",0U);";
  protected final String TEXT_67 = NL + "   " + NL + "  /* Configure RTC alarm (Call back function is NULL) */  " + NL + "  status |= RTC001_ConfigAlarm(&RTC001_Handle,&Alarmptr1,NULL,0U); ";
  protected final String TEXT_68 = " " + NL + "  if (status != (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID,status, 0, NULL);" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "" + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/** @ingroup RTC001_publicparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*" + NL + " *  Initialization function for the app. Configures the registers" + NL + " *  based on options selected in UI." + NL + " */" + NL + "void RTC001_Init()" + NL + "{" + NL + "\tRTC001_lInit(&RTC001_Handle);" + NL + "" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Deinitialization function which initializes the App internal data" + NL + " *  structures to default values. " + NL + " */" + NL + "void  RTC001_DeInit(void)" + NL + "{" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "   /* <<<DD_RTC001_API_2>>> */" + NL + "\t" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  The function enables the RTC module." + NL + " */" + NL + "status_t  RTC001_Enable(void)" + NL + "{" + NL + "  status_t status = (uint32_t) RTC001_ERROR;" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "   /* <<<DD_RTC001_API_3>>> */" + NL + " " + NL + "  /* Clear Mirror register update status of RTC registers in SCU*/" + NL + "  SCU_INTERRUPT->SRCLR |= (uint32_t)\\" + NL + "    (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk |\\" + NL + "  \tSCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\\" + NL + "  \t\t\t\t\t\t\t\tSCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);" + NL + "  /* Enable RTC module */" + NL + "  RTC->CTR |= (uint32_t)(RTC_CTR_ENB_Msk);" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;\t" + NL + "  " + NL + "  status = (uint32_t) DAVEApp_SUCCESS;\t" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  The function disables the RTC module." + NL + " */" + NL + " " + NL + "status_t  RTC001_Disable(void)\t" + NL + "{" + NL + "  status_t status = (uint32_t) RTC001_ERROR;" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "   /* <<<DD_RTC001_API_4>>> */" + NL + "" + NL + "  /* Disable the RTC module*/" + NL + "  RTC->CTR &= (uint32_t) (~(RTC_CTR_ENB_Msk));" + NL + "  /* Wait for Mirror register update and clear the update indication */" + NL + "  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) " + NL + "  {}" + NL + "  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;\t" + NL + "" + NL + "  /* Clear the RTC Time registers */";
  protected final String TEXT_69 = "  " + NL + "  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)" + NL + "  {}" + NL + "  RTC->TIM0 = 0x00000000U;" + NL + "  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)" + NL + "  {}" + NL + "  RTC->TIM1 = 0x00000000U;";
  protected final String TEXT_70 = " " + NL + "  while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk))!= 0x0U)" + NL + "  {}" + NL + "  RTC->TIM0 = 0x00000000U; " + NL + "  RTC->TIM1 = 0x00000000U;";
  protected final String TEXT_71 = "  " + NL + "  /* Clear the Alarm registers */";
  protected final String TEXT_72 = NL + "  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)" + NL + "  {}" + NL + "  RTC->ATIM0 = 0x00000000U;" + NL + "  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)" + NL + "  {}" + NL + "  RTC->ATIM1 = 0x00000000U; ";
  protected final String TEXT_73 = "  " + NL + "  while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk))!= 0x0U)" + NL + "  {}" + NL + "  RTC->ATIM0 = 0x00000000U;  " + NL + "  RTC->ATIM1 = 0x00000000U;";
  protected final String TEXT_74 = "\t" + NL + "  /* Clear Mirror register update status of RTC registers in SCU*/" + NL + "  SCU_INTERRUPT->SRCLR |= (uint32_t)\\" + NL + "    (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk |\\" + NL + "  \tSCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\\" + NL + "  \tSCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);    " + NL + "  \t\t\t\t\t\t\t" + NL + "  status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  The function gets RTC status flag for Alarm and Periodic Timer Events." + NL + " */\t" + NL + "status_t  RTC001_GetFlagStatus(RTC001_FlagType Flag)" + NL + "{" + NL + "  status_t status = (uint32_t) RTC001_RESET;" + NL + "  uint32_t TempValue = 0U;" + NL + "  /* <<<DD_RTC001_API_6>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "" + NL + "  /*read the Status Service Request Register*/" + NL + "  TempValue = RTC->STSSR;" + NL + "  " + NL + "  /*check the given flag*/" + NL + "\tif((TempValue & (uint32_t) Flag) != 0U)" + NL + "\t{" + NL + "\t  status = (uint32_t) RTC001_SET;" + NL + "\t}" + NL + "" + NL + "\tDBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "\treturn status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  The function clears RTC status flag for Alarm and Periodic Timer Events." + NL + " */" + NL + "void  RTC001_ClearFlagStatus(RTC001_FlagType Flag)" + NL + "{" + NL + "  /* <<<DD_RTC001_API_5>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "  " + NL + "  /*write to the Clear Service Request Register*/" + NL + "  RTC->CLRSR |= (uint32_t)Flag;" + NL + "" + NL + "\tDBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "}" + NL;
  protected final String TEXT_75 = "\t\t\t\t\t" + NL + "/*" + NL + " *  Interface for creating a new software Timer instance." + NL + " */" + NL + "handle_t RTC001_CreateTimer" + NL + "(" + NL + "  uint32_t Period," + NL + "  RTC001_TimerType TimerType, " + NL + "  RTC001_TimerCallBackPtr TimerCallBack, " + NL + "  void  * pCallBackArgPtr" + NL + ")" + NL + "{" + NL + "  uint8_t TimerID = 0;" + NL + "  uint8_t Count = 0;" + NL + "  /* <<<DD_RTC001_API_7>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Check for input parameter */" + NL + "    if((TimerType != RTC001_ONE_SHOT) && (TimerType != RTC001_PERIODIC))" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);" + NL + "      break;\t" + NL + "    }" + NL + "    if(TimerCallBack == NULL)" + NL + "    {" + NL + "      DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "    for(Count = 0; Count < RTC001_CFG_MAX_TMR; Count++)" + NL + "    {" + NL + "      /* Check for free timer ID */" + NL + "      if((RTC001_TimerTracker & ((uint32_t)1U << Count)) == 0) " + NL + "      {" + NL + "        /* If yes,assign ID to this timer      */" + NL + "        RTC001_TimerTracker |= ((uint32_t)1U << Count);   " + NL + "         /* Initialize timer as per input values */" + NL + "        RTC001_TimerTbl[Count].TimerID     = Count;     " + NL + "        RTC001_TimerTbl[Count].TimerType   = TimerType;\t" + NL + "        RTC001_TimerTbl[Count].TimerState  = TIMER_STATE_STOPPED;" + NL + "        RTC001_TimerTbl[Count].TimerCount    = Period;" + NL + "        RTC001_TimerTbl[Count].TimerReload\t= Period;" + NL + "        RTC001_TimerTbl[Count].TimerCallBack = TimerCallBack;" + NL + "        RTC001_TimerTbl[Count].ParamToCallBack = pCallBackArgPtr;" + NL + "        RTC001_TimerTbl[Count].TimerPrev   = NULL;" + NL + "        RTC001_TimerTbl[Count].TimerNext   = NULL;" + NL + "        TimerID = Count + 1;" + NL + "        break;               " + NL + "      }" + NL + "    }  " + NL + "  }while(0);" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return TimerID;                " + NL + "}  " + NL + "" + NL + "/*" + NL + " *  Interface to start the software timer ." + NL + " */" + NL + "status_t RTC001_StartTimer(handle_t  Handle) " + NL + "{" + NL + "  uint32_t Error = RTC001_ERROR;" + NL + "  /* <<<DD_RTC001_API_9>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Check validity of parameter        */" + NL + "    if(Handle > RTC001_CFG_MAX_TMR)" + NL + "    {" + NL + "        Error = RTC001_INVALID_HANDLE;" + NL + "        DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "        break;" + NL + "    }" + NL + "    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)" + NL + "    {" + NL + "        Error = RTC001_INVALID_HANDLE;" + NL + "        DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "        break;" + NL + "    }" + NL + "    /* Check if timer is running */    " + NL + "    if(RTC001_TimerTbl[(Handle - 1)].TimerState != TIMER_STATE_RUNNING)   " + NL + "    {" + NL + "      /* set timer status as TIMER_STATE_RUNNING */" + NL + "      RTC001_TimerTbl[(Handle - 1)].TimerState = TIMER_STATE_RUNNING;" + NL + "      /* Insert this timer into timer list  */" + NL + "      RTC001_lInsertTimerList((Handle - 1));     " + NL + "    }       " + NL + "    Error = DAVEApp_SUCCESS;                    " + NL + "  }while(0);" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  Interface to stop the software timer." + NL + " */" + NL + "status_t RTC001_StopTimer(handle_t Handle) " + NL + "{" + NL + "  uint32_t Error = RTC001_ERROR;" + NL + "  /* <<<DD_RTC001_API_10>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Check validity of parameter        */" + NL + "    if(Handle > RTC001_CFG_MAX_TMR)" + NL + "    {" + NL + "      Error = RTC001_INVALID_HANDLE;" + NL + "      DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)" + NL + "    {" + NL + "      Error = RTC001_INVALID_HANDLE;" + NL + "      DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "    /* Check whether Timer is in Stop state */" + NL + "    if(RTC001_TimerTbl[(Handle - 1)].TimerState != TIMER_STATE_STOPPED)" + NL + "    {" + NL + "      /* remove Timer from node list */" + NL + "      RTC001_lRemoveTimerList((Handle - 1));" + NL + "  " + NL + "      /* Set timer status as TIMER_STATE_STOPPED  */" + NL + "      RTC001_TimerTbl[(Handle - 1)].TimerState = TIMER_STATE_STOPPED;" + NL + "    }\t" + NL + "    Error = DAVEApp_SUCCESS;              " + NL + "  }while(0);" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Function to delete the Timer instance." + NL + " */" + NL + "status_t RTC001_DeleteTimer(handle_t Handle) " + NL + "{" + NL + "  uint32_t Error = RTC001_ERROR;" + NL + "  /* <<<DD_RTC001_API_8>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Check validity of parameter        */" + NL + "    if(Handle > RTC001_CFG_MAX_TMR)" + NL + "    {" + NL + "      Error = RTC001_INVALID_HANDLE;" + NL + "      DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)" + NL + "    {" + NL + "      Error = RTC001_INVALID_HANDLE;" + NL + "      DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "      break;" + NL + "    }" + NL + "    /* Check if timer is running */" + NL + "    if(RTC001_TimerTbl[(Handle - 1)].TimerState == TIMER_STATE_RUNNING) " + NL + "    {" + NL + "        /* Yes,remove this timer from timer list*/" + NL + "        RTC001_lRemoveTimerList((Handle - 1));         " + NL + "    }" + NL + "    /* Release resource that this timer hold*/" + NL + "    RTC001_TimerTracker &=~((uint32_t)1U << (Handle - 1));     " + NL + "    Error = DAVEApp_SUCCESS;           " + NL + "  }while(0);" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}";
  protected final String TEXT_76 = NL + NL + "/*" + NL + " *  Interface to configure the RTC alarm." + NL + " */" + NL + "" + NL + "status_t RTC001_ConfigAlarm (const RTC001_HandleType* Handle, " + NL + "    RTC001_TimeHandle* timeptr, AlarmCallBackPtr CallBack,uint32_t CbArg)" + NL + "{" + NL + "  uint16_t m1 = 0U,y1 = 0U,d1 = 0U;" + NL + "  status_t status = (uint32_t)RTC001_ERROR;" + NL + "  /* <<<DD_RTC001_API_11>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* <<<DD_RTC001 _API_4>>> */" + NL + "    /* Clear Mirror register update status of RTC registers in SCU*/" + NL + "    SCU_INTERRUPT->SRCLR = (uint32_t)\\" + NL + "      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \\" + NL + "  \t\tSCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\\" + NL + "  \t\tSCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);";
  protected final String TEXT_77 = "  \t" + NL + "" + NL + "    /* Register the call back function with NVIC_SCU001 */\t\t" + NL + "    if(CallBack != NULL)" + NL + "    {    " + NL + "\t    ";
  protected final String TEXT_78 = NL + "\t    NVIC_SCU001_RegisterCallback(NVIC_SCU001_AI,CallBack,CbArg);" + NL + "\t    ";
  protected final String TEXT_79 = NL + "\t    NVIC_SR101_RegisterCallback(NVIC_SR101_AI,CallBack,CbArg);" + NL + "\t    ";
  protected final String TEXT_80 = NL + "\t  }";
  protected final String TEXT_81 = " " + NL + "    /*   Write values into ATIM0 and ATIM1 registers  */" + NL + "    m1 = timeptr->Month;" + NL + "    y1 = timeptr->Year;" + NL + "    d1 = timeptr->Days;" + NL + "    /* Check whether the date entered is valid */" + NL + "    if (RTC001_ldatevalid(m1,d1,y1))" + NL + "    { ";
  protected final String TEXT_82 = NL + "      /*Wait until any transfer over serial interface to ATIM0 is completed*/   " + NL + "      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)" + NL + "      {}   " + NL + "      /*Configure the Alarm Time Register 0 */" + NL + "      RTC->ATIM0 = (uint32_t)\\" + NL + "               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \\" + NL + "              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \\" + NL + "                                  (uint32_t)RTC_ATIM0_AMI_Msk) | \\" + NL + "            ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & \\" + NL + "                                  (uint32_t)RTC_ATIM0_AHO_Msk) | \\" + NL + "        (((((uint32_t)timeptr->Days)-1U) << RTC_ATIM0_ADA_Pos) & \\" + NL + "                                  (uint32_t)RTC_ATIM0_ADA_Msk));" + NL + "" + NL + "      /*Wait until any transfer over serial interface to ATIM1 is completed*/        " + NL + "      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)" + NL + "      {}   " + NL + "      /*Configure the Alarm Time Register 1 */" + NL + "      RTC->ATIM1 = (uint32_t)\\" + NL + "           ((((((uint32_t)timeptr->Month)-1U) << RTC_ATIM1_AMO_Pos) & \\" + NL + "                                       (uint32_t)RTC_ATIM1_AMO_Msk) | \\" + NL + "        ((uint32_t)(((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos) & \\" + NL + "                                       (uint32_t)RTC_ATIM1_AYE_Msk));";
  protected final String TEXT_83 = NL + "       /*Wait until any transfer over serial interface to ATIM0 and ATIM1 is completed*/" + NL + "       while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk))!= 0x0U)" + NL + "       {}   " + NL + "       /*Configure the Alarm Time Register 0 */" + NL + "       RTC->ATIM0 = (uint32_t)\\" + NL + "               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \\" + NL + "              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \\" + NL + "                                  (uint32_t)RTC_ATIM0_AMI_Msk) | \\" + NL + "            ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & \\" + NL + "                                  (uint32_t)RTC_ATIM0_AHO_Msk) | \\" + NL + "        (((((uint32_t)timeptr->Days)-1U) << RTC_ATIM0_ADA_Pos) & \\" + NL + "                                  (uint32_t)RTC_ATIM0_ADA_Msk));        " + NL + "       /*Configure the Alarm Time Register 1 */" + NL + "       RTC->ATIM1 = (uint32_t)\\" + NL + "           ((((((uint32_t)timeptr->Month)-1U) << RTC_ATIM1_AMO_Pos) & \\" + NL + "                                       (uint32_t)RTC_ATIM1_AMO_Msk) | \\" + NL + "        ((uint32_t)(((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos) & \\" + NL + "                                       (uint32_t)RTC_ATIM1_AYE_Msk));\t";
  protected final String TEXT_84 = " \t\t\t\t       " + NL + "      status = (uint32_t)DAVEApp_SUCCESS;   " + NL + "    }  " + NL + "    else /*date is not valid*/" + NL + "    {" + NL + "      status = (uint32_t)RTC001_INVALID_HANDLE;" + NL + "      DBG002_ERROR(APP_GID,status, 0, NULL);" + NL + "    }" + NL + " " + NL + "  }while(0);" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return status;" + NL + "}" + NL + "\t" + NL + "" + NL + "/*" + NL + " *  Function to read the current RTC time" + NL + " */" + NL + " " + NL + "status_t RTC001_Clock_GetTime (RTC001_TimeHandle* timeptr)" + NL + "{" + NL + "  status_t status = (uint32_t)RTC001_ERROR;" + NL + "  uint32_t temp0,temp1;" + NL + "  temp0 = RTC->TIM0;" + NL + "  temp1 = RTC->TIM1;" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "   /* <<<DD_RTC001_API_12>>> */" + NL + "" + NL + "  /*   Read values from TIM0 and TIM1 registers  */" + NL + "  /*   Days of Week value  */" + NL + "\ttimeptr->DaWe = (uint8_t)(temp1 & RTC_TIM1_DAWE_Msk);" + NL + "  /*   Month value  */" + NL + "\ttimeptr->Month = \\" + NL + "          (uint8_t)(((temp1 & RTC_TIM1_MO_Msk) >> RTC_TIM1_MO_Pos) + 1U);" + NL + "  /*   Year value  */" + NL + "\ttimeptr->Year = (uint16_t)((temp1 & RTC_TIM1_YE_Msk) >> RTC_TIM1_YE_Pos);" + NL + "" + NL + "  /*   Seconds value  */" + NL + "\ttimeptr->Sec =  (uint8_t)((temp0 & RTC_TIM0_SE_Msk));" + NL + "  /*   Minutes value  */" + NL + "\ttimeptr->Min = (uint8_t)(((temp0 & RTC_TIM0_MI_Msk) >> RTC_TIM0_MI_Pos));" + NL + "  /*   Hours value  */" + NL + "\ttimeptr->Hours = (uint8_t)(((temp0 & RTC_TIM0_HO_Msk) >> RTC_TIM0_HO_Pos));" + NL + "  /*   Days value starting from the 1st day of the month */" + NL + "\ttimeptr->Days = \\" + NL + "          (uint8_t)(((temp0 & RTC_TIM0_DA_Msk) >> RTC_TIM0_DA_Pos) + 1U);" + NL + "\tstatus = (uint32_t)DAVEApp_SUCCESS;" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  This function is to set the time." + NL + " */" + NL + "status_t RTC001_Clock_SetTime(RTC001_TimeHandle* timeptr)" + NL + "{" + NL + "  uint16_t m1 = 0U,y1 = 0U,d1 = 0U;" + NL + "  uint32_t weekDay = 0U;" + NL + "  status_t status = (uint32_t)RTC001_ERROR;" + NL + "  " + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "   /* <<<DD_RTC001_API_13>>> */" + NL + "  " + NL + "" + NL + "" + NL + "  /* Clear Mirror register update status of RTC registers in SCU*/" + NL + "  SCU_INTERRUPT->SRCLR = \\" + NL + "      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \\" + NL + "  \t\tSCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\\" + NL + "  \t\tSCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);" + NL + " " + NL + "  /*   Days of Week value  */" + NL + "  m1 = timeptr->Month;" + NL + "  y1 = timeptr->Year;" + NL + "  d1 = timeptr->Days;" + NL + "  " + NL + "  do" + NL + "  {    " + NL + "    if (RTC001_ldatevalid(m1,d1,y1))" + NL + "    { " + NL + "      weekDay = ((uint32_t)(RTC001_lweekday(m1,d1,y1)));" + NL + "      if(weekDay < 6U)" + NL + "      {" + NL + "        weekDay += 1U;" + NL + "      }" + NL + "      else if(weekDay == 6U)" + NL + "      {" + NL + "        weekDay = 0U;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        status = (uint32_t)RTC001_INVALID_HANDLE;" + NL + "        DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "      /*Write values into TIM0 and TIM1 registers  */" + NL + "      /*wait until any serial transaction is completed*/";
  protected final String TEXT_85 = "      " + NL + "      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)" + NL + "      {}" + NL + "      /*Configure RTC Time register 0*/" + NL + "      RTC->TIM0 = (uint32_t)\\" + NL + "               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \\" + NL + "              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \\" + NL + "                                  (uint32_t)RTC_TIM0_MI_Msk) | \\" + NL + "            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \\" + NL + "                                  (uint32_t)RTC_TIM0_HO_Msk) | \\" + NL + "      ((((((uint32_t)timeptr->Days)-1U)) << RTC_TIM0_DA_Pos) & \\" + NL + "                                  (uint32_t)RTC_TIM0_DA_Msk));      " + NL + "      /*wait until any serial transaction is completed*/" + NL + "      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)" + NL + "      {}     " + NL + "      /*Configure RTC Time register 1*/" + NL + "      RTC->TIM1 = (uint32_t) (weekDay |\\" + NL + "                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \\" + NL + "                                              (uint32_t)RTC_TIM1_MO_Msk) | \\" + NL + "                         ((((uint32_t)timeptr->Year) << RTC_TIM1_YE_Pos) & \\" + NL + "                                              (uint32_t)RTC_TIM1_YE_Msk));";
  protected final String TEXT_86 = "       " + NL + "      while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk))!= 0x0U)" + NL + "      {}" + NL + "      /*Configure RTC Time register 0*/" + NL + "      RTC->TIM0 = (uint32_t)\\" + NL + "               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \\" + NL + "              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \\" + NL + "                                  (uint32_t)RTC_TIM0_MI_Msk) | \\" + NL + "            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \\" + NL + "                                  (uint32_t)RTC_TIM0_HO_Msk) | \\" + NL + "      ((((((uint32_t)timeptr->Days)-1U)) << RTC_TIM0_DA_Pos) & \\" + NL + "                                  (uint32_t)RTC_TIM0_DA_Msk));  " + NL + "      /*Configure RTC Time register 1*/" + NL + "      RTC->TIM1 = (uint32_t) (weekDay |\\" + NL + "                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \\" + NL + "                                              (uint32_t)RTC_TIM1_MO_Msk) | \\" + NL + "                         ((((uint32_t)timeptr->Year) << RTC_TIM1_YE_Pos) & \\" + NL + "                                              (uint32_t)RTC_TIM1_YE_Msk));      ";
  protected final String TEXT_87 = "      " + NL + "      status = (uint32_t) DAVEApp_SUCCESS;" + NL + "    }  " + NL + "    else" + NL + "    {" + NL + "      status = (uint32_t) RTC001_INVALID_HANDLE;" + NL + "      DBG002_ERROR(APP_GID,status, 0, NULL);" + NL + "    }" + NL + "  }while(0);" + NL + "" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  This function is to get the time in seconds calculated from Epoch time (01/01/1970)." + NL + " */" + NL + "" + NL + "status_t RTC001_Time(time_t* time_value)" + NL + "{" + NL + "" + NL + "  uint32_t CurrentYear = 0U, ElapsedYear = 0U;" + NL + "  uint32_t CurrentMonth = 0U, ElapsedMonth = 0U;" + NL + "  uint32_t CurrentDay = 0U, ElapsedDays = 0U;" + NL + "  uint32_t CurrentHour = 0U;" + NL + "  uint32_t CurrentMin = 0U;" + NL + "  uint32_t CurrentSec = 0U;" + NL + "  uint32_t ElapsedSeconds = 0U;" + NL + "  status_t Status = (uint32_t)RTC001_ERROR; " + NL + "  " + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);" + NL + "   /* <<<DD_RTC001_API_15>>> */" + NL + "  " + NL + "  /*check if RTC module is enabled and no NULL pointer*/" + NL + "  if(((RTC->CTR & (RTC_CTR_ENB_Msk)) != 0U) && (time_value != NULL))" + NL + "  {" + NL + "" + NL + "    /*   Read values from TIM0 and TIM1 registers  */" + NL + "    CurrentYear = ((uint32_t)((RTC->TIM1 & RTC_TIM1_YE_Msk) >> 16U));" + NL + "    CurrentMonth = \t((uint32_t)(((RTC->TIM1 & RTC_TIM1_MO_Msk) >> 8U) + 1U));" + NL + "    CurrentDay = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_DA_Msk) >> 24U) + 1U));" + NL + "    CurrentHour = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_HO_Msk) >> 16U)));" + NL + "    CurrentMin = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_MI_Msk) >> 8U)));" + NL + "    CurrentSec = ((uint32_t)((RTC->TIM0 & RTC_TIM0_SE_Msk)));" + NL + "    " + NL + "    /*Count number of Days for Elapsed Years since Epoch*/" + NL + "    ElapsedDays = (uint32_t)(CurrentYear - RTC001_EPOCH_YEAR) *\\" + NL + "                  (uint32_t) RTC001_DAYS_IN_AN_YEAR;" + NL + "" + NL + "    /* Add the number of days to be adjusted for leap years, " + NL + "    start from previous year and check backwords */" + NL + "    for (ElapsedYear=(CurrentYear-1U); ElapsedYear>= 1970U; ElapsedYear--)" + NL + "    {" + NL + "      if((((ElapsedYear) % 400U) == 0U) || \\" + NL + "        ((((ElapsedYear) % 100U) != 0U) && (((ElapsedYear) %4U) == 0U)))" + NL + "      {" + NL + "        ElapsedDays++;" + NL + "      }" + NL + "    }" + NL + "    /*if current year is leap year add 1 only if March or later*/" + NL + "    if((((CurrentYear) % 400U) == 0U) || \\" + NL + "      ((((CurrentYear) % 100U) != 0U) && (((CurrentYear) %4U) == 0U)))" + NL + "    {" + NL + "      if(CurrentMonth > 2U)" + NL + "      {" + NL + "        ElapsedDays++;" + NL + "      }" + NL + "    }" + NL + "    " + NL + "    /*Add number of Days from Elapsed months from current year*/" + NL + "    for (ElapsedMonth = (CurrentMonth - 1U); ElapsedMonth != 0U; ElapsedMonth--)" + NL + "    {" + NL + "      ElapsedDays += RTC001_DAYS_IN_MONTH[ElapsedMonth];  " + NL + "    } " + NL + "    " + NL + "    /*add Elapsed days from current month*/" + NL + "    ElapsedDays += CurrentDay - 1U;" + NL + "    " + NL + "    /*Accumulate the total seconds for ElapsedDays*/" + NL + "    ElapsedSeconds = (ElapsedDays * RTC001_SECONDS_IN_A_DAY);" + NL + "" + NL + "    /*Add seconds for current hour, minute and seconds*/" + NL + "    ElapsedSeconds += (CurrentHour * RTC001_SECONDS_IN_AN_HOUR);   " + NL + "    ElapsedSeconds += (CurrentMin * RTC001_SECONDS_IN_A_MINUTE); " + NL + "    ElapsedSeconds += CurrentSec; " + NL + "" + NL + "    *time_value = (time_t) ElapsedSeconds;" + NL + "    Status = (uint32_t) DAVEApp_SUCCESS;" + NL + "    " + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "/* return 1 if date is valid, 0 otherwise.\t*/" + NL + "static uint32_t RTC001_ldatevalid(uint16_t m,uint16_t d,uint16_t y)" + NL + "{" + NL + "  uint32_t valid = 0U;" + NL + "" + NL + "  if ((m == 0U) || (m > 12U) )" + NL + "  {" + NL + "    valid = 0U;" + NL + "  }" + NL + "  else  if ((m != 2U) || (d < 29U))" + NL + "  {" + NL + "     if (d <= RTC001_DAYS_IN_MONTH[m])" + NL + "     {" + NL + "       valid = 1U;" + NL + "     }" + NL + "  }" + NL + "  else /*reaches here only if m = February and day = 29*/" + NL + "  {" + NL + "    /*check if it is leap year*/" + NL + "    if ((((y) % 400U) == 0U) || ((((y) % 100U) != 0U) && (((y) %4U) == 0U)))" + NL + "    {" + NL + "      if (d == 29U)" + NL + "      { " + NL + "        valid = 1U;" + NL + "      }" + NL + "    }" + NL + "  }" + NL + "  return valid;" + NL + "}" + NL + "" + NL + "/* given month, day, year, returns day of week, eg. Monday = 0 etc." + NL + "*/ " + NL + "" + NL + "static uint32_t RTC001_lweekday(uint16_t m,uint16_t d,uint16_t y)" + NL + "{" + NL + "  uint16_t vx, tx, ix, feb;" + NL + "  const uint8_t vx_list[] = " + NL + "  {" + NL + "      0U, 20U, 0U, 16U, 24U, 20U, 0U, 24U, 4U, 12U, 8U, 16U, 12U" + NL + "  };" + NL + "" + NL + "  vx = vx_list[m];" + NL + "  if(y > 1900U)" + NL + "  {" + NL + "    y = y - 1900U;" + NL + "  }" + NL + "  feb = (m  > 2U)? 1U : 0U;" + NL + "/* take care of February */" + NL + "  ix = ((y - 21U) % 28U) + vx + feb;" + NL + "/* take care of leap year */" + NL + "  tx = ((ix + (ix / 4U)) % 7U) + d;" + NL + "  tx = tx % 7U;" + NL + "  return ((uint32_t)tx);" + NL + "}" + NL + "" + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_88 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/RTC001/0";
    stringBuffer.append(TEXT_2);
     int Is4Device = -1; 
     int Is1Device = -1; 
     Is4Device = ((app.getSoftwareId().substring(0,1).compareTo("4")==0)?1:0); 
     Is1Device = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); 
    stringBuffer.append(TEXT_3);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_4);
     String UserFunc = null;
    stringBuffer.append(TEXT_5);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_6);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_7);
     } 
    stringBuffer.append(TEXT_8);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_9);
     } else {
 }
    stringBuffer.append(TEXT_10);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_11);
     } else {
 }
    stringBuffer.append(TEXT_12);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_13);
     } else {
 }
    stringBuffer.append(TEXT_14);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_15);
     } else {
 }
    stringBuffer.append(TEXT_16);
    if (Is1Device==1){
    stringBuffer.append(TEXT_17);
    }
    stringBuffer.append(TEXT_18);
    if (Is1Device==1){
    stringBuffer.append(TEXT_19);
    }
    stringBuffer.append(TEXT_20);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_21);
     } else { }
    stringBuffer.append(TEXT_22);
    if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/enb") == 1) { 
    stringBuffer.append(TEXT_23);
     }  else {  }
    stringBuffer.append(TEXT_24);
    if (Is4Device==1){
    stringBuffer.append(TEXT_25);
    if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/tae") == 1) { 
    stringBuffer.append(TEXT_26);
     }  else { }
	  if (app.getIntegerValue(AppBaseuri + "/rtc/msksr/mai") == 1) { 
    stringBuffer.append(TEXT_27);
    }
     } else {
    stringBuffer.append(TEXT_28);
    if (app.getIntegerValue(AppBaseuri + "/rtc/msksr/mai") == 1) { 
    stringBuffer.append(TEXT_29);
    }
    }
    stringBuffer.append(TEXT_30);
    if (Is4Device==1){
    stringBuffer.append(TEXT_31);
    }
    stringBuffer.append(TEXT_32);
    if (Is4Device==1){
    stringBuffer.append(TEXT_33);
    if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/esec") == 1) { 
    stringBuffer.append(TEXT_34);
     }  else {
     }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/emic") ==1) {
    stringBuffer.append(TEXT_35);
     } else {}
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/ehoc") ==1) {
    stringBuffer.append(TEXT_36);
     } else { }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/edac") ==1) {
    stringBuffer.append(TEXT_37);
     } else { }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/emoc") ==1) {
    stringBuffer.append(TEXT_38);
     } else { }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/eyec") ==1) {
    stringBuffer.append(TEXT_39);
     } else {}
    stringBuffer.append(TEXT_40);
    }
    stringBuffer.append(TEXT_41);
    if (Is1Device==1){
    stringBuffer.append(TEXT_42);
    }
    stringBuffer.append(TEXT_43);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_44);
    if (Is4Device==1){
    stringBuffer.append(TEXT_45);
     } else {
    stringBuffer.append(TEXT_46);
    }
    stringBuffer.append(TEXT_47);
     } else { }
    int pi_count = 0;
  if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpse") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {
    stringBuffer.append(TEXT_48);
     pi_count = pi_count + 1;
	} else { }
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpmi") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {
    stringBuffer.append(TEXT_49);
     pi_count = pi_count + 1;
	} else { }
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpho") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {
    stringBuffer.append(TEXT_50);
     pi_count = pi_count + 1;
	} else {}
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpda") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {
    stringBuffer.append(TEXT_51);
     pi_count = pi_count + 1;
	} else {}
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpmo") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {
    stringBuffer.append(TEXT_52);
     pi_count = pi_count + 1;
	} else {}
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpye") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {
    stringBuffer.append(TEXT_53);
     pi_count = pi_count + 1;
	} else { }
    stringBuffer.append(TEXT_54);
    if (pi_count > 0)
    stringBuffer.append(TEXT_55);
    if (Is4Device==1){
    stringBuffer.append(TEXT_56);
    }
    stringBuffer.append(TEXT_57);
    String EventHandlerTimer = app.getStringValue(AppBaseuri +"/RTC001_srwTimerUserFunction");
  if((EventHandlerTimer != null) && (EventHandlerTimer != "")) 
  { 
    if (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1) 
    { 
      if (app.getIntegerValue(AppBaseuri + "/RTC001_Eventtrigger_timer/0") == 1) 
      { 
    stringBuffer.append(TEXT_58);
    if (Is4Device==1){
    stringBuffer.append(TEXT_59);
    stringBuffer.append(EventHandlerTimer);
    stringBuffer.append(TEXT_60);
     } else {
    stringBuffer.append(TEXT_61);
    stringBuffer.append(EventHandlerTimer);
    stringBuffer.append(TEXT_62);
    }
    stringBuffer.append(TEXT_63);
     } 
     }
  }
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_64);
     } else { }
    String EventHandlerAlarm1 = app.getStringValue(AppBaseuri +"/RTC001_srwAlarmUserFunction"); 
  if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwAlarmIntrptEna/0") == 1)) 
  { 
    if((EventHandlerAlarm1 != null) && (EventHandlerAlarm1 != "") && (app.getIntegerValue(AppBaseuri + "/RTC001_Eventtrigger_Alarm/0") == 1)) 
    { 
    stringBuffer.append(TEXT_65);
    stringBuffer.append(EventHandlerAlarm1);
    stringBuffer.append(TEXT_66);
     }
    else { 
    stringBuffer.append(TEXT_67);
     } 
  } 
    stringBuffer.append(TEXT_68);
    if (Is4Device==1){
    stringBuffer.append(TEXT_69);
     } else {
    stringBuffer.append(TEXT_70);
    }
    stringBuffer.append(TEXT_71);
    if (Is4Device==1){
    stringBuffer.append(TEXT_72);
     } else {
    stringBuffer.append(TEXT_73);
    }
    stringBuffer.append(TEXT_74);
     if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {
    stringBuffer.append(TEXT_75);
     } else {
 }
    stringBuffer.append(TEXT_76);
     if (app.getIntegerValue(AppBaseuri + "/RTC001_Eventtrigger_Alarm/0") == 1) 
     { 
    stringBuffer.append(TEXT_77);
    if (Is4Device==1){
    stringBuffer.append(TEXT_78);
     } else {
    stringBuffer.append(TEXT_79);
    }
    stringBuffer.append(TEXT_80);
     } 
    stringBuffer.append(TEXT_81);
    if (Is4Device==1){
    stringBuffer.append(TEXT_82);
     } else {
    stringBuffer.append(TEXT_83);
    }
    stringBuffer.append(TEXT_84);
    if (Is4Device==1){
    stringBuffer.append(TEXT_85);
     } else {
    stringBuffer.append(TEXT_86);
    }
    stringBuffer.append(TEXT_87);
    stringBuffer.append(TEXT_88);
    return stringBuffer.toString();
  }
}
