package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class sdmmc003_privatec_template
{
  protected static String nl;
  public static synchronized sdmmc003_privatec_template create(String lineSeparator)
  {
    nl = lineSeparator;
    sdmmc003_privatec_template result = new sdmmc003_privatec_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + NL + "/*CODE_BLOCK_BEGIN[SDMMC003_Private.c]*/" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Oct 1, 2012                                            **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** SK          App Developer                                                  **" + NL + "*******************************************************************************/";
  protected final String TEXT_2 = NL + NL + NL + "/**" + NL + " * @file   SDMMC003_Private.c" + NL + " *" + NL + " * @App Version SDMMC003 <";
  protected final String TEXT_3 = ">" + NL + " *" + NL + " * @brief  This file contains definitions of all private type definitions and" + NL + " * functions of SDMMC LLD App." + NL + " *" + NL + " * Revision History" + NL + " * 22 March 2012  v1.0.0    Initial version" + NL + " * 3 Aug 2012     v1.0.12   Erase optimizations  introduced." + NL + " *                          Make File System(MKFS) through software issue fixed. " + NL + " * 1 Oct 2012     v1.0.14   Delays reduced." + NL + " *                          Removed RTOS specific code. " + NL + " */" + NL + "/*******************************************************************************" + NL + " *                            INCLUDE FILES                                   **" + NL + " ******************************************************************************/" + NL + "#include \"../../inc/SDMMC003/SDMMC003_Conf.h\"" + NL + "#include <DAVE3.h>" + NL + "#include \"../../inc/SDMMC003/SDMMC003_Private.h\"" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + " **                      Global Variable Definitions                          **" + NL + " *******************************************************************************/" + NL + "extern volatile SDMMC003_HandleType SDMMC003_Handle ;" + NL + "/**  Card Information Structure */" + NL + "SDMMC003_CardInfoType SDMMC003_CardInfo ;" + NL + "/** Structure containing the Interrupt related variables */" + NL + "volatile SDMMC003_InterruptContext SDMMC003_ISRContext;" + NL + "" + NL + "/* Dummy Variable to store return status */" + NL + "status_t SDMMC003_ReturnStatus;" + NL + "" + NL + "#if SDMMC_UVP_TEST" + NL + "  extern Test_TriggerInterruptType Test_TriggerInterrupt;" + NL + "#endif /* SDMMC_UVP_TEST */" + NL + "" + NL + "/** Stores Normal Interrupt Status Register */" + NL + "volatile  uint16_t NormalIntStatus;" + NL + "/** Stores Error Interrupt Status Register */" + NL + "volatile  uint16_t ErrorIntStatus;" + NL + "" + NL + "/*******************************************************************************" + NL + " *                                ARRAYS                                      **" + NL + " ******************************************************************************/" + NL + "/**" + NL + " * Command Structure defining SD, MMC and Application specific commands " + NL + " */" + NL + "const SDMMC003_CommandType SDMMC003_Command[40] =" + NL + "{" + NL + "  /* SD  Card Commands */" + NL + "  { 0,0,0,0,0,0,SDMMC003_GO_IDLE_STATE,0 },     /*0*/" + NL + "  { 1,0,1,0,0,0,SDMMC003_ALL_SEND_CID,0 },      /*1*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SEND_RELATIVE_ADDR,0}, /*2*/" + NL + "  { 0,0,0,0,0,0,SDMMC003_SET_DSR,0 },           /*3*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_SWITCH_FUNC,0},        /*4*/" + NL + "  { 3,0,1,1,0,0,SDMMC003_SELECT_DESELECT_CARD,0},/*5*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SD_SEND_IF_COND,0},    /*6*/" + NL + "  { 1,0,1,0,0,0,SDMMC003_SEND_CSD,0},           /*7*/" + NL + "  { 1,0,1,0,0,0,SDMMC003_SEND_CID,0},           /*8*/" + NL + "  { 3,0,1,1,0,0,SDMMC003_STOP_TRANSMISSION,0},  /*9*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SEND_STATUS,0 },       /*10*/" + NL + "  { 0,0,0,0,0,0,SDMMC003_GO_INACTIVE_STATE,0},  /*11*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SET_BLOCKLEN,0},       /*12*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_READ_SINGLE_BLOCK,0},  /*13*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_READ_MULTIPLE_BLOCK,0},/*14*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_WRITE_BLOCK,0 },       /*15*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_WRITE_MULTIPLE_BLOCK,0},/*16*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_PROGRAM_CSD,0},        /*17*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SET_WRITE_PROT,0},     /*18*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_CLR_WRITE_PROT,0},     /*19*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_SEND_WRITE_PROT,0},    /*20*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_ERASE_WR_BLK_START,0}, /*21*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_ERASE_WR_BLK_END,0},   /*22*/" + NL + "  { 3,0,1,1,0,0,SDMMC003_ERASE,0},              /*23*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_LOCK_UNLOCK,0},        /*24*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_APP_CMD,0},            /*25*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_GEN_CMD,0},            /*26*/" + NL + "  /*  End of SD card commands */" + NL + "  /* Start of Application Specific commands */" + NL + "  { 2,0,1,1,0,0,SDMMC003_SET_BUS_WIDTH,0},      /*27*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_SD_STATUS,0},          /*28*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_SEND_NUM_WR_BLOCKS,0}, /*29*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SET_WR_BLK_ERASE_COUNT,0},/*30*/" + NL + "  { 2,0,0,0,0,0,SDMMC003_SD_SEND_OP_COND,0},    /*31*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_SET_CLR_CARD_DETECT,0},/*32*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_SEND_SCR,0 },          /*33*/" + NL + "  /* End of Application Specific Commands */" + NL + "  /* Start of SDMMC_MMC Card  specific commands */" + NL + "  { 2,0,0,1,0,0,SDMMC003_MMC_SEND_OP_COND,0},   /*34*/" + NL + "  { 3,0,1,1,0,0,SDMMC003_MMC_SLEEP_AWAKE,0},    /*35*/" + NL + "  { 3,0,1,1,0,0,SDMMC003_SWITCH_FUNC,0},        /*36*/" + NL + "  { 2,0,1,1,1,0,SDMMC003_MMC_SEND_EXT_CSD,0},   /*37*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_ERASE_GROUP_START,0},  /*38*/" + NL + "  { 2,0,1,1,0,0,SDMMC003_ERASE_GROUP_END,0},    /*39*/" + NL + "  /* End of SDMMC_MMC  Card specific commands */" + NL + "};" + NL + "" + NL + "/* Sd Card's Command Index Hash Table having index of the command structure" + NL + " * Array Index 0-57 is for SD general Commands and Array Index 58-64 is for" + NL + " * Application Specific Commands." + NL + " */" + NL + "const uint8_t SDMMC003_SDHashTable[65] =" + NL + "{" + NL + "  0, 0xFF,1,2,3,0xFF,4,5,6,7,8,0xFF,9,10,0xFF,\\" + NL + "  11, 12, 13, 14,0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\" + NL + "  15, 16, 0xFF, 17, 18, 19, 20, 0xFF, 21, 22,\\" + NL + "  0xFF, 0xFF, 0xFF, 0xFF, 23, 0xFF, 0xFF, 0xFF,\\" + NL + "  24, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\" + NL + "  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 25, 26, 0xFF, \\" + NL + "  27, 28, 29,30,31,32,33" + NL + "};" + NL + "" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "const uint8_t SDMMC003_MMCHashTable[64] =" + NL + "{" + NL + "  0,34,1,2,3,35,36,5,37,7,8,0xFF,9,10,0xFF,11,12,\\" + NL + "  13,14,0xFF,0xFF,0xFF,0xFF,0xFF,15,16,0xFF,17,\\" + NL + "  18,19,20,0xFF,0xFF,0xFF,0xFF,38,39,0xFF,23,\\" + NL + "  0xFF,0xFF,0xFF,24,0xFF,0xFF,0xFF,0xFF,0xFF,\\" + NL + "  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,25,26,0xFF,\\" + NL + "  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF" + NL + "};" + NL + "#endif" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "/*<<<DD_SDMMC_nonAPI_1>>> */" + NL + "/*" + NL + " * This function resets the Host Controller's register depending on the" + NL + " * parameter passed." + NL + " */" + NL + "status_t SDMMC003_lReset( uint8_t Reset )" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  handle_t TimerId;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  SDMMC->SW_RESET =  (SDMMC->SW_RESET | Reset);" + NL + "  /* The Host Controller takes some time to complete software reset*/" + NL + "  /* Wait till host controller clears each bit */" + NL + "/* <<<DD_SDMMC_nonAPI_1_1>>>*/" + NL + "  TimerId = SDMMC003_lStartTimer(SDMMC003_RESET_DELAY);" + NL + "  if(0 == TimerId)" + NL + "  {" + NL + "    Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "    ERROR(GID_SDMMC00x, Status, 0, NULL);    " + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    do" + NL + "    {" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while (SDMMC->SW_RESET & Reset);" + NL + "    SDMMC003_lStopTimer(TimerId);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "/* <<<DD_SDMMC_nonAPI_2>>> */" + NL + "/*" + NL + " * This function clears the card related structures and stops the SD clock." + NL + " */" + NL + "void SDMMC003_lCardCleanUp()" + NL + "{" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  memset((void*)&SDMMC003_CardInfo,0,sizeof(SDMMC003_CardInfo));" + NL + "  SDMMC003_Handle.CardType = 0;" + NL + "  SDMMC003_Handle.f8 = 0;" + NL + "  SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;" + NL + "  SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;" + NL + "  SDMMC003_Handle.ErrorRecoveryStatus = SDMMC003_ERROR;" + NL + "  SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;" + NL + "  SDMMC003_Handle.State  = 0;" + NL + "  /* Stop the SD Clock Enable */" + NL + "  CLR_BIT( SDMMC->CLOCK_CTRL,SDMMC_CLOCK_CTRL_SDCLOCK_EN_Pos  );" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_3>>> */" + NL + "/*" + NL + " * This function checks whether the CMD and DATA lines are free before issuing" + NL + " * any command." + NL + " */" + NL + "status_t SDMMC003_lCheckDatCmdline(const SDMMC003_CommandType *CommandPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "#if SDMMC_UVP_TEST" + NL + "    if( Test_TriggerInterrupt.Trigger_DataCmdLineBusy == TRUE)" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_CMD_LINE_BUSY;" + NL + "      break;" + NL + "    }" + NL + "#endif" + NL + "/* Read from Present state register to Check Cmd line is free */" + NL + "/* <<<DD_SDMMC_nonAPI_3_1>>> */" + NL + "    if ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_CMD_Msk)" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_CMD_LINE_BUSY;" + NL + "      break;" + NL + "    }" + NL + "/* Check for  data line for Send Status command  and all those commands using  " + NL + "   data line */" + NL + "/* <<<DD_SDMMC_nonAPI_3_2>>> */" + NL + "    if (( 1UL == CommandPtr->DataPresentSelect) ||  \\" + NL + "        ( (SDMMC003_SEND_STATUS == CommandPtr->CommandIndex) || \\" + NL + "          (3UL == CommandPtr->ResponseTypeSelect) )" + NL + "       )" + NL + "    {" + NL + "/* <<<DD_SDMMC_nonAPI_3_3>>> */" + NL + "      /* Read from Present state register to Check data line is free */" + NL + "      if ( (SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_DAT_Msk )!= 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_DATA_LINE_BUSY;" + NL + "        break;" + NL + "      }" + NL + "/* <<<DD_SDMMC_nonAPI_3_4>>> */" + NL + "      else" + NL + "      {" + NL + "        /* Update the data line state to active */" + NL + "        if( (1UL == CommandPtr->DataPresentSelect) || \\" + NL + "            (3UL == CommandPtr->ResponseTypeSelect) )" + NL + "        {" + NL + "          SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_DATA_ACTIVE;" + NL + "        }" + NL + "      }" + NL + "    }" + NL + "    /* Update the Command line state to active */" + NL + "    SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_CMD_ACTIVE;" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_4>>> */" + NL + "/*" + NL + " * This function checks response error types in Command's Arguments category" + NL + " */" + NL + "void SDMMC003_lCheckArgumentError" + NL + "(" + NL + "  const uint32_t  *CardStatusPtr," + NL + "  uint8_t *ErrorPtr" + NL + ")" + NL + "{" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* The command's argument was out of the allowed range for this card.*/" + NL + "/* <<<DD_SDMMC_nonAPI_4_1>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_OUT_OF_RANGE_BITMASK ) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x, SDMMC003_OUT_OF_RANGE_ERROR,0,NULL);" + NL + "  } /*End of \"if( *CardStatusPtr & CSR_OUT_OF_RANGE_BITMASK ) \"*/" + NL + "" + NL + "  /* A mis-aligned address which did not match the block length was used in" + NL + "   * the command.*/" + NL + "/* <<<DD_SDMMC_nonAPI_4_2>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_ADDRESS_ERROR_BITMASK) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x, SDMMC003_ADDRESS_ERROR,0,NULL);" + NL + "  } /*End of \" if ( *CardStatusPtr & CSR_ADDRESS_ERROR_BITMASK) \"*/" + NL + "" + NL + "  /* The transferred block length is not allowed for this card, or the number" + NL + "   * of transferred bytes does not match the block length.*/" + NL + "/* <<<DD_SDMMC_nonAPI_4_3>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_BLOCK_LEN_ERROR_BITMASK) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_BLOCK_LEN_ERROR,0,NULL);" + NL + "  }/*End of \" if (*CardStatusPtr & CSR_BLOCK_LEN_ERROR_BITMASK) \"*/" + NL + "" + NL + "  /* Set when the host attempts to write to a protected block or to the" + NL + "     temporary or permanent write protected card.*/" + NL + "/* <<<DD_SDMMC_nonAPI_4_4>>> */" + NL + "  if (( *CardStatusPtr & SDMMC003_CSR_WP_VIOLATION_BITMASK ) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_WP_VIOLATION_ERROR,0,NULL);" + NL + "  }/*End of \"if ( *CardStatusPtr & CSR_WP_VIOLATION_BITMASK ) \"*/" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_5>>> */" + NL + "/*" + NL + " * This function checks response error types in Erase category" + NL + " */" + NL + "void SDMMC003_lCheckEraseError" + NL + "(" + NL + "  const uint32_t *CardStatusPtr," + NL + "  uint8_t *ErrorPtr" + NL + ")" + NL + "{" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /* An error in the sequence of erase commands occurred.*/" + NL + "/* <<<DD_SDMMC_nonAPI_5_1>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_ERASE_SEQ_ERROR_BITMASK) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_ERASE_SEQ_ERROR,0,NULL);" + NL + "  }" + NL + "  /* An invalid selection of write-blocks for erase occurred.*/" + NL + "/* <<<DD_SDMMC_nonAPI_5_2>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_ERASE_PARAM_BITMASK) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_ERASE_PARAM_ERROR,0,NULL);" + NL + "  }" + NL + "  /* Set when only partial address space was erased due to existing" + NL + "   * write protected blocks or the temporary or permanent write protected card" + NL + "   *  was erased.*/" + NL + "/* <<<DD_SDMMC_nonAPI_5_3>>> */" + NL + "  if (( *CardStatusPtr & SDMMC003_CSR_WP_ERASE_SKIP_BITMASK) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_WP_ERASE_SKIP_ERROR,0,NULL);" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_6>>> */" + NL + "/*" + NL + " * This function checks response error types in card's internal error category" + NL + " */" + NL + "void SDMMC003_lCheckCardError" + NL + "(" + NL + "  const uint32_t *CardStatusPtr," + NL + "  uint8_t *ErrorPtr" + NL + ")" + NL + "{" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* Card internal ECC was applied but failed to correct the data.*/" + NL + "/* <<<DD_SDMMC_nonAPI_6_1>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_CARD_ECC_FAILED_BITMASK) != 0UL)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_CARD_ECC_ERROR,0,NULL);" + NL + "  }" + NL + "  /* Internal card controller error*/" + NL + "/* <<<DD_SDMMC_nonAPI_6_2>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_CC_ERROR_BITMASK) != 0UL)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_CC_ERROR,0,NULL);" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_6_3>>> */" + NL + "  /* A general or an unknown error occurred during the operation.*/" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_ERROR_BITMASK) != 0)" + NL + "  {" + NL + "    *ErrorPtr = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_UNKNOWN_ERROR,0,NULL);" + NL + "  }" + NL + "  /* Debug Log message .*/" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_7>>> */" + NL + "/*" + NL + " * This function checks for any error in the command's response received." + NL + " */" + NL + "status_t SDMMC003_lCheckErrorInResponse( const uint32_t *CardStatusPtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  uint8_t ErrorStatus = 0;      /* No Error */" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /* Argument Related Error Function */" + NL + "  SDMMC003_lCheckArgumentError( CardStatusPtr, &ErrorStatus );" + NL + "" + NL + "  /* Erase Related Error function  */" + NL + "  SDMMC003_lCheckEraseError( CardStatusPtr, &ErrorStatus);" + NL + "" + NL + "  /* Card Related Error function */" + NL + "  SDMMC003_lCheckCardError(CardStatusPtr, &ErrorStatus);" + NL + "" + NL + "  /* Set when a sequence or password error has been detected in lock/unlock" + NL + "   * card command.*/" + NL + "/*<<<DD_SDMMC_nonAPI_7_1>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_LOCK_UNLOCK_FAILED_BITMASK) != 0)" + NL + "  {" + NL + "    ErrorStatus = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_LOCK_UNLOCK_ERROR,0,NULL);" + NL + "  }" + NL + "  /* Can be either one of the following errors:" + NL + "   * The read only section of the CSD does not match the card content." + NL + "   *  An attempt to reverse the copy  or permanent WP  bits was made." + NL + "   */" + NL + "/*<<<DD_SDMMC_nonAPI_7_4>>> */" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_CSD_OVERWRITE_BITMASK) != 0)" + NL + "  {" + NL + "    ErrorStatus = 1UL;" + NL;
  protected final String TEXT_4 = "    ERROR(GID_SDMMC00x,SDMMC003_CSD_OVERWRITE,0,NULL);" + NL + "  }" + NL + "/*<<<DD_SDMMC_nonAPI_7_5>>> */" + NL + "  /* Error in the sequence of the authentication process*/" + NL + "  if ((*CardStatusPtr & SDMMC003_CSR_ASK_SEQ_ERROR_BITMASK) != 0)" + NL + "  {" + NL + "    ErrorStatus = 1UL;" + NL + "    ERROR(GID_SDMMC00x,SDMMC003_ASK_SEQ_ERROR,0,NULL);" + NL + "  }" + NL + "  /* Below Additional condition is because some SD cards treat CMD55 as Illegal" + NL + "   * Command and gives this error in response */" + NL + "/*<<<DD_SDMMC_nonAPI_7_6>>> */" + NL + "  if (ErrorStatus == 1UL) " + NL + "  {" + NL + "    Status = (uint32_t) SDMMC003_ERROR;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function checks for lock status of SDMMC card." + NL + " */" + NL + "void SDMMC003_lGetCardLockState(uint32_t CardStatus, uint16_t CommandIndex)" + NL + "{" + NL + "  if (((CardStatus & SDMMC003_CSR_CARD_IS_LOCKED_BITMASK) != 0) &&" + NL + "      (CommandIndex != SDMMC003_SEND_RELATIVE_ADDR ))" + NL + "  {" + NL + "    SDMMC003_Handle.State |= SDMMC003_STATE_CARD_LOCKED ;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CARD_LOCKED ;" + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function provide the delay in transfer." + NL + " */" + NL + "status_t SDMMC003_lTransferDelay(uint32_t DelayTime)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  handle_t TimerId;" + NL + "  SDMMC003_Handle.TimerExpire = 1;" + NL + "  TimerId = SDMMC003_lStartTimer(DelayTime);" + NL + "  if(0 == TimerId)" + NL + "  {" + NL + "    Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "  }" + NL + "  if(Status != (uint32_t) SDMMC003_START_TIMER_FAILED)" + NL + "  {" + NL + "    do" + NL + "    {" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while (SDMMC003_ISRContext.TransferFlag == 0);" + NL + "    SDMMC003_ISRContext.TransferFlag = 0;" + NL + "    SDMMC003_lStopTimer(TimerId);" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_22_6>>> */" + NL + "  if( SDMMC003_Handle.TransferInterruptError != SDMMC003_TRANSFER_COMPLETE)" + NL + "  {" + NL + "    Status = (uint32_t)SDMMC003_Handle.DataInterruptError;" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_8>>> */" + NL + "/*" + NL + " * This function reads for the response received for the command issued." + NL + " */" + NL + "status_t  SDMMC003_lReadResponse" + NL + "(" + NL + "   const SDMMC003_CommandType *CommandPtr," + NL + "   SDMMC003_ResponseType ResponseType," + NL + "   void *ResponsePtr" + NL + ")" + NL + "{" + NL + "  uint32_t CardStatus = 0;" + NL + "  uint32_t ErrorStatus = 0;" + NL + "  uint32_t *TmpPtr;" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /* Check for  No response type commands */" + NL + "/*<<<DD_SDMMC_nonAPI_8_1>>> */" + NL + "  if (CommandPtr->CommandIndex == SDMMC003_GO_IDLE_STATE || \\" + NL + "      CommandPtr->CommandIndex == SDMMC003_GO_INACTIVE_STATE)" + NL + "  {" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "/*<<<DD_SDMMC_nonAPI_8_2>>> */" + NL + "  else" + NL + "  {" + NL + "    TmpPtr = (uint32_t *)ResponsePtr;" + NL + "    CardStatus = SDMMC->RESPONSE0;" + NL + "    /* Check Lock Status */" + NL + "/*<<<DD_SDMMC_nonAPI_8_3>>> */" + NL + "    SDMMC003_lGetCardLockState(CardStatus, CommandPtr->CommandIndex);" + NL + "   /* Check response type*/" + NL + "    switch( ResponseType )" + NL + "    {" + NL + "      /* Response R1*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_4>>> */" + NL + "      case SDMMC003_RESPONSE_R1:" + NL + "        /* check the error bits in the response */" + NL + "         *TmpPtr = CardStatus;" + NL + "/*<<<DD_SDMMC_nonAPI_8_5>>> */" + NL + "        Status = SDMMC003_lCheckErrorInResponse(&CardStatus);" + NL + "        break;" + NL + "      /* Response R1b*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_6>>> */" + NL + "      case SDMMC003_RESPONSE_R1b:" + NL + "        *TmpPtr = CardStatus;" + NL + "        /* check the error bits in the response */" + NL + "         Status = SDMMC003_lCheckErrorInResponse(&CardStatus);" + NL + "         if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "         {" + NL + "           break;" + NL + "         }" + NL + "#if SDMMC_UVP_TEST" + NL + "        if (Test_TriggerInterrupt.Trigger_TransferInterruptError == TRUE)" + NL + "        {" + NL + "          SDMMC003_ISRContext.TransferFlag = 1;" + NL + "          SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;" + NL + "        }" + NL + "#endif  /* SDMMC_UVP_TEST*/" + NL + "        /* Wait for transfer complete Interrupt */" + NL + "/*<<<DD_SDMMC_nonAPI_8_7>>> */" + NL + "        Status = SDMMC003_lTransferDelay(SDMMC003_DELAY_IN_TRANSFER);" + NL + "        if(Status != (uint32_t) DAVEApp_SUCCESS)" + NL + "        {" + NL + "          ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "          break;" + NL + "        }" + NL + "#if SDMMC_UVP_TEST" + NL + "        if (Test_TriggerInterrupt.Trigger_TransferInterruptError == TRUE)" + NL + "        {" + NL + "          /* Enable the Transfer Complete Status Interrupt */" + NL + "          SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk;" + NL + "          /*  Enable the Transfer Complete Signal Interrupt */" + NL + "          SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk;" + NL + "        }" + NL + "#endif     /* SDMMC_UVP_TEST*/" + NL + "        /* If busy status received successfully  in the data line for R1b */" + NL + "/*<<<DD_SDMMC_nonAPI_8_8>>> */" + NL + "        break;" + NL + "      /* Response R2*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_9>>> */" + NL + "      case SDMMC003_RESPONSE_R2:" + NL + "        /* Response register R0-R7 */" + NL + "        *TmpPtr = CardStatus;" + NL + "        TmpPtr++;" + NL + "" + NL + "        *TmpPtr = SDMMC->RESPONSE2;" + NL + "        TmpPtr++;" + NL + "" + NL + "        *TmpPtr = SDMMC->RESPONSE4;" + NL + "        TmpPtr++;" + NL + "" + NL + "        *TmpPtr = SDMMC->RESPONSE6;" + NL + "        break;" + NL + "      /* Response R3*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_10>>> */" + NL + "      case SDMMC003_RESPONSE_R3:" + NL + "" + NL + "      /* Response R7*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_11>>> */" + NL + "      case SDMMC003_RESPONSE_R7:" + NL + "        *TmpPtr = CardStatus;" + NL + "         break;" + NL + "" + NL + "      /* Response R6*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_12>>> */" + NL + "      case SDMMC003_RESPONSE_R6:" + NL + "        ErrorStatus  = CardStatus & SDMMC_RESPONSE0_RESPONSE0_Msk;" + NL + "        Status = SDMMC003_lCheckErrorInResponse(&ErrorStatus);" + NL + "/*<<<DD_SDMMC_nonAPI_8_13>>> */" + NL + "        /* Read the 16bit RCA received in Response R1 register */" + NL + "        *TmpPtr =(uint16_t)((CardStatus & SDMMC_RESPONSE0_RESPONSE1_Msk) >> \\" + NL + "                              SDMMC003_HC_RESPONSE1_BITPOS );" + NL + "        break;" + NL + "" + NL + "      /* No response*/" + NL + "/*<<<DD_SDMMC_nonAPI_8_14>>> */" + NL + "      case SDMMC003_NO_RESPONSE:" + NL + "        Status = DAVEApp_SUCCESS;" + NL + "        break;" + NL + "" + NL + "      default:" + NL + "        Status = (uint32_t)SDMMC003_ERROR;" + NL + "        break;" + NL + "    } /* End of \" switch( ResponseType )\"*/" + NL + "  }/* End of \" if (CommandPtr->CommandIndex == SDMMC003_GO_IDLE_STATE || " + NL + "               CommandPtr->CommandIndex == SDMMC003_GO_INACTIVE_STATE)\"*/" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_9>>> */" + NL + "/*" + NL + " * This function issues the command." + NL + " */" + NL + "status_t SDMMC003_lSendCommand" + NL + "( " + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  uint32_t Argument," + NL + "  SDMMC003_ResponseType ResponseType," + NL + "  void *ResponsePtr" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  handle_t TimerId;" + NL + "  SDMMC003_Handle.IssueAbort = 0UL;  " + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;" + NL + "    /* Data or Command line free */" + NL + "/*<<<DD_SDMMC_nonAPI_9_1>>>*/" + NL + "    Status = SDMMC003_lCheckDatCmdline(CommandPtr);" + NL + "    if ((Status == (uint32_t)SDMMC003_DATA_LINE_BUSY) ||" + NL + "        (Status == (uint32_t)SDMMC003_CMD_LINE_BUSY))" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "      /* Set argument register */" + NL + "    SDMMC->ARGUMENT1 = Argument;" + NL + "    /* Set command register */" + NL + "    SDMMC->COMMAND = (uint16_t)(*(uint16_t *)CommandPtr);" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_CommandErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Forcefully trigger the Command Timeout Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0001 ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_EraseStartError == TRUE)" + NL + "    {" + NL + "        /* Forcefully trigger the Command Index Error Interrupt */" + NL + "        SDMMC->FORCE_EVENT_ERR_STATUS = 0x0008 ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_EraseEndError == TRUE)" + NL + "    {" + NL + "      /* Forcefully trigger the Command Index Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0008 ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Cmd55Error == TRUE)" + NL + "    {" + NL + "      /* Forcefully trigger the Command Timeout Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0001 ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Command42Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;" + NL + "    }" + NL + "#endif  /*SDMMC_UVP_TEST*/   " + NL + "/* Blocking until any of the bit in the Interrupt Status Register gets set */" + NL + "/*<<<DD_SDMMC_nonAPI_9_2>>>*/" + NL + "    TimerId = SDMMC003_lStartTimer(SDMMC003_DELAY_IN_COMMAND);" + NL + "    if(0 == TimerId)" + NL + "    {" + NL + "      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "      ERROR(GID_SDMMC00x, Status, 0, NULL);    " + NL + "      break;" + NL + "    }" + NL + "    do" + NL + "    {" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, SDMMC003_TIMEOUT_OCCURED, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while (SDMMC003_ISRContext.CmdFlag == 0);" + NL + "    SDMMC003_ISRContext.CmdFlag = 0;" + NL + "    SDMMC003_lStopTimer(TimerId);" + NL + "   /* Check for any errors */" + NL + "/*<<<DD_SDMMC_nonAPI_9_3>>> */" + NL + "    if( SDMMC003_Handle.CommandInterruptError == SDMMC003_COMMAND_COMPLETE )" + NL + "    {" + NL + "#if SDMMC_UVP_TEST" + NL + "      if(Test_TriggerInterrupt.Trigger_CommandResponseError == TRUE)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_ERROR;" + NL + "        break;" + NL + "      }" + NL + "#endif" + NL + "      /* Read response received. */" + NL + "/*<<<DD_SDMMC_nonAPI_9_4>>>*/" + NL + "      Status = SDMMC003_lReadResponse(CommandPtr,ResponseType,ResponsePtr);" + NL + "      break;" + NL + "    }" + NL + "/*<<<DD_SDMMC_nonAPI_9_5>>>*/" + NL + "    /* For Cmd8, check for  Command Timeout Interrupt */" + NL + "    else if ((CommandPtr->CommandIndex == SDMMC003_SD_SEND_IF_COND) &&" + NL + "             (SDMMC003_Handle.CommandInterruptError == \\" + NL + "                                             SDMMC003_COMMAND_TIMEOUT_ERROR))" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_COMMAND_TIMEOUT_ERROR;" + NL + "      break;" + NL + "    }" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_CommandErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Enable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk;" + NL + "      /* Enable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk;" + NL + "      SDMMC->EN_INT_STATUS_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "" + NL + "      SDMMC->EN_INT_STATUS_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "" + NL + "      SDMMC->EN_INT_STATUS_NORM |= (SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= (SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk);" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Cmd55Error == TRUE)" + NL + "    {" + NL + "        /* Enable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk;" + NL + "      /* Enable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk;" + NL + "" + NL + "       SDMMC->EN_INT_STATUS_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "" + NL + "      SDMMC->EN_INT_STATUS_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= (SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "" + NL + "      SDMMC->EN_INT_STATUS_NORM |= (SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= (SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk);" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Command42Error == TRUE)" + NL + "    {" + NL + "      /* Enable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk;" + NL + "      /* Enable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk;" + NL + "    }" + NL + "" + NL + "    if (Test_TriggerInterrupt.Trigger_EraseEndError == TRUE)" + NL + "    {" + NL + "      /* Enable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk;" + NL + "      /* Enable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_EraseStartError == TRUE)" + NL + "    {" + NL + "      /* Enable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |=  SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk;" + NL + "        /* Disable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |=  SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk ;" + NL + "    }" + NL + "#endif  /*SDMMC_UVP_TEST*/" + NL + "" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_TC8Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_TC10Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_TC13Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_TC17Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_TC20Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;" + NL + "    }" + NL + "#endif /* SDMMC_UVP_TEST  */" + NL + "/*<<<DD_SDMMC_nonAPI_9_6>>>*/" + NL + "    if (CommandPtr->DataPresentSelect == 1)" + NL + "    {" + NL + "      SDMMC003_Handle.IssueAbort = 1UL;" + NL + "    }    " + NL + "    /* Error Recovery for the failed command  */" + NL + "    Status = SDMMC003_lErrorInterruptRecovery( \\" + NL + "                                   SDMMC003_ISRContext.InterruptStatusShadow, \\" + NL + "                                   SDMMC003_Handle.IssueAbort);" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_10>>> */" + NL + "/*" + NL + " * This function sets the voltage window in OCR register" + NL + " */" + NL + "status_t  SDMMC003_lSetVoltageWindow()" + NL;
  protected final String TEXT_5 = "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  uint32_t CardStatus = 0;" + NL + "  uint32_t Argument = 0;" + NL + "  uint32_t LoopCount= 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "/* <<<DD_SDMMC_nonAPI_10_1>>> */" + NL + "  /* For Standard Capacity Card  */" + NL + "  if (SDMMC003_Handle.f8 == 0)" + NL + "  {" + NL + "    /* Set HCS = 0  */" + NL + "    Argument = SDMMC003_SD_ACMD41_F80_ARG;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_10_2>>> */" + NL + "  /* For High Capacity Card */" + NL + "  else" + NL + "  {" + NL + "    /* Set  HCS = 1 */" + NL + "    Argument = SDMMC003_SD_ACMD41_F81_ARG;" + NL + "  }" + NL + "  do" + NL + "  {" + NL + "    /*Send Command55 for Application Specific Command with default RCA as 0*/" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), \\" + NL + "                                     SDMMC003_ARGUMENT0, SDMMC003_RESPONSE_R1,\\" + NL + "                                     &CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_10_3>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* Send ACMD41 to Set the card's voltage window */" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(62)), Argument,\\" + NL + "                                  SDMMC003_RESPONSE_R3,&(SDMMC003_CardInfo.Ocr));" + NL + "/* <<<DD_SDMMC_nonAPI_10_4>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS && \\" + NL + "       (Status != (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR))" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    /* Cards takes some time to set power status bit. Card must repsond " + NL + "    within 1 sec. */" + NL + "    /* Timeout of 10ms.*/" + NL + "    SDMMC003_lDelay(SDMMC003_CARD_POWER_DELAY);" + NL + "/* Check for busy bit in the OCR content i.e response */" + NL + "  } while(!(SDMMC003_CardInfo.Ocr & SDMMC003_OCR_POWER_STATUS_BITMASK) &&\\" + NL + "           ( (LoopCount++)<50 ) );" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_11>>> */" + NL + "/*" + NL + " * This function queries Voltage operating condition of the card." + NL + " */" + NL + "status_t SDMMC003_lQueryOperatingCond()" + NL + "{" + NL + "  uint32_t ResponseData = 0;" + NL + "  status_t Status;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /*Query voltage operating condition i.e. cmd8 */" + NL + "  Status = SDMMC003_lSendCommand(&(SDMMC003_SD_COMMAND(8)),SDMMC003_SD_CMD8_ARG,\\" + NL + "                                  SDMMC003_RESPONSE_R7, &ResponseData );" + NL + "  do" + NL + "  {" + NL + "/*<<<DD_SDMMC_nonAPI_11_1>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "    {" + NL + "/*<<<DD_SDMMC_nonAPI_11_2>>> */" + NL + "      /*  No response is received for Standard Capacity SD cards or MMC card. */" + NL + "      if (SDMMC003_Handle.CommandInterruptError ==SDMMC003_COMMAND_TIMEOUT_ERROR)" + NL + "      {" + NL + "        SDMMC003_Handle.f8 = 0;" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "      /*<<<DD_SDMMC_nonAPI_11_3>>> */" + NL + "      else" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /* Response received i.e. High Capacity cards. */" + NL + "/*<<<DD_SDMMC_nonAPI_11_4>>> */" + NL + "    else" + NL + "    {" + NL + "/*<<<DD_SDMMC_nonAPI_11_5>>> */" + NL + "      /* Check whether Check pattern matches in the Argument and Response */" + NL + "      if (((ResponseData >> SDMMC003_SD_CMD8_CHECK_PATTERN_BITPOS) &\\" + NL + "             SDMMC003_SD_CMD8_CHECK_PATTERN_BITMASK) != \\" + NL + "            (SDMMC003_SD_CMD8_CHECK_PATTERN_VALUE)" + NL + "         )" + NL + "      {" + NL + "        Status  = (uint32_t)SDMMC003_BAD_RESPONSE;" + NL + "        break;" + NL + "      }" + NL + "/*<<<DD_SDMMC_nonAPI_11_6>>> */" + NL + "      /* Check the Voltage Supplied is Accepted by the card in the response  */" + NL + "      if( ((uint8_t)( ResponseData >> SDMMC003_SD_CMD8_VHS_BITPOS) &\\" + NL + "                     SDMMC003_SD_CMD8_VHS_BITMASK)!=  \\" + NL + "                     ( SDMMC003_SD_VHS_PATTERN_2_7_3_6_VALUE ) )" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_BAD_RESPONSE;" + NL + "        break;" + NL + "      }" + NL + "      /* Set Flag f8 */" + NL + "      SDMMC003_Handle.f8 = 1;" + NL + "    }" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_12>>> */" + NL + "/*" + NL + " * This function queries voltage supported from the card." + NL + " */" + NL + "status_t SDMMC003_lQueryVoltage (uint32_t Argument)" + NL + "{" + NL + "  uint32_t CardStatus = 0;" + NL + "  status_t Status;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Send Command55 for Application Specific Command with default RCA as 0*/" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), Argument,\\" + NL + "                                    SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_12_1>>> */" + NL + "    if (Status != DAVEApp_SUCCESS )" + NL + "    {" + NL + "      /* Some SD cards which doesn't supports CMD8 treat cmd55 as illegal so" + NL + "       * ignore this error */" + NL + "/*<<<DD_SDMMC_nonAPI_12_2>>> */" + NL + "      if (!( (Status == (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR) && \\" + NL + "             (SDMMC003_Handle.f8 == 0) ))" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /* Send ACMD41 to query the card's voltage window */" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(62)), Argument,\\" + NL + "                                   SDMMC003_RESPONSE_R3,&(SDMMC003_CardInfo.Ocr));" + NL + "/*<<<DD_SDMMC_nonAPI_12_3>>> */" + NL + "    if ( (Status != (uint32_t)DAVEApp_SUCCESS) &&\\" + NL + "         (Status != (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR))" + NL + "    {" + NL + "      /* No response means SDMMC_MMC card */" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "/*<<<DD_SDMMC_nonAPI_12_4>>> */" + NL + "      if (Status == (uint32_t) SDMMC003_COMMAND_TIMEOUT_ERROR)" + NL + "      {" + NL + "        Status  =  (uint32_t)SDMMC003_lInitializeMmcCard();" + NL + "        break;" + NL + "      }" + NL + "      else" + NL + "#endif /* SDMMC_SUPPORT_MMC_CARD */" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /* Send ACMD41 with voltage window argument set */" + NL + "/*<<<DD_SDMMC_nonAPI_12_5>>> */" + NL + "    Status = SDMMC003_lSetVoltageWindow();" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* SD Card Type */" + NL + "/*<<<DD_SDMMC_nonAPI_12_6>>> */" + NL + "    SDMMC003_lWriteCardType();" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_SDMMC_nonAPI_13>>> */" + NL + "/*" + NL + " * This function reads the card registers after the card is initialized." + NL + " */" + NL + "status_t SDMMC003_lAfterCardInitialize()" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "   /* Read CSD & SCR Register & Card Write Protection Flags. */" + NL + "    Status = SDMMC003_lReadCardRegisters();" + NL + "/*<<<DD_SDMMC_nonAPI_13_1>>> */" + NL + "    if(Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "#if SDMMC_SUPPORT_4_BUS_WIDTH" + NL + "    /* Switch  to 4-bit bus width if supported */" + NL + "    Status = SDMMC003_lSwitchBusWidth();" + NL + "/*<<<DD_SDMMC_nonAPI_13_2>>> */" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "    {" + NL + "      /* Change bus width to default in the Host Controller */" + NL + "      CLR_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos);" + NL + "    }" + NL + "    /* Switch  to High Speed Mode */" + NL + "    Status = SDMMC003_lSwitchSpeed();" + NL + "/*<<<DD_SDMMC_nonAPI_13_3>>> */" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "    {" + NL + "      /* Change Speed mode to default in the Host Controller */" + NL + "      CLR_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_HIGH_SPEED_EN_Pos );" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "#endif" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_14>>> */" + NL + "/*" + NL + " * This function initializes the SD card." + NL + " */" + NL + "status_t SDMMC003_lInitializeCard()" + NL + "{" + NL + "  status_t Status;" + NL + "  uint32_t LockStatus ;" + NL + "  uint8_t Count= 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_SDMMC_nonAPI_14_1>>> */" + NL + "    /* Repeat the below steps 2 times if bad response is received.    */" + NL + "    do" + NL + "    {" + NL + "      /* Reset the card. i.e cmd0 */" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(0)), \\" + NL + "                                        SDMMC003_ARGUMENT0, \\" + NL + "                                        SDMMC003_NO_RESPONSE, \\" + NL + "                                        NULL);" + NL + "/* <<<DD_SDMMC_nonAPI_14_2>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }/* End of \"if(Status != DAVEApp_SUCCESS )\" */" + NL + "      /* Query the Operation Condition Info from the card.*/" + NL + "/* <<<DD_SDMMC_nonAPI_14_3>>> */" + NL + "      Status = SDMMC003_lQueryOperatingCond();" + NL + "      Count++;" + NL + "    } while(( Count < SDMMC003_NUM_CARD_RESET_RETRIES) && \\" + NL + "            ( Status == (uint32_t)SDMMC003_BAD_RESPONSE));" + NL + "/* <<<DD_SDMMC_nonAPI_14_4>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }/* End of \"if(Status != DAVEApp_SUCCESS )\" */" + NL + "    /* Query & Set voltage window  */" + NL + "" + NL + "    Status = SDMMC003_lQueryVoltage(SDMMC003_CardInfo.Rca);" + NL + "/* <<<DD_SDMMC_nonAPI_14_5>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Read CID */" + NL + "    Status = SDMMC003_lSendCommand(&(SDMMC003_COMMON_COMMAND(2)), \\" + NL + "                                     SDMMC003_ARGUMENT0,SDMMC003_RESPONSE_R2, \\" + NL + "                                     (void *)SDMMC003_CardInfo.CidArray);" + NL + "/* <<<DD_SDMMC_nonAPI_14_6>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Read RCA */" + NL + "    Status = SDMMC003_lReadRca();" + NL + "/* <<<DD_SDMMC_nonAPI_14_7>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    } " + NL + "    /* Check the card Lock/ Unlock Status */" + NL + "    Status = SDMMC003_GetLockStatus(&LockStatus);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_14_8>> */" + NL + "    if (LockStatus == (uint32_t)SDMMC003_CARD_IS_LOCKED)" + NL + "    {" + NL + "      SDMMC003_Handle.State |= SDMMC003_STATE_CARD_LOCKED ;" + NL + "      Status = (uint32_t)SDMMC003_INITIALIZED_BUT_LOCKED;     " + NL + "    }" + NL + "    /* Update card initialization Status */" + NL + "    SDMMC003_Handle.State |= SDMMC003_STATE_CARD_INITIALIZED;" + NL + "    SDMMC003_Handle.State &=  ~(SDMMC003_STATE_NO_CARD);" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_15>>> */" + NL + "/*" + NL + " * This function finds out the card Type information." + NL + " */" + NL + "void SDMMC003_lWriteCardType()" + NL + "{" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /* If F8 =0 , Standard Capacity V1 Card */" + NL + "/* <<<DD_SDMMC_nonAPI_15_1>>> */" + NL + "  if ( SDMMC003_Handle.f8 == 0)" + NL + "  {" + NL + "    SDMMC003_Handle.CardType |= SDMMC003_SD_STANDARD_CAPACITY_V1x;" + NL + "  }" + NL + "  /* If F8 =1 , Standard Capacity V2 or High Capacity Card */" + NL + "/* <<<DD_SDMMC_nonAPI_15_2>>> */" + NL + "  else" + NL + "  {" + NL + "    /* Check CCS bit in the OCR register, CCS=1 means High Capacity  card*/" + NL + "/* <<<DD_SDMMC_nonAPI_15_3>>> */" + NL + "    if ((SDMMC003_CardInfo.Ocr & SDMMC003_OCR_CCS_BITMASK ) != 0)" + NL + "    {" + NL + "      SDMMC003_Handle.CardType |= SDMMC003_SD_HIGH_CAPACITY | \\" + NL + "                                  SDMMC003_BLOCK_ADDRESSING;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_15_4>>> */" + NL + "    /* CCS=0 means Standard Capacity Version2*/" + NL + "    else" + NL + "    {" + NL + "      SDMMC003_Handle.CardType |= SDMMC003_SD_STANDARD_CAPACITY_V2;" + NL + "    }" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_16>>> */" + NL + "/*" + NL + " * This function finds out the Write protection status of the card." + NL + " */" + NL + "status_t SDMMC003_lSetWriteProtect (void)" + NL + "{" + NL + "  uint32_t SdStatus[16] = {0};" + NL + "  uint32_t WriteProtect;" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "    SDMMC003_MMCCSDType *TmpMmcCsdPtr;" + NL + "/* <<<DD_SDMMC_nonAPI_16_1>>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_MMC) != 0)" + NL + "    {" + NL + "      TmpMmcCsdPtr = (SDMMC003_MMCCSDType *)&SDMMC003_CardInfo.CsdArray;" + NL + "      /* Read Write Protection bits from CSD Register i.e both Temp & Permanent */" + NL + "/* <<<DD_SDMMC_nonAPI_16_2>>> */" + NL + "      if ( ((TmpMmcCsdPtr->TempWriteProtect) != 0) || \\" + NL + "           ((TmpMmcCsdPtr->PermWriteProtect) != 0))" + NL + "      {" + NL + "        SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_CARD_WRITE_PROTECT;" + NL + "      }" + NL + "    }" + NL + "    else" + NL + "#endif" + NL + "    {" + NL + "      /* SD Card Write Protection.  */" + NL + "      Status  = SDMMC003_GetSdStatus((void*)&(SdStatus[0]));" + NL + "/* <<<DD_SDMMC_nonAPI_16_3>>> */" + NL + "      if (Status != DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "/* <<<DD_SDMMC_nonAPI_16_4>>> */" + NL + "      /* Bits 480:495 in the SD status gives the Write Protection Information */" + NL + "      WriteProtect = ((SdStatus[0] & 0xFF000000) >> 24 ) | " + NL + "                     (((SdStatus[0] & 0x00FF0000) >> 16 ) << 8) ;" + NL + "      if ( (WriteProtect & SDMMC003_SD_CARD_TYPE_BITMASK) != 0 )" + NL + "      {" + NL + "        SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_CARD_WRITE_PROTECT;" + NL + "      }" + NL + "    }" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_17>>> */" + NL + "/*" + NL + " * This function reads the  Relative card address of the card." + NL + " */" + NL + "status_t SDMMC003_lReadRca()" + NL + "{" + NL + "  status_t Status ;" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "  uint32_t CardStatus = 0;" + NL + "#endif /* SDMMC_SUPPORT_MMC_CARD */" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /*  Read RCA for MMC card */" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "/* <<<DD_SDMMC_nonAPI_17_1>>> */" + NL + "  if ((SDMMC003_Handle.CardType & SDMMC003_MMC) != 0)" + NL + "  {" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(3))," + NL + "                                    (uint32_t)SDMMC003_MMC_DEFAULT_RCA,  \\" + NL + "                                    SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "    SDMMC003_CardInfo.Rca = SDMMC003_MMC_DEFAULT_RCA;" + NL;
  protected final String TEXT_6 = "  }" + NL + "  /*  Read RCA for SD  */" + NL + "  else" + NL + "#endif" + NL + "  {" + NL + "/* <<<DD_SDMMC_nonAPI_17_2>>> */" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(3)), \\" + NL + "                                    SDMMC003_ARGUMENT0, \\" + NL + "                                    SDMMC003_RESPONSE_R6, \\" + NL + "                                    &(SDMMC003_CardInfo.Rca));" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_18>>> */" + NL + "/*" + NL + " * This function initializes the MMC card." + NL + " */" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "/* SDMMC_MMC Initialize */" + NL + "status_t SDMMC003_lInitializeMmcCard()" + NL + "{" + NL + "  status_t Status;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Reset the card. i.e cmd0 */" + NL + "    Status = (uint32_t)SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(0)), \\" + NL + "                                                SDMMC003_ARGUMENT0,  \\" + NL + "                                                SDMMC003_NO_RESPONSE, NULL);" + NL + "/* <<<DD_SDMMC_nonAPI_18_1>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "    {" + NL + "      break;" + NL + "    }/* End of \"if(Status != DAVEApp_SUCCESS )\" */" + NL + "   /*Command1 indicating support for high capacity cards & voltage 2.7 to 3.6v */" + NL + "    do" + NL + "    {" + NL + "      Status = SDMMC003_lSendCommand(&(SDMMC003_MMC_COMMAND(1)), \\" + NL + "                                        MMC_CMD1_ARG ,SDMMC003_RESPONSE_R3,\\" + NL + "                                        &(SDMMC003_CardInfo.Ocr) );" + NL + "/* <<<DD_SDMMC_nonAPI_18_2>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "      {" + NL + "        break;" + NL + "      }/* End of \"if(Status != DAVEApp_SUCCESS )\" */" + NL + "    } while(SDMMC003_CardInfo.Ocr & SDMMC003_OCR_POWER_STATUS_BITMASK );" + NL + "   /* Check mode. 00b (byte mode) & 10b (sector mode)*/" + NL + "/* <<<DD_SDMMC_nonAPI_18_3>>> */" + NL + "    if( ((SDMMC003_CardInfo.Ocr & SDMMC003_MMC_OCR_ACCESS_MODE_BITMASK) >> \\" + NL + "       (SDMMC003_MMC_OCR_ACCESS_MODE_BITPOS) != 0))" + NL + "    {" + NL + "      SDMMC003_Handle.CardType |= SDMMC003_BLOCK_ADDRESSING;" + NL + "    }" + NL + "    SDMMC003_Handle.CardType |= SDMMC003_MMC;" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "#endif" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_19>>> */" + NL + "/*" + NL + " * This function reads the CSD, SCR and Write protection status of the card." + NL + " */" + NL + "status_t SDMMC003_lReadCardRegisters (void)" + NL + "{" + NL + "  uint32_t Argument = 0;" + NL + "  uint32_t CardStatus = 0;" + NL + "  status_t Status;" + NL + "  SDMMC003_SCRType ScrContent = {0};" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Read CSD Register  */" + NL + "    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(9)),Argument, \\" + NL + "                                     SDMMC003_RESPONSE_R2, \\" + NL + "                                     (void *)SDMMC003_CardInfo.CsdArray);" + NL + "/* <<<DD_SDMMC_nonAPI_19_1>>> */" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Set Write protection flags */" + NL + "    Status = SDMMC003_lSetWriteProtect();" + NL + "/* <<<DD_SDMMC_nonAPI_19_2>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_19_3>>> */" + NL + "    /* Read SCR register for SD card */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_MMC) == 0)" + NL + "    {" + NL + "      /* Switch to Transferring State. */" + NL + "      Status = SDMMC003_lSwitchToTransferState();" + NL + "/* <<<DD_SDMMC_nonAPI_19_4>>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }   " + NL + "      /*Send the Application Specific Command i.e. Command 55.*/" + NL + "      Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)),Argument, \\" + NL + "                                      SDMMC003_RESPONSE_R1, &CardStatus );" + NL + "/* <<<DD_SDMMC_nonAPI_19_5>>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Set Direction Select bit in the Transfer Mode register */" + NL + "      SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);" + NL + "      /* Read the transferred SCR data*/" + NL + "      Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(64)), \\" + NL + "                                              SDMMC003_ARGUMENT0,8, \\" + NL + "                                              (uint32_t *)&ScrContent, \\" + NL + "                                              SDMMC003_READ_FROM_BUFF);" + NL + "      SDMMC003_CardInfo.Scr  =   ScrContent;" + NL + "/* <<<DD_SDMMC_nonAPI_19_6>>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      } " + NL + "    } /* End of \" if ((SDMMC003_Handle.CardType & SDMMC003_MMC) == 0)\"*/" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_20>>> */" + NL + "/*" + NL + " * This function configures the registers for Single Block Transfer." + NL + " */" + NL + "status_t SDMMC003_lConfigureForSingleTransfer" + NL + "(" + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  uint32_t Argument," + NL + "  uint16_t BlockSize" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  uint32_t CardStatus = 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Set Block Size Register */" + NL + "    WR_REG( SDMMC->BLOCK_SIZE,SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Msk , \\" + NL + "            SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Pos,BlockSize );" + NL + "    /* Clear the Multi Block Select bit */" + NL + "    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_MULTI_BLOCK_SELECT_Pos);" + NL + "    /* Clear the ACMD Enable bit*/" + NL + "    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_ACMD_EN_Pos);" + NL + "    /* Clear the Block Count Enable bit*/" + NL + "    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_BLOCK_COUNT_EN_Pos);" + NL + "" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_TC13Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt =TRUE ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_TC20Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt =TRUE ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Command42Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt =TRUE ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_CommandErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Disable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "      /* Disable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk);" + NL + "" + NL + "      /* Disable the Buffer Ready Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      /* Disable the Buffer Write  Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "       /* Disable the Transfer Complete  Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk);" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_DataErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Disable the Buffer Ready Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      /* Disable the Buffer Ready Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "    }" + NL + "#endif" + NL + "    /* Send Single Block Transfer Command */" + NL + "    Status = (uint32_t)SDMMC003_lSendCommand( CommandPtr, Argument, \\" + NL + "                                              SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_20_1>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_21>>> */" + NL + "/*" + NL + " * This function configures the registers for Multiple Block Transfer." + NL + " */" + NL + "status_t SDMMC003_lConfigureRegForMultiTransfer" + NL + "(" + NL + "  uint32_t *TmpAddrPtr," + NL + "  uint32_t NumberOfBlocks," + NL + "  const SDMMC003_CommandType *CommandPtr" + NL + ")" + NL + "{" + NL + "  status_t Status;" + NL + "  uint32_t CardStatus = 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Block Addressing */" + NL + "    /* <<<DD_SDMMC_nonAPI_21_1>>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)" + NL + "    {" + NL + "      *TmpAddrPtr *= 512UL;" + NL + "    }" + NL + "    /* Set Block Size Register */" + NL + "    WR_REG( SDMMC->BLOCK_SIZE,SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Msk , \\" + NL + "            SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Pos,SDMMC003_TX_BLOCK_SIZE_VALUE);" + NL + "    /* Set Transfer Mode Register */" + NL + "    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_MULTI_BLOCK_SELECT_Pos);" + NL + "    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_ACMD_EN_Pos);" + NL + "    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_BLOCK_COUNT_EN_Pos);" + NL + "" + NL + "    /* Set Block Count Register */" + NL + "    WR_REG( SDMMC->BLOCK_COUNT, SDMMC_BLOCK_COUNT_BLOCK_COUNT_Msk ,   \\" + NL + "            SDMMC_BLOCK_COUNT_BLOCK_COUNT_Pos, NumberOfBlocks);" + NL + "" + NL + "    /* Enable ACMD 12 Interrupt Signal  */" + NL + "    SDMMC->EN_INT_SIGNAL_ERR &= ~SDMMC_EN_INT_SIGNAL_ERR_ACMD_ERR_EN_Msk;" + NL + "    SDMMC->EN_INT_SIGNAL_ERR |= SDMMC_EN_INT_SIGNAL_ERR_ACMD_ERR_EN_Msk;" + NL + "" + NL + "#if SDMMC_UVP_TEST " + NL + "    if ( Test_TriggerInterrupt.Trigger_TC8Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = TRUE;" + NL + "    }" + NL + "    if ( Test_TriggerInterrupt.Trigger_TC10Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = TRUE;" + NL + "    }" + NL + "    if ( Test_TriggerInterrupt.Trigger_TC17Error == TRUE)" + NL + "    {" + NL + "      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = TRUE;" + NL + "    }" + NL + "" + NL + "    if (Test_TriggerInterrupt.Trigger_CommandErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Disable the Command Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "      /* Disable the Command Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk);" + NL + "      /* Disable the Buffer Ready Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      /* Disable the Buffer Write Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      /* Disable the Transfer Complete Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk);" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_DataErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Disable the Buffer Ready Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk);" + NL + "" + NL + "       /* Disable the Buffer Ready Status & Signal Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);" + NL + "    }" + NL + "#endif" + NL + "   /* Send Multiple Block  Transfer Command */" + NL + "    Status = SDMMC003_lSendCommand( CommandPtr,  *TmpAddrPtr, \\" + NL + "                                    SDMMC003_RESPONSE_R1, &CardStatus );" + NL + "/* <<<DD_SDMMC_nonAPI_21_2>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_22>>> */" + NL + "/*" + NL + " * This function is used to transfer multiple blocks of data." + NL + " */" + NL + "status_t SDMMC003_lMultiBlockTransfer( uint32_t *AddrPtr,uint32_t NumberOfBlocks,\\" + NL + "                                       const SDMMC003_CommandType *CommandPtr, \\" + NL + "                                       uint32_t *BufferPtr, \\" + NL + "                                       SDMMC003_DataTrasferType TransferMode" + NL + "                                     )" + NL + "{" + NL + "  status_t Status ;" + NL + "  SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;" + NL + "  do" + NL + "  {" + NL + "    /* Configure Registers for Multi block transfer*/" + NL + "    Status = SDMMC003_lConfigureRegForMultiTransfer( AddrPtr, \\" + NL + "                                                    NumberOfBlocks,CommandPtr );" + NL + "/* <<<DD_SDMMC_nonAPI_22_1>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "       break;" + NL + "    }" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_DataErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Forcefully trigger the Data Crc Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0020 ;" + NL + "    }" + NL + "#endif" + NL + " /* Read/Write  Block Data  */" + NL + "/* <<<DD_SDMMC_nonAPI_22_2>>> */" + NL + "    while( NumberOfBlocks > 0 )" + NL + "    {" + NL + "      /* Perform Transfer */" + NL + "      Status = SDMMC003_lDataTransfer( BufferPtr, TransferMode,  \\" + NL + "                                       SDMMC003_NUM_QUADLETS_IN_BLOCK);" + NL + "/* <<<DD_SDMMC_nonAPI_22_3>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Decrement Number of blocks Variable */" + NL + "      NumberOfBlocks--;" + NL + "      /* Pointer pointing to the next Block Pointer*/" + NL + "      BufferPtr += SDMMC003_NUM_QUADLETS_IN_BLOCK;" + NL + "    }/* End of \" while( NumberOfBlocks > 0 )\"*/" + NL + "/* <<<DD_SDMMC_nonAPI_22_4>>> */" + NL + "    if ( Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "     /* Block on Transfer Complete Interrupt */" + NL + "/* <<<DD_SDMMC_nonAPI_22_5>>> */      " + NL + "      /* Timeout of 5ms.*/" + NL + "      Status = SDMMC003_lTransferDelay(SDMMC003_DELAY_IN_TRANSFER);" + NL + "      if(Status != (uint32_t) DAVEApp_SUCCESS)" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "/* <<<DD_SDMMC_nonAPI_22_6>>> */" + NL + "    }/* End of \" if ( Status == (uint32_t)DAVEApp_SUCCESS)\"*/" + NL + "    /* Check Transfer Completed Successfully */" + NL + "/* Check ACMD status*/" + NL + "/* <<<DD_SDMMC_nonAPI_22_7>>> */" + NL + "    if(SDMMC003_Handle.AcmdInterruptError == SDMMC003_ACMD12_ERROR)" + NL + "    {" + NL + "      /* Call ACMD12 Error Recovery */" + NL + "      SDMMC003_lAcmdErrorRecovery();" + NL + "    }" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_23>>> */" + NL + "/*" + NL + " * This function performs the  Single Block Transfer." + NL + " */" + NL + "status_t SDMMC003_lSingleBlockTransfer" + NL + "(" + NL + "  const SDMMC003_CommandType *CommandPtr," + NL + "  uint32_t Argument," + NL + "  uint16_t BlockSize," + NL + "  uint32_t *BufferPtr," + NL + "  SDMMC003_DataTrasferType TransferMode" + NL + ")" + NL + "{" + NL + "  status_t Status;" + NL + "  handle_t TimerId;" + NL + "  do" + NL + "  {" + NL + "    /* Configure Register  for Single Block Transfer */" + NL + "    Status = SDMMC003_lConfigureForSingleTransfer(CommandPtr,Argument,BlockSize);" + NL + "/* <<<DD_SDMMC_nonAPI_23_1>>> */" + NL + "    if ((uint32_t)DAVEApp_SUCCESS != Status)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_DataErrorInterrupt == TRUE)" + NL + "    {" + NL;
  protected final String TEXT_7 = "      /* Forcefully trigger the Data Crc Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0020 ;" + NL + "    }" + NL + "#endif" + NL + "    /* Perform Data Transfer */" + NL + "    Status = SDMMC003_lDataTransfer(BufferPtr,TransferMode,(BlockSize/4));" + NL + "/* <<<DD_SDMMC_nonAPI_23_2>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* Block on Transfer Complete Interrupt */" + NL + "    /* Timeout of 5ms.*/" + NL + "    TimerId = SDMMC003_lStartTimer (SDMMC003_DELAY_IN_TRANSFER);" + NL + "    if(0 == TimerId)" + NL + "    {" + NL + "      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "      ERROR(GID_SDMMC00x, Status, 0, NULL);   " + NL + "      break; " + NL + "    }" + NL + "    do" + NL + "    {" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while (SDMMC003_ISRContext.TransferFlag == 0);" + NL + "    SDMMC003_lStopTimer(TimerId);" + NL + "    SDMMC003_ISRContext.TransferFlag = 0;" + NL + "    /* Check Transfer Complete Status */" + NL + "/* <<<DD_SDMMC_nonAPI_23_4>>> */" + NL + "    if (SDMMC003_Handle.TransferInterruptError == SDMMC003_TRANSFER_COMPLETE )" + NL + "    {" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_23_5>>> */" + NL + "    else" + NL + "    {" + NL + "      SDMMC003_Handle.IssueAbort = 1;" + NL + "      Status = SDMMC003_lErrorInterruptRecovery(\\" + NL + "                                    SDMMC003_ISRContext.InterruptStatusShadow, \\" + NL + "                                    SDMMC003_Handle.IssueAbort);" + NL + "      break;" + NL + "    }" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_24>>> */" + NL + "/*" + NL + " * This function checks the Lock Status ." + NL + " */" + NL + "status_t SDMMC003_lCheckLockStatus( SDMMC003_CardLockMode OperationMode )" + NL + "{" + NL + "  status_t Status ;" + NL + "  uint32_t LockStatus = 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  Status =  SDMMC003_GetLockStatus(&LockStatus);" + NL + "  /* For Lock, Card State must be locked */" + NL + "/* <<<DD_SDMMC_nonAPI_24_1>>> */" + NL + "  if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    if ((LockStatus == (uint32_t)SDMMC003_CARD_IS_LOCKED) && \\" + NL + "                        (OperationMode == SDMMC003_LOCK) )" + NL + "    {" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_24_2>>> */" + NL + "    /* For UnLock, Card State must be unlock */" + NL + "    else if( (LockStatus == (uint32_t)SDMMC003_CARD_UNLOCKED) && \\" + NL + "             (OperationMode == SDMMC003_UNLOCK) )" + NL + "    {" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "    /* Some Error */" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_LOCK_UNLOCK_ERROR;" + NL + "    }" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_25>>> */" + NL + "/*" + NL + " * This function switches the bus width to 4-bit if is supported." + NL + " */" + NL + "status_t SDMMC003_lSwitchBusWidth(void)" + NL + "{" + NL + "  uint32_t Argument = 0;" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  uint32_t CardStatus = 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Switch to transfer state i.e. CMD7 */" + NL + "    Status = SDMMC003_lSwitchToTransferState();" + NL + "/* <<<DD_SDMMC_nonAPI_25_1>>> */" + NL + "    if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Disable Card Interrupt */" + NL + "    CLR_BIT( SDMMC->EN_INT_SIGNAL_NORM, SDMMC_EN_INT_STATUS_NORM_CARD_INS_EN_Pos );" + NL + "    /* MMC Card */" + NL + "/* <<<DD_SDMMC_nonAPI_25_2>>> */" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_MMC) != 0)" + NL + "    {" + NL + "      Status = SDMMC003_lSendCommand (&(SDMMC003_MMC_COMMAND(6)), \\" + NL + "                                      MMC_4BUS_WIDTH_ARG,\\" + NL + "                                      SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_25_3>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "/* SD card */" + NL + "    else" + NL + "#endif /* SDMMC_SUPPORT_MMC_CARD*/" + NL + "    {" + NL + "/* <<<DD_SDMMC_nonAPI_25_4>>> */" + NL + "      /* Check the Data Transfer width supported in SCR Register */" + NL + "      if( !(SDMMC003_CardInfo.Scr.SdBusWidth & SDMMC003_SCR_BUS_WIDTH4_BITMASK))" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Set the Argument.*/" + NL + "      Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "      /* Send Application Specific Command */" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), \\" + NL + "                                      Argument, SDMMC003_RESPONSE_R1, \\" + NL + "                                      &CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_25_5>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Send ACMD6 to switch the bus width. */" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(58)), \\" + NL + "                                      SDMMC003_SD_4BUS_WIDTH_ARG, \\" + NL + "                                      SDMMC003_RESPONSE_R1, \\" + NL + "                                      &CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_25_6>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /* Set Data Transfer Width  in Host Control Register. */" + NL + "    SET_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos);" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_26>>> */" + NL + "/*" + NL + " * This function switches the card speed to high speed if is supported." + NL + " */" + NL + "status_t  SDMMC003_lSwitchSpeed( void)" + NL + "{" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "uint32_t CardStatus;" + NL + "#endif" + NL + "  uint32_t SwitchStatus[16] = {0 };" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "/* <<<DD_SDMMC_nonAPI_26_1>>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_MMC) != 0)" + NL + "    {" + NL + "      /* Switch to transfer state i.e. CMD7 */" + NL + "      Status = SDMMC003_lSwitchToTransferState();" + NL + "      if( Status != DAVEApp_SUCCESS )" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      Status = SDMMC003_lSendCommand(&(SDMMC003_MMC_COMMAND(6))," + NL + "                                       MMC_HIGH_SPEED_ARG,\\" + NL + "                                       SDMMC003_RESPONSE_R1,&CardStatus);" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /* SD card */" + NL + "    else" + NL + "#endif /* SDMMC_SUPPORT_MMC_CARD */" + NL + "    {" + NL + "/* <<<DD_SDMMC_nonAPI_26_2>>> */" + NL + "      /* Check CMD6 support in SCR register*/" + NL + "      if ( SDMMC003_CardInfo.Scr.SdSpec == 0 )" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Switch to transfer state i.e. CMD7 */" + NL + "      Status = SDMMC003_lSwitchToTransferState();" + NL + "/* <<<DD_SDMMC_nonAPI_26_3>>> */" + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Send the Switch function  command and read the transferred block of" + NL + "       * data from the card */" + NL + "      Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(6)), \\" + NL + "                                               SDMMC003_SD_HIGH_SPEED_ARG,64, \\" + NL + "                                               (uint32_t*)SwitchStatus, \\" + NL + "                                               SDMMC003_READ_FROM_BUFF" + NL + "                                            );" + NL + "/* <<<DD_SDMMC_nonAPI_26_4>>> */" + NL + "      if ( Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "/* <<<DD_SDMMC_nonAPI_26_5>>> */" + NL + "      if ( ((SwitchStatus[4] & SDMMC003_SWITCH_FUNC_GRP1_STATUS_BITMASK)>>" + NL + "            SDMMC003_SWITCH_FUNC_GRP1_STATUS_BITPOS) != 1UL )" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_ERROR;" + NL + "        break;" + NL + "      }" + NL + "      /* Change Speed mode in the Host Controller */" + NL + "      SET_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_HIGH_SPEED_EN_Pos );" + NL + "    }" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function provides delay in command execution." + NL + " */" + NL + "status_t SDMMC003_lCommandDelay(uint32_t DelayTime)" + NL + "{" + NL + "  handle_t TimerId;" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  SDMMC003_Handle.TimerExpire = 1;" + NL + "  TimerId = SDMMC003_lStartTimer(DelayTime);" + NL + "  if(0 == TimerId)" + NL + "  {" + NL + "    Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "  }" + NL + "  if(Status != (uint32_t) SDMMC003_START_TIMER_FAILED)" + NL + "  {" + NL + "    do" + NL + "    {" + NL + "      /* If any error interrupt bit is set, then break*/" + NL + "      if (SDMMC->INT_STATUS_NORM &  SDMMC_INT_STATUS_NORM_ERR_INT_Msk )" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while (!(SDMMC003_ISRContext.CmdFlag  || \\" + NL + "             SDMMC003_ISRContext.DataFlag ));" + NL + "  }" + NL + "  SDMMC003_lStopTimer(TimerId);" + NL + "  SDMMC003_ISRContext.CmdFlag = 0;" + NL + "  SDMMC003_ISRContext.DataFlag = 0;" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_27>>> */" + NL + "/*" + NL + " * This function performs the recovery task if any error interrupt occurs." + NL + " */" + NL + "status_t SDMMC003_lErrorInterruptRecovery(uint16_t InterruptStatus," + NL + "                                                    uint8_t IssueAbort)" + NL + "{" + NL + "  status_t Status =  (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    /* Disable the Error Interrupt Signal  */" + NL + "    SDMMC->EN_INT_SIGNAL_ERR = 0;" + NL + "    /* Check Error Interrupt Status bits D0-D3 for CMD line errors */" + NL + "/* <<<DD_SDMMC_nonAPI_27_1>>> */" + NL + "    if ( ((InterruptStatus & SDMMC003_ERROR_CMD_STATUS_BITMASK) != 0 ) ||  \\" + NL + "         ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_CMD_Msk ))" + NL + "    {" + NL + "      /* Set Software Reset for CMD Line  */" + NL + "      Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk);" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_27_2>>> */" + NL + "    /* Check Error Interrupt Status bits D4-D6 for Data line errors */" + NL + "    if ( ((InterruptStatus & SDMMC003_ERROR_DATA_STATUS_BITMASK) != 0 ) ||   \\" + NL + "         ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_DAT_Msk ))" + NL + "    {" + NL + "      /*  Set Software Reset for Data Line */" + NL + "/* <<<DD_SDMMC_nonAPI_27_3>>> */" + NL + "      Status = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk);" + NL + "    }" + NL + "    /*  Clear previous error status  */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC003_ALL_ERROR_STATUS_BITMASK ;" + NL + "    if (IssueAbort == 1)" + NL + "    {   " + NL + "      /*  Issue Abort Command.  */" + NL + "      /*  Set argument register */" + NL + "      SDMMC->ARGUMENT1 = SDMMC003_ARGUMENT0;" + NL + "      SDMMC->COMMAND = (uint16_t)(*(uint16_t*)&(SDMMC003_COMMON_COMMAND(12)));  " + NL + "/* Wait for any Interrupt status  bit to set */" + NL + "/* <<<DD_SDMMC_nonAPI_27_4>>> */    " + NL + "    /* Timeout of 5ms.*/" + NL + "      Status =SDMMC003_lCommandDelay(SDMMC003_DELAY_IN_COMMAND);" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "    /* If error status bit is set in the Status register */" + NL + "/* <<<DD_SDMMC_nonAPI_27_5>>> */" + NL + "      if (SDMMC->INT_STATUS_ERR )" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;" + NL + "        SDMMC->INT_STATUS_ERR = SDMMC003_ALL_ERROR_STATUS_BITMASK ;" + NL + "        SDMMC->INT_STATUS_NORM = SDMMC003_ALL_ERROR_STATUS_BITMASK ;" + NL + "         /* Set Software Reset for CMD Line and Data Line  */" + NL + "        SDMMC003_ReturnStatus = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk | \\" + NL + "                                SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk );" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /* Check Data lines status in present status register  */" + NL + "/* <<<DD_SDMMC_nonAPI_27_6>>> */" + NL + "    if (( (SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_DAT_3_0_PIN_LEVEL_Msk) >> \\" + NL + "           SDMMC_PRESENT_STATE_DAT_3_0_PIN_LEVEL_Pos) == SDMMC003_ALL_DATA_LINES_HIGH)" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_RECOVERABLE_ERROR;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status =  (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;" + NL + "    }" + NL + "  } while(0);" + NL + "  /* Enable the Error Interrupt signal */" + NL + "  SDMMC->EN_INT_SIGNAL_ERR |= SDMMC003_ERROR_INT_SIGNAL_ENABLE;" + NL + "" + NL + "  /* Global Error Recovery Variable */" + NL + "  SDMMC003_Handle.ErrorRecoveryStatus = (SDMMC003_ErrorCodesType)Status;" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_28>>> */" + NL + "/*" + NL + " * This function handles the Interrupt in Normal Interrupt Status Register." + NL + " */" + NL + "status_t SDMMC003_lNormalInterruptHandler (uint16_t IntStatus)" + NL + "{" + NL + "  status_t Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "#if SDMMC_CARD_DETECTION_SUPPORT" + NL + "/* <<<DD_SDMMC_nonAPI_28_1>>> */" + NL + "  /* CARD REMOVAL INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_NORM_CARD_REMOVAL_Msk) != 0)" + NL + "  {" + NL + "    /* Confirm that the Card Insertion bit is clear in Present State Status*/" + NL + "    do" + NL + "    {" + NL + "    } while(( SDMMC->PRESENT_STATE &  SDMMC_PRESENT_STATE_CARD_INSERTED_Msk)!= 0);" + NL + "    /* Clear the Interrupt Status bit */" + NL + "    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_CARD_REMOVAL_Msk;" + NL + "    " + NL + "    /* Call back to upper layer function for card removal interrupt*/" + NL + "    if (SDMMC003_Handle.CallBackPtr != NULL)" + NL + "    {" + NL + "      SDMMC003_Handle.CallBackPtr(SDMMC003_CARD_REMOVAL); " + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = SDMMC003_NULL_POINTER;" + NL + "      ERROR(GID_SDMMC00x, Status,0,0);" + NL + "    }" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_28_2>>> */" + NL + "  /* CARD INSERTION INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_NORM_CARD_INS_Msk) != 0)" + NL + "  {" + NL + "    /* Confirm that the Card Insertion bit is set in Present State Status*/" + NL + "    do" + NL + "    {" + NL + "    } while((SDMMC->PRESENT_STATE & SDMMC_PRESENT_STATE_CARD_INSERTED_Msk) == 0);" + NL + "    /* Clear the Interrupt Status */" + NL + "    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_CARD_INS_Msk;" + NL + "" + NL + "    /* Call back to upper layer function for card insertion interrupt*/" + NL + "    if (SDMMC003_Handle.CallBackPtr != NULL)" + NL + "    {" + NL + "      SDMMC003_Handle.CallBackPtr(SDMMC003_CARD_INSERTION); " + NL + "    }" + NL;
  protected final String TEXT_8 = "    else" + NL + "    {" + NL + "      Status = SDMMC003_NULL_POINTER;" + NL + "      ERROR(GID_SDMMC00x, Status,0,0);" + NL + "    }" + NL + "  }" + NL + "#endif" + NL + "/* <<<DD_SDMMC_nonAPI_28_3>>> */" + NL + "  /* BUFFER READ READY INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_NORM_BUFF_READ_READY_Msk) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_BUFFER_READY;" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_BUFF_READ_READY_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.DataFlag = 1;" + NL + "  }" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_28_4>>> */" + NL + "  /* BUFFER WRITE READY INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_NORM_BUFF_WRITE_READY_Msk) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_BUFFER_READY;" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_BUFF_WRITE_READY_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.DataFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_28_5>>> */" + NL + "  /* TRANSFER COMPLETE INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_NORM_TX_COMPLETE_Msk ) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.TransferInterruptError = SDMMC003_TRANSFER_COMPLETE;" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_TX_COMPLETE_Msk;" + NL + "    /* Change the data line Status  to be free */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.TransferFlag = 1;" + NL + "  }" + NL + "  " + NL + "/* <<<DD_SDMMC_nonAPI_28_6>>> */" + NL + "  /* COMMAND COMPLETE INTERRUPT */" + NL + "  if ((IntStatus &  SDMMC_INT_STATUS_NORM_CMD_COMPLETE_Msk) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_COMPLETE;" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_CMD_COMPLETE_Msk;" + NL + "    /* Change the Command Line Status to free */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.CmdFlag = 1;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return (uint32_t)Status;" + NL + "}" + NL + "/* <<<DD_SDMMC_nonAPI_29>>> */" + NL + "/*" + NL + " * This function handles the Interrupt in Error Interrupt Status Register." + NL + " */" + NL + "" + NL + "status_t SDMMC003_lErrorInterruptHandler(uint16_t IntStatus)" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  SDMMC003_ISRContext.InterruptStatusShadow = IntStatus;" + NL + "/* <<<DD_SDMMC_nonAPI_29_1>>> */" + NL + "  /* COMMAND TIMEOUT ERROR INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_TIMEOUT_ERR_Msk)!= 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_TIMEOUT_ERROR;" + NL + "    /* Change the Command Line Status to free */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_CommandErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Forcefully disable the Command Timeout Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;" + NL + "    }" + NL + "   " + NL + "    if (Test_TriggerInterrupt.Trigger_Cmd55Error == TRUE)" + NL + "    {" + NL + "     /* Forcefully disable the Command Timeout Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_Command42Error == TRUE)" + NL + "    {" + NL + "     /* Forcefully disable the Command Timeout Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;" + NL + "    }" + NL + "#endif  /*SDMMC_UVP_TEST*/" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR =  SDMMC_INT_STATUS_ERR_CMD_TIMEOUT_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.CmdFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_2>>> */" + NL + "/* COMMAND CRC ERROR INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_CRC_ERR_Msk ) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_CRC_ERROR;" + NL + "   /* Change the Command Line Status to free */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;" + NL + "   /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_CMD_CRC_ERR_Msk;" + NL + "   /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.CmdFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_3>>> */" + NL + "  /* COMMAND END BIT ERROR INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_END_BIT_ERR_Msk ) != 0)" + NL + "  {" + NL + "   /* Update the Global Variable */" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_ENDBIT_ERROR;" + NL + "   /* Change the Command Line Status to free */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;" + NL + "   /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_CMD_END_BIT_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.CmdFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_4>>> */" + NL + "  /* COMMAND INDEX ERROR INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_IND_ERR_Msk ) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_INDEX_ERROR;" + NL + "    /* Change the Command Line Status to free */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;" + NL + "" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_EraseEndError == TRUE)" + NL + "    {" + NL + "      /* Forcefully disable the Command Index Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;" + NL + "    }" + NL + "    if (Test_TriggerInterrupt.Trigger_EraseStartError == TRUE)" + NL + "    {" + NL + "      /* Forcefully disable the Command Index Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;" + NL + "    }" + NL + "#endif  /*SDMMC_UVP_TEST*/" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_CMD_IND_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.CmdFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_5>>> */" + NL + "  /* DATA TIMEOUT ERROR INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_DATA_TIMEOUT_ERR_Msk) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_DATA_TIMEOUT_ERROR;" + NL + "    /* Change the Data line to free  */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_DATA_TIMEOUT_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.DataFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_6>>> */" + NL + "  /* DATA CRC ERROR INTERRUPT  */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_DATA_CRC_ERR_Msk) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.DataInterruptError = SDMMC003_DATA_CRC_ERROR;" + NL + "    /* Change the Data line to free  */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_DataErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Forcefully trigger the Data Crc Error Interrupt */" + NL + "      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;" + NL + "      /* Enable the Buffer Ready Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_BUFF_READ_READY_EN_Msk;" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN_Msk;" + NL + "" + NL + "       /* Enable the Buffer Ready Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk;" + NL + "      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN_Msk;" + NL + "    }" + NL + "#endif" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_DATA_CRC_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.DataFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_7>>> */" + NL + "  /*DATA END BIT ERROR INTERRUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_DATA_END_BIT_ERR_Msk) != 0)" + NL + "  {" + NL + "   /* Update the Global Variable */" + NL + "   SDMMC003_Handle.DataInterruptError = SDMMC003_DATA_ENDBIT_ERROR;" + NL + "   /* Change the Data line to free  */" + NL + "   SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;" + NL + "   /* Clear the Interrupt Status Bit */" + NL + "   SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_DATA_END_BIT_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.DataFlag = 1;" + NL + "  }" + NL + "/* <<<DD_SDMMC_nonAPI_29_8>>> */" + NL + "  /* ACMD12 ERROR INTERUPT */" + NL + "  if ((IntStatus & SDMMC_INT_STATUS_ERR_ACMD_ERR_Msk) != 0)" + NL + "  {" + NL + "    /* Update the Global Variable */" + NL + "    SDMMC003_Handle.AcmdInterruptError = SDMMC003_ACMD12_ERROR;" + NL + "    /* Change the Cmd line to free  */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;" + NL + "    /* Change the Data line to free  */" + NL + "    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;" + NL + "    /* Clear the Interrupt Status Bit */" + NL + "    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_ACMD_ERR_Msk;" + NL + "    /* Update the Interrupt variable */" + NL + "    SDMMC003_ISRContext.CmdFlag = 1;" + NL + "  }" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_30>>> */" + NL + "/*" + NL + " * This function is use to switch the card state to transferring state if the" + NL + " * card is not in the transferring state." + NL + " */" + NL + "" + NL + "status_t SDMMC003_lSwitchToTransferState()" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  uint32_t Argument = 0;" + NL + "  uint32_t CardStatus = 0UL;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  /* Check the current state of the card */" + NL + "  do" + NL + "  { " + NL + "     Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;" + NL + "    /* Send Cmd13 to read card status  */" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)),Argument, \\" + NL + "                                      SDMMC003_RESPONSE_R1,&CardStatus);" + NL + "/* <<<DD_SDMMC_nonAPI_30_1>>> */" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_30_2>>> */" + NL + "    /* Check if it is in transferring state */" + NL + "    if( (( CardStatus & SDMMC003_CSR_CURRENT_STATE_BITMASK) >>\\" + NL + "                               SDMMC003_CSR_CURRENT_STATE_BITPOS ) ==  \\" + NL + "                               SDMMC003_CSR_CURRENT_STATE_TRANS_VALUE )" + NL + "    {" + NL + "#if SDMMC_UVP_TEST" + NL + "      if ( Test_TriggerInterrupt.Trigger_TransferStateError == TRUE)" + NL + "      {" + NL + "         /* Toggle to the Standby state.*/" + NL + "        Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(7)),Argument, \\" + NL + "                                        SDMMC003_RESPONSE_R1b, &CardStatus);" + NL + "        break;" + NL + "      }" + NL + "#endif" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      break;" + NL + "    }" + NL + "    /* Switch to transfer state i.e. CMD7 */" + NL + "/* <<<DD_SDMMC_nonAPI_30_3>>> */" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(7)),Argument, \\" + NL + "                                   SDMMC003_RESPONSE_R1b, &CardStatus);" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_31>>> */" + NL + "/*" + NL + " * This function performs the data transfer to/from the card ." + NL + " */" + NL + "status_t SDMMC003_lDataTransfer( uint32_t *BufferPtr, \\" + NL + "                              SDMMC003_DataTrasferType TransferMode, \\" + NL + "                              uint32_t QuadBytes)" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  handle_t TimerId;" + NL + "  uint32_t Count = 0;" + NL + "  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "/* Block on Buffer Read/Write Ready Interrupt */" + NL + "/* <<<DD_SDMMC_nonAPI_31_1>>> */" + NL + "    TimerId = SDMMC003_lStartTimer(SDMMC003_RESET_In_DATA_TRANSFER);" + NL + "    if(0 == TimerId)" + NL + "    {" + NL + "      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "      ERROR(GID_SDMMC00x, Status, 0, NULL);  " + NL + "      break;  " + NL + "    }" + NL + "    do" + NL + "    {" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while( SDMMC003_ISRContext.DataFlag == 0);" + NL + "    SDMMC003_lStopTimer(TimerId);" + NL + "    SDMMC003_ISRContext.DataFlag = 0;" + NL + "    /* Check Buffer is ready */" + NL + "/* <<<DD_SDMMC_nonAPI_31_2>>> */" + NL + "    if (SDMMC003_Handle.DataInterruptError == SDMMC003_BUFFER_READY)" + NL + "    {" + NL + "     /* Non-DMA transfer */" + NL + "/*<<<DD_SDMMC_nonAPI_31_7>>> */" + NL + "      /* Data transfer 4bytes in each iteration  */" + NL + "      for (Count=0; Count<QuadBytes; Count++)" + NL + "      {" + NL + "/*<<<DD_SDMMC_nonAPI_31_8>>> */" + NL + "        if (TransferMode == SDMMC003_READ_FROM_BUFF)" + NL + "        {" + NL + "          *BufferPtr  = SDMMC->DATA_BUFFER;" + NL + "        }" + NL + "/*<<<DD_SDMMC_nonAPI_31_9>>> */" + NL + "        if(TransferMode == SDMMC003_WRITE_INTO_BUFF)" + NL + "        {" + NL + "          SDMMC->DATA_BUFFER = *BufferPtr;" + NL + "        }" + NL + "        BufferPtr++;" + NL + "      }" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }/* End of \"if (SDMMC_Handle.DataInterruptError == SDMMC003_BUFFER_READY)\" */" + NL + "/*<<<DD_SDMMC_nonAPI_31_10>>> */" + NL + "    else" + NL + "    {" + NL + "      SDMMC003_Handle.IssueAbort = 1;" + NL + "      Status = SDMMC003_lErrorInterruptRecovery(\\" + NL + "                              SDMMC003_ISRContext.InterruptStatusShadow, \\" + NL + "                              SDMMC003_Handle.IssueAbort);" + NL + "    }" + NL + "  } while(0);" + NL + "  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function checks the PCMD flag." + NL + " */" + NL + "void SDMMC003_CheckPCMDFlag(status_t PCMDFlag)" + NL + "{" + NL + "  SDMMC003_ReturnStatus  = 1UL;" + NL + "  if (PCMDFlag == 1)" + NL + "  {" + NL + "    ERROR(GID_SDMMC00x, SDMMC003_ACMD_BOTH_ERROR,0,0);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    ERROR(GID_SDMMC00x, SDMMC003_ACMD_SD_TRANSFER_ERROR,0,0);" + NL + "  }" + NL + "}" + NL + "" + NL + "/* <<<DD_SDMMC_nonAPI_32>>> */" + NL + "/*" + NL + " * This function performs the ACMD error Recovery." + NL + " */" + NL + "void SDMMC003_lAcmdErrorRecovery()" + NL + "{" + NL + "  status_t Status;" + NL + "  status_t PCMDFlag = 0;" + NL + "  uint32_t CardStatus = 0;" + NL + "  do" + NL + "  {" + NL + "/* <<<DD_SDMMC_nonAPI_32_1>>> */" + NL + "    /** Check Auto CMD12 Not Executed Err in Auto CMd12 Error Status Register */" + NL + "    if ( ((SDMMC->ACMD_ERR_STATUS & SDMMC_ACMD_ERR_STATUS_ACMD12_NOT_EXEC_ERR_Msk) >> \\" + NL + "            SDMMC_ACMD_ERR_STATUS_ACMD12_NOT_EXEC_ERR_Pos)  == 1)" + NL + "    {" + NL + "      /* Set PCMDFlag to 1*/" + NL + "      PCMDFlag = 1;" + NL + "      /* Check Return Status of Recovery function of CMD_wo_DAT command */" + NL + "/* <<<DD_SDMMC_nonAPI_32_2>>> */" + NL + "      if (SDMMC003_Handle.ErrorRecoveryStatus != SDMMC003_RECOVERABLE_ERROR)" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, SDMMC003_NONRECOVERABLE_ERROR,0,0);" + NL + "        break;" + NL + "      }" + NL + "      /* For recoverable error, issue CMD12 */" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(12)), \\" + NL + "                                      SDMMC003_ARGUMENT0, \\" + NL + "                                      SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "      /* No Error */" + NL + "/* <<<DD_SDMMC_nonAPI_32_3>>> */" + NL + "      if (Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, SDMMC003_ACMD_CMD_wo_DAT_ERROR,0,0);" + NL + "        break;" + NL + "      }" + NL + "/* <<<DD_SDMMC_nonAPI_32_4>>> */" + NL + "      /* Non Recoverable Error */" + NL;
  protected final String TEXT_9 = "      if (Status == (uint32_t)SDMMC003_NONRECOVERABLE_ERROR)" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, Status,0,0);" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_32_5>>> */" + NL + "    else" + NL + "    {" + NL + "      /* Set software reset for CMD line */" + NL + "      Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk);" + NL + "      if ( Status !=(uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Issue Cmd 12*/" + NL + "/* <<<DD_SDMMC_nonAPI_32_6>>> */" + NL + "      Status = SDMMC003_lSendCommand(  &(SDMMC003_COMMON_COMMAND(12)), \\" + NL + "                                      SDMMC003_ARGUMENT0, \\" + NL + "                                      SDMMC003_RESPONSE_R1, \\" + NL + "                                      &CardStatus);" + NL + "      /* Non Recoverable Error */" + NL + "/* <<<DD_SDMMC_nonAPI_32_7>>> */" + NL + "      if (Status == (uint32_t)SDMMC003_NONRECOVERABLE_ERROR)" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, Status,0,0);" + NL + "        break;" + NL + "      }" + NL + "    }" + NL + "    /*Set Software Reset for  Data line*/" + NL + "    Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk);" + NL + "    if ( Status !=(uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_32_8>>> */" + NL + "    /*Check Command Not issued by Auto CMD12 Error */" + NL + "    if (((SDMMC->ACMD_ERR_STATUS & SDMMC_ACMD_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR_Msk) >> \\" + NL + "            SDMMC_ACMD_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR_Pos) == 1)" + NL + "    {" + NL + "      ERROR(GID_SDMMC00x, SDMMC003_ACMD_CMD_wo_DAT_NOT_ISSUED,0,0);" + NL + "    }" + NL + "/* <<<DD_SDMMC_nonAPI_32_9>>> */" + NL + "    else" + NL + "    {" + NL + "     /* Check PCMD flag.If 1 means that An error occurred in CMD_wo_DAT," + NL + "      *  and also occurred in the SD memory transfer */" + NL + "      SDMMC003_CheckPCMDFlag(PCMDFlag);" + NL + "    }" + NL + "  } while(0);" + NL + "}" + NL + "" + NL + "void Timer_CallBack(void* Temp)" + NL + "{" + NL + "  if (Temp != NULL)" + NL + "  {" + NL + "    SDMMC003_ReturnStatus = (status_t)Temp;" + NL + "  }" + NL + "  SDMMC003_Handle.TimerExpire =0;" + NL + "}" + NL + "" + NL + "" + NL + "/* <<< DD_SDMMC_nonAPI_33 >>> */" + NL + "/**" + NL + " * This function is used to some delay." + NL + " */" + NL + "void SDMMC003_lDelay(uint32_t DelayTime)" + NL + "{" + NL + "  handle_t TimerId;" + NL + "  status_t Status;" + NL + "  SDMMC003_Handle.TimerExpire = 1;" + NL + "  TimerId = SYSTM001_CreateTimer(DelayTime,SYSTM001_ONE_SHOT,Timer_CallBack,NULL);" + NL + "  if(TimerId != 0)" + NL + "  {" + NL + "    /* Timer is created successfully */" + NL + "    Status = SYSTM001_StartTimer(TimerId);" + NL + "    if(Status == DAVEApp_SUCCESS)" + NL + "    {" + NL + "      /* Wait in infinite loop till the timer expires */" + NL + "      while(SDMMC003_Handle.TimerExpire)" + NL + "      {" + NL + "      }" + NL + "      /* stop the timer */" + NL + "      Status = SYSTM001_StopTimer(TimerId);" + NL + "      /* Delete the Timer*/" + NL + "      if(Status == DAVEApp_SUCCESS)" + NL + "      {" + NL + "        SDMMC003_ReturnStatus = SYSTM001_DeleteTimer(TimerId);" + NL + "      } /* End of \" if(Status == DAVEApp_SUCCESS)\"*/" + NL + "    } /* End of \" if(Status == DAVEApp_SUCCESS)\"*/" + NL + "  }/* End of \"if(TimerId != 0)\" */" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_nonAPI_34 >>>" + NL + " *  SDMMC Interrupt Handler */" + NL + "void SDMMC0_0_IRQHandler()" + NL + "{" + NL + "  uint32_t Status;" + NL + "  NormalIntStatus = SDMMC->INT_STATUS_NORM;" + NL + "  ErrorIntStatus  = SDMMC->INT_STATUS_ERR;" + NL + "/* <<< DD_SDMMC_nonAPI_34_1 >>> */" + NL + "  if (NormalIntStatus & SDMMC_INT_STATUS_NORM_ERR_INT_Msk)" + NL + "  {" + NL + "    Status = SDMMC003_lErrorInterruptHandler( ErrorIntStatus );" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      ERROR(GID_SDMMC00x, Status,0,0);" + NL + "    }" + NL + "  }" + NL + "/* <<< DD_SDMMC_nonAPI_34_2 >>> */" + NL + "  if(NormalIntStatus & SDMMC003_NORMAL_INT_STATUS_BITS)" + NL + "  {" + NL + "    Status = SDMMC003_lNormalInterruptHandler( NormalIntStatus);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      ERROR(GID_SDMMC00x, Status,0,0);" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "/* <<< DD_SDMMC_nonAPI_36 >>> */" + NL + "/*" + NL + " * This function performs the card initialization and identification operation." + NL + " */" + NL + "status_t SDMMC003_lCardIdentificationProcess()" + NL + "{" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  handle_t TimerId = 0;" + NL + "  /* Silicon Testing Added */" + NL + "  do" + NL + "  {" + NL + "/* <<< DD_SDMMC_nonAPI_36_1 >>> */" + NL + "   /* Wait till the Internal clock gets Stable.*/" + NL + "    TimerId = SDMMC003_lStartTimer(SDMMC003_CLOCK_STABLE_DELAY);" + NL + "    if(0 == TimerId)" + NL + "    {" + NL + "      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;" + NL + "      ERROR(GID_SDMMC00x, Status, 0, NULL);  " + NL + "      break; " + NL + "    }" + NL + "    do" + NL + "    {" + NL + "      if (SDMMC003_Handle.TimerExpire == 0)" + NL + "      {" + NL + "        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }" + NL + "    } while((SDMMC->CLOCK_CTRL & SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_STABLE_Msk ) == 0);" + NL + "    SDMMC003_lStopTimer(TimerId);    " + NL + "    if (Status == (uint32_t)SDMMC003_TIMEOUT_OCCURED )" + NL + "    {" + NL + "      break; " + NL + "    }" + NL + "    /* Enable the SD clock */" + NL + "    SDMMC->CLOCK_CTRL |= SDMMC_CLOCK_CTRL_SDCLOCK_EN_Msk;" + NL + "    /* Set Power Control Register */" + NL + "    SET_BIT( SDMMC->POWER_CTRL, SDMMC_POWER_CTRL_SD_BUS_POWER_Pos);" + NL + "/* <<< DD_SDMMC_nonAPI_36_2 >>> */    " + NL + "    if(SDMMC003_Handle.InitializeFlag == 0)" + NL + "    {" + NL + "      Status  = SDMMC003_lInitializeCard();" + NL + "/* <<< DD_SDMMC_nonAPI_36_3 >>> */    " + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }/* End of \" if( Status != DAVEApp_SUCCESS )\"*/" + NL + "      Status = SDMMC003_lAfterCardInitialize();" + NL + "/* <<< DD_SDMMC_nonAPI_36_4 >>> */  " + NL + "      if( Status != (uint32_t)DAVEApp_SUCCESS )" + NL + "      {" + NL + "        ERROR(GID_SDMMC00x, Status, 0, NULL);" + NL + "        break;" + NL + "      }/* End of \"if(Status != DAVEApp_SUCCESS )\" */" + NL + "    }/* End of \"if((SDMMC003_Handle.State & SDMMC003_STATE_CARD_INITIALIZED)== 0 )\"*/" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_nonAPI_37 >>> */" + NL + "/**" + NL + " * This function is used to create and start timer in NON-RTOS environment." + NL + " */" + NL + "handle_t SDMMC003_lStartTimer(uint32_t DelayTime)" + NL + "{" + NL + "  handle_t TimerId;" + NL + "  status_t Status;" + NL + "  SDMMC003_Handle.TimerExpire = 1;" + NL + "  TimerId = SYSTM001_CreateTimer(DelayTime,SYSTM001_ONE_SHOT,Timer_CallBack,NULL);" + NL + "/* <<< DD_SDMMC_nonAPI_37_1 >>> */" + NL + "  if(TimerId != 0)" + NL + "  {" + NL + "    /* Timer is created successfully */" + NL + "    Status = SYSTM001_StartTimer(TimerId);" + NL + "/* <<< DD_SDMMC_nonAPI_37_2 >>> */" + NL + "    if(DAVEApp_SUCCESS != Status)" + NL + "    {" + NL + "      /*Delete Timer*/" + NL + "      SDMMC003_ReturnStatus = SYSTM001_DeleteTimer(TimerId);" + NL + "      TimerId = 0;" + NL + "    }" + NL + "  }" + NL + "  return TimerId;" + NL + "}" + NL + "" + NL + "/* <<< DD_SDMMC_nonAPI_38 >>> */" + NL + "/**" + NL + " * This function is used to stop timer in NON-RTOS environment." + NL + " */" + NL + "void SDMMC003_lStopTimer(handle_t TimerId)" + NL + "{" + NL + "  status_t Status;" + NL + "  /* stop the timer */" + NL + "  Status = SYSTM001_StopTimer(TimerId);" + NL + "  /* Delete the Timer*/" + NL + "/* <<< DD_SDMMC_nonAPI_38_1 >>> */" + NL + "  if(Status == DAVEApp_SUCCESS)" + NL + "  {" + NL + "    SDMMC003_ReturnStatus = SYSTM001_DeleteTimer(TimerId);" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "/* <<< DD_SDMMC_nonAPI_39 >>> */" + NL + "/**" + NL + " * This function is used to check the sector address is out of bound or not." + NL + " */" + NL + "status_t SDMMC003_lCheckSectorBound (uint32_t SectorNumberParam, \\" + NL + "                                     uint32_t SectorCountParam)" + NL + "{" + NL + "  status_t Status;" + NL + "  uint32_t SectorCount = 0;" + NL + "  do" + NL + "  {" + NL + "/* Get Sector Count function   */  " + NL + "/* <<< DD_SDMMC_nonAPI_39_1 >>> */" + NL + "    Status = SDMMC003_GetSectorCount((void *)&SectorCount);" + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "/* <<< DD_SDMMC_nonAPI_39_2 >>> */" + NL + "/* Check the Sector Count limit */" + NL + "    if((SectorNumberParam + SectorCountParam) >= SectorCount)" + NL + "    {" + NL + "      Status = (uint32_t)SDMMC003_SECTOR_OUT_OF_BOUND;" + NL + "    }" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * The function performs the actual erase operation." + NL + " */" + NL + "status_t SDMMC003_lLocalErase" + NL + "(" + NL + "  uint32_t StartAddr," + NL + "  uint32_t EndAddr," + NL + "  uint32_t TimeoutVal" + NL + ")" + NL + "{" + NL + "  /* Stores the response received  */" + NL + "  uint32_t CardStatus = 0;" + NL + "  status_t Status = (uint32_t)SDMMC003_ERROR;" + NL + "  do" + NL + "  {" + NL + "  /* <<<DD_SDMMC_API_7_3>>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)" + NL + "    {" + NL + "      StartAddr *= 512UL;" + NL + "      EndAddr *=  512UL;" + NL + "    }/*End of \"if((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)\" */" + NL + "  /* MMC Card */" + NL + "#if SDMMC_SUPPORT_MMC_CARD" + NL + "/* <<<DD_SDMMC_API_7_4>>> */" + NL + "    if ((SDMMC003_Handle.CardType & SDMMC003_MMC) != 0 )" + NL + "    {" + NL + "/* Erase Start Command */" + NL + "#if SDMMC_UVP_TEST" + NL + "      if (Test_TriggerInterrupt.Trigger_EraseStartError == TRUE)" + NL + "      {" + NL + "        /* Forcefully trigger the Command Index Error Interrupt */" + NL + "        /* Disable the Command Complete Status Interrupt */" + NL + "        SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "        /* Disable the Command Complete Signal Interrupt */" + NL + "        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "      }" + NL + "#endif" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_MMC_COMMAND(35)),\\" + NL + "                                              StartAddr, RESPONSE_R1, &CardStatus );" + NL + "/* <<<DD_SDMMC_API_7_5>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        break;" + NL + "      }" + NL + "      /* Erase End Command */" + NL + "#if SDMMC_UVP_TEST" + NL + "      if (Test_TriggerInterrupt.Trigger_EraseEndError == TRUE)" + NL + "      {" + NL + "        /* Disable the Command Complete Status Interrupt */" + NL + "        SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "        /* Disable the Command Complete Signal Interrupt */" + NL + "        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "      }" + NL + "#endif" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_MMC_COMMAND(36)),EndAddr, \\" + NL + "                                             RESPONSE_R1,&CardStatus );" + NL + "/* <<<DD_SDMMC_API_7_6>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "         break;" + NL + "      }" + NL + "    }" + NL + "    /* SD Card */" + NL + "    else" + NL + "#endif /* SDMMC_SUPPORT_MMC_CARD */" + NL + "    {" + NL + "#if SDMMC_UVP_TEST" + NL + "      if (Test_TriggerInterrupt.Trigger_EraseStartError == TRUE)" + NL + "      {" + NL + "        /* Forcefully trigger the Command Index Error Interrupt */" + NL + "      //  SDMMC->FORCE_EVENT_ERR_STATUS = 0x0004 ;" + NL + "        /* Disable the Command Complete Status Interrupt */" + NL + "        SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "        /* Disable the Command Complete Signal Interrupt */" + NL + "        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "      }" + NL + "#endif" + NL + "/* <<<DD_SDMMC_API_7_7>>> */" + NL + "      /* SD Erase Start Command */" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(32)), \\" + NL + "                                              StartAddr, SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "         break;" + NL + "      } /* if (Status != (uint32_t)DAVEApp_SUCCESS) */" + NL + "      /* SD Erase End Command */" + NL + "#if SDMMC_UVP_TEST" + NL + "      if (Test_TriggerInterrupt.Trigger_EraseEndError == TRUE)" + NL + "      {" + NL + "        /* Forcefully trigger the Command Index Error Interrupt */" + NL + "     //   SDMMC->FORCE_EVENT_ERR_STATUS = 0x0004 ;" + NL + "        /* Disable the Command Complete Status Interrupt */" + NL + "        SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);" + NL + "        /* Disable the Command Complete Signal Interrupt */" + NL + "        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );" + NL + "      }" + NL + "#endif" + NL + "      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(33)),EndAddr, \\" + NL + "                                      SDMMC003_RESPONSE_R1, &CardStatus);" + NL + "/* <<<DD_SDMMC_API_7_8>>> */" + NL + "      if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "         break;" + NL + "      }/* End of \" if (Status != (uint32_t)DAVEApp_SUCCESS)\"*/" + NL + "    }/* End of \"if SD card\"*/" + NL + "#if SDMMC_UVP_TEST" + NL + "    if (Test_TriggerInterrupt.Trigger_DataErrorInterrupt == TRUE)" + NL + "    {" + NL + "      /* Disable the Transfer Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);" + NL + "      /* Disable the Transfer Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk  );" + NL + "    }" + NL + "" + NL + "    if (Test_TriggerInterrupt.Trigger_TransferInterruptError == TRUE)" + NL + "    {" + NL + "      /* Disable the Transfer Complete Status Interrupt */" + NL + "      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);" + NL + "      /* Disable the Transfer Complete Signal Interrupt */" + NL + "      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk  );" + NL + "    }" + NL + "#endif" + NL + "    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(38))," + NL + "                                    SDMMC003_ARGUMENT0," + NL + "                                    SDMMC003_RESPONSE_R1b," + NL + "                                    &CardStatus);   " + NL + "    if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "       break;" + NL + "    }/* End of \" if (Status != (uint32_t)DAVEApp_SUCCESS)\"*/" + NL + "    SDMMC003_lDelay(TimeoutVal * 1000);" + NL + "  } while(0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*CODE_BLOCK_END*/" + NL + NL + NL + NL + NL + NL;
  protected final String TEXT_10 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/sdmmc003/"; 
     int appInst = 0; 
     int RTOS = app.getIntegerValue(AppBaseuri + appInst + "/sdmmc003_rtos_present");
   int BusWidth = app.getIntegerValue(AppBaseuri + appInst + "/sdmmc003_data_lines/0"); 

    stringBuffer.append(TEXT_2);
    stringBuffer.append(app.getAppVersion(AppBaseuri) );
    stringBuffer.append(TEXT_3);
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(TEXT_8);
    stringBuffer.append(TEXT_9);
    stringBuffer.append(TEXT_10);
    return stringBuffer.toString();
  }
}
