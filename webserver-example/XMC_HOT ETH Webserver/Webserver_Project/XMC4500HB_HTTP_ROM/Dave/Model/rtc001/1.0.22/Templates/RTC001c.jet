<%@ jet package="CodeGenerator" class="rtc001c_template"
imports="java.util.* com.ifx.davex.appjetinteract.App2JetInterface" %>
<% App2JetInterface app = (App2JetInterface) argument; %>

/*CODE_BLOCK_BEGIN[RTC001.c]*/

 /*******************************************************************************
 Copyright (c) 2011, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : App Developer                                                   **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : Feb 12, 2013                                           **
**                                                                            **
*******************************************************************************/
/*******************************************************************************
**                      Author(s) Identity                                    **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** RP        App Developer                                                    **
**                                                                            **
*******************************************************************************/
<% String AppBaseuri = "app/RTC001/0";%> 

<% int Is4Device = -1; %>
<% int Is1Device = -1; %>
<% Is4Device = ((app.getSoftwareId().substring(0,1).compareTo("4")==0)?1:0); %>
<% Is1Device = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); %>

/**
 * @file RTC001.c
 *
 * @App Version RTC001 <<%=app.getAppVersion(AppBaseuri) %>>
 *
 * @brief  Real Time Clock App Implementation.
 *
 */
/*******************************************************************************
 ** INCLUDE FILES                                                             **
 ******************************************************************************/

<% String UserFunc = null;%>
/* Inclusion of header file */
#include <DAVE3.h>

<% String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } %>

<% if (!DBGApp) { %>  
/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/ 
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e) 
#define DBG002_IG(e,g) 
#define DBG002_IH(e,h) 
#define DBG002_IP(e,p) 
#define DBG002_IGH(e,g,h) 
#define DBG002_IGP(e,g,p) 
#define DBG002_IHP(e,h,p) 
#define DBG002_IGHP(e,g,h,p) 
#define DBG002_N(e) 
#define DBG002_NG(e,g) 
#define DBG002_NH(e,h) 
#define DBG002_NP(e,p) 
#define DBG002_NGH(e,g,h) 
#define DBG002_NGP(e,g,p) 
#define DBG002_NHP(e,h,p) 
#define DBG002_NGHP(e,g,h,p) 
#define DBG002_ID(e) 
#define DBG002_IS(e) 
#define DBG002_ISG(e,g) 
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status) 
#define DBG002_FUNCTION_EXIT(GID, Status) 

#endif/* End of defintions of dummy Debug Log macros*/
<% } %>                  
 
#define APP_GID DBG002_GID_RTC001
/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/


/*******************************************************************************
**                      Private Type Definitions                              **
*******************************************************************************/
<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>
/** 
 * Note: This part of the code will be generated if Software Timer is
 *       enabled. This part is not reviewed and tested
 **/
/**
 * This enumerates the timer state.
 */
typedef enum RTC001_TimerStateType{
/**
 * The timer is in running state
 */
  TIMER_STATE_RUNNING,
/**
  * The timer is stopped
 */
  TIMER_STATE_STOPPED 
}RTC001_TimerStateType;
<% } else {
 }%>

/*******************************************************************************
**                 Private Function Declarations:
*******************************************************************************/
 <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>		
 /** 
  * Note: This part of the code will be generated if Software Timer is
  *       enabled. This part is not reviewed and tested
  **/
/*
 * This function is called to insert a timer into the timer list.  
 *        
 * @param[in]  Index Timer ID
 * @return     none
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lInsertTimerList (uint32_t Index);


/*
 * This function is called to remove a timer from the timer list. 
 *              
 * @param[in]  Index Timer ID
 * @return     none
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lRemoveTimerList(uint32_t Index);

/*
 * Handler function called from Seconds event handler. 
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lTimerHandler (void);
 
/*
 * Time event handler 
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void RTC001_SecondsEvent_Handler(uint32_t CbArg);
<% } else {
 }%>

/*
 * Function to check whether the date is valid
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static uint32_t RTC001_ldatevalid(uint16_t m, uint16_t d, uint16_t y);


/*
 * Function to calculate day of the week
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static uint32_t RTC001_lweekday(uint16_t m, uint16_t d, uint16_t y);

/*
 *  Initialization function for the app. Configures the registers
 *  based on options selected in UI.
 *
 * @return     void
 *
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lInit(const RTC001_HandleType* Handle);

/*******************************************************************************
**                      Global Constant Definitions                           **
*******************************************************************************/



/*******************************************************************************
**                      Global Variable Definitions                           **
*******************************************************************************/
<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>
/** 
 * Note: This part of the code will be generated if Software Timer is
 *       enabled. This part is not reviewed and tested
 **/
/** Table which save timer control block. */
RTC001_TimerObject    RTC001_TimerTbl[RTC001_CFG_MAX_TMR] = {{0}};

/** The header of the TimerCtrl list.      */
RTC001_TimerObject*  RTC001_TimerList = 0; 

/**   Timer ID Tracker  */
uint32_t       RTC001_TimerTracker = 0;
<% } else {
 }%>

/*******************************************************************************
**                      Private Constant Definitions                          **
*******************************************************************************/
const uint32_t RTC001_DAYS_IN_MONTH[13] =
{
   /* Index from 1, hence skip 0*/
    0U,
    /*Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec*/
       31U,28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U
};
#define RTC001_DAYS_IN_AN_YEAR     (365U)
#define RTC001_SECONDS_IN_A_DAY    (24U * 60U * 60U)
#define RTC001_SECONDS_IN_AN_HOUR  (60U * 60U)
#define RTC001_SECONDS_IN_A_MINUTE (60U)
#define RTC001_EPOCH_YEAR          (1970U)
/*******************************************************************************
**                 Function like macro definitions                            **
*******************************************************************************/



/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/
 
 <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					
 /** 
  * Note: This part of the code will be generated if Software Timer is
  *       enabled. This part is not reviewed and tested
  **/
/*
 * This function is called to insert a timer into the timer list.
 */
static void  RTC001_lInsertTimerList (uint32_t Index)
{
  /* <<<DD_RTC001_PRIV_API_1>>> */
  RTC001_TimerObject* TmrObjPtr;
  int32_t DeltaTicks;
  uint32_t TempTmrCnt;
   /* Get timer time */
  TempTmrCnt = RTC001_TimerTbl[Index].TimerCount;
  /* Check if timer count is zero */
  /* <<<DD_RTC001_PRIV _API_1>>> */
  do
  {
    if(TempTmrCnt == 0)                  
    {
      break;                                          
    }
    /* Check if Timer list is NULL */
    if(RTC001_TimerList == NULL)                
    {
      /* Set this as first Timer */
        RTC001_TimerList = &RTC001_TimerTbl[Index];       
    }
    /* IF Not, find the correct place ,and insert the specified timer */
    else                  
    {								    
      TmrObjPtr = RTC001_TimerList; 
      /* Get timer tick */
      DeltaTicks = (int32_t)TempTmrCnt;           
      /* Find correct place for inserting the timer */
      while(TmrObjPtr != NULL)
      {				    
        /* Get timer Count Difference  */
        DeltaTicks -= (int32_t)TmrObjPtr->TimerCount;
        /* Is delta ticks<0? */
        if(DeltaTicks < 0)            
        {	
          /*  Check If head item */
          if(TmrObjPtr->TimerPrev!= NULL)
          {	
            /* If Insert to list */
            TmrObjPtr->TimerPrev->TimerNext = &RTC001_TimerTbl[Index]; 
            RTC001_TimerTbl[Index].TimerPrev = TmrObjPtr->TimerPrev;
            RTC001_TimerTbl[Index].TimerNext = TmrObjPtr;
            TmrObjPtr->TimerPrev = &RTC001_TimerTbl[Index];
          }
          else                    	
          { 
            /* Set Timer as first item */
            RTC001_TimerTbl[Index].TimerNext = RTC001_TimerList;
            RTC001_TimerList->TimerPrev = &RTC001_TimerTbl[Index];
            RTC001_TimerList = &RTC001_TimerTbl[Index];
          }
          RTC001_TimerTbl[Index].TimerCount = RTC001_TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;  
          RTC001_TimerTbl[Index].TimerNext->TimerCount  -= RTC001_TimerTbl[Index].TimerCount; 
          break;	
        }
        /* Is last item in list? */									
        else 
        {	
          if((DeltaTicks >= 0) && (TmrObjPtr->TimerNext == NULL))
          {
            /* Yes,insert into */
            RTC001_TimerTbl[Index].TimerPrev = TmrObjPtr;
            TmrObjPtr->TimerNext = &RTC001_TimerTbl[Index];	
            RTC001_TimerTbl[Index].TimerCount = (uint32_t)DeltaTicks;
            break;
          }
        }
        /* Get the next item in timer list    */	
        TmrObjPtr = TmrObjPtr->TimerNext;      
      }
    }
  }while(0);
}

/*
 * This function is called to remove a timer from the timer list. 
 */
static void  RTC001_lRemoveTimerList(uint32_t Index)
{
  /* <<<DD_RTC001_PRIV_API_2>>> */
  RTC001_TimerObject* TmrObjPtr;
  TmrObjPtr = &RTC001_TimerTbl[Index];
  /* Check whether only one timer available */
  /* <<<DD_RTC001_PRIV _API_2>>> */
  if((TmrObjPtr->TimerPrev == NULL) && (TmrObjPtr->TimerNext == NULL))
  {		
    /* set timer list as NULL */ 
    RTC001_TimerList = NULL;                 	
  }
   /* Check if the first item in timer list   */
  else if(TmrObjPtr->TimerPrev == NULL)     
  {   
    /* Remove timer from list,and reset timer list */
    RTC001_TimerList  = TmrObjPtr->TimerNext;
    RTC001_TimerList->TimerPrev = NULL;
    TmrObjPtr->TimerNext->TimerCount += TmrObjPtr->TimerCount;
    TmrObjPtr->TimerNext    = NULL;  
  }
  /* Check if the last item in timer list   */
  else if(TmrObjPtr->TimerNext == NULL)      
  {
    /* Remove timer from list */
    TmrObjPtr->TimerPrev->TimerNext = NULL;	
    TmrObjPtr->TimerPrev = NULL;
  }
  else                                /*  remove timer from list         */
  {
    /*  Remove timer from list */
    TmrObjPtr->TimerPrev->TimerNext  =  TmrObjPtr->TimerNext;
    TmrObjPtr->TimerNext->TimerPrev  =  TmrObjPtr->TimerPrev;
    TmrObjPtr->TimerNext->TimerCount  += TmrObjPtr->TimerCount;
    TmrObjPtr->TimerNext = NULL;
    TmrObjPtr->TimerPrev = NULL;
  }
}

/*
 * Handler function  called from RTC event handler. 
 */
static void  RTC001_lTimerHandler (void)
{
  /* <<<DD_RTC001_PRIV_API_3>>> */
  RTC001_TimerObject* TmrObjPtr;
   /* Get first item of timer list       */
  TmrObjPtr = RTC001_TimerList;         
  /* <<<DD_RTC001_PRIV _API_3>>> */  
  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0) )
  {	
    /* Check whether timer is a one shot timer */
    if(TmrObjPtr->TimerType == RTC001_ONE_SHOT)
    {
      /* Yes,remove this timer from timer list */
      RTC001_lRemoveTimerList(TmrObjPtr->TimerID);
      /* Set timer status as TIMER_STATE_STOPPED */
      TmrObjPtr->TimerState = TIMER_STATE_STOPPED;
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
    }
    /* Check whether timer is RTC001_PERIODIC */
    else if(TmrObjPtr->TimerType == RTC001_PERIODIC)
    {
      /* Yes,remove this timer from timer list */
      RTC001_lRemoveTimerList(TmrObjPtr->TimerID);
      /* Reset timer tick             */
      TmrObjPtr->TimerCount = TmrObjPtr->TimerReload;
      /* Insert timer into timer list */
      RTC001_lInsertTimerList(TmrObjPtr->TimerID);
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
    }
    else
    {
      break;
    }
    /* Get first item of timer list */
      TmrObjPtr = RTC001_TimerList;	                      
  }
}

/*
 *  Event Handler 
 */

static void RTC001_SecondsEvent_Handler(uint32_t CbArg)
{ 
  /* <<<DD_RTC001_PRIV_API_4>>> */
  RTC001_TimerObject* TmrObjPtr;

  TmrObjPtr = RTC001_TimerList;
  /* <<<DD_RTC001_PRIV _API_4>>> */
  do
  {
    if(TmrObjPtr == NULL)
    {
      break;
    }
    else
    {
      if(TmrObjPtr->TimerCount >= 1)
      {
        TmrObjPtr->TimerCount--;
      }
      else
      {
        RTC001_lTimerHandler();
      }
    }
  }while(0);
}
<% } else {
 }%>

/*
 *  Initialization function for the app. Configures the registers
 *  based on options selected in UI.
 */ 

static void  RTC001_lInit(const RTC001_HandleType* Handle)
{

  status_t status = (uint32_t) DAVEApp_SUCCESS;  
  <%if (Is1Device==1){%>
  uint32_t DelayCount = 0x3FFUL;
  <%}%>	  
   /* <<<DD_RTC001_API_1>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY); 
   
  <%if (Is1Device==1){%>
  /* To disable gating for RTC : RTC Gating Clear  */ 
  WR_REG(SCU_CLK->CLKCR,SCU_CLK_CLKCR_CNTADJ_Msk,SCU_CLK_CLKCR_CNTADJ_Pos,DelayCount);
  SCU_GENERAL->PASSWD = 0x000000C0UL;
  SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_RTC_Pos);
  while(SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk);
  SCU_GENERAL->PASSWD = 0x000000C3UL;
  <%}%>	  
<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					   
  /* Initialize the header of the list */
  RTC001_TimerList     = NULL; 
  /*   Initialize timer tracker  */
  RTC001_TimerTracker = 0;
<% } else { }%>

  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR = \
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  
  if ((((RTC->CTR & RTC_CTR_ENB_Msk) >> RTC_CTR_ENB_Pos) == 0U ) ||\
    (Handle->RTCInitOnce != 1U))
  {
     /* RTC disabled to set the time */
     status = RTC001_Disable();
     /*assert status = DAVEApp_SUCCESS*/
     DBG002_I (status = DAVEApp_SUCCESS);
     /* Calendar time and date set in RTC registers */
     status |= RTC001_Clock_SetTime(&timeptr1);
     /*assert status = DAVEApp_SUCCESS*/
     DBG002_I (status = DAVEApp_SUCCESS);

  }

  <%if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/enb") == 1) { %>  
  /* Enable the RTC module */
  RTC->CTR |= ((uint32_t)(RTC_CTR_ENB_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;	
  
	<% }  else {  }%>	
  <%if (Is4Device==1){%>
	  <%if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/tae") == 1) { %>  
	  /*Enable wake up from hibernate mode on an RTC alarm event*/
	  RTC->CTR |= ((uint32_t)(RTC_CTR_TAE_Msk));  
	  /* Wait for Mirror register update and clear the update indication */
	  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
	  {}
	  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;   
	  <% }  else { }
	  if (app.getIntegerValue(AppBaseuri + "/rtc/msksr/mai") == 1) { %>    

	  /* Enable interrupt on alarm event  */
	  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MAI_Pos) & RTC_MSKSR_MAI_Msk);
	  <%}%>
  <% } else {%> 
	  <%if (app.getIntegerValue(AppBaseuri + "/rtc/msksr/mai") == 1) { %>    

	  /* Enable interrupt on alarm event  */
	  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MAI_Pos) & RTC_MSKSR_MAI_Msk); 
	  <%}%>
  <%}%>
     
  <%if (Is4Device==1){%> 
  /* Enable RTC alarm interrupt in SCU */
  SCU_INTERRUPT->SRMSK |= SCU_INTERRUPT_SRMSK_AI_Msk;
  <%}%> 
    
  <%if (Is4Device==1){%> 	
	<%if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/esec") == 1) { %>  
  /*Enable wake up from hibernate mode on periodic second event*/
  RTC->CTR |=((uint32_t)(RTC_CTR_ESEC_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;
	<% }  else {
     }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/emic") ==1) {%>
  /*Enable wake up from hibernate mode on periodic minute event*/
  RTC->CTR |=((uint32_t)(RTC_CTR_EMIC_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;
	<% } else {}
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/ehoc") ==1) {%>
  /*Enable wake up from hibernate mode on periodic hour event*/
  RTC->CTR |=((uint32_t)(RTC_CTR_EHOC_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;
	<% } else { }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/edac") ==1) {%>
  /*Enable wake up from hibernate mode on periodic day event*/
  RTC->CTR |=((uint32_t)(RTC_CTR_EDAC_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;
	<% } else { }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/emoc") ==1) {%>
  /*Enable wake up from hibernate mode on periodic month event*/
  RTC->CTR |=((uint32_t)(RTC_CTR_EMOC_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;
	<% } else { }
	if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/eyec") ==1) {%>
  /*Enable wake up from hibernate mode on periodic year event*/
  RTC->CTR |=((uint32_t)(RTC_CTR_EYEC_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;
	<% } else {}%>
  /*configure RTC prescaler*/
  WR_REGHIB(RTC->CTR, RTC_CTR_DIV_Msk, RTC_CTR_DIV_Pos, \
           (uint32_t)Handle->DividerValue, SCU_INTERRUPT_SRRAW_RTC_CTR_Msk);	   
  <%}%> 	    
  <%if (Is1Device==1){%> 
  /*configure RTC prescaler*/ 
  WR_REG(RTC->CTR, RTC_CTR_DIV_Msk, RTC_CTR_DIV_Pos,(uint32_t)Handle->DividerValue);
  <%}%> 

   <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					     
	/* Enable seconds when Software timer is enabled */
  if(Handle->SoftwareTimerSel == SOFTWARE_TIMER_ENABLE)
  {
	  RTC->MSKSR |= (((uint32_t)1U << RTC_MSKSR_MPSE_Pos) & RTC_MSKSR_MPSE_Msk);
	  <%if (Is4Device==1){%> 
	   NVIC_SCU001_RegisterCallback(NVIC_SCU001_PI,RTC001_SecondsEvent_Handler,0);
	  <% } else {%> 
	   NVIC_SR101_RegisterCallback(NVIC_SR101_PI,RTC001_SecondsEvent_Handler,0);
	  <%}%>
  } 
  else
  {
	<% } else { }%>
  <%int pi_count = 0;
  if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpse") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>					
  
  /* Enable periodic seconds interrupt */
  RTC->MSKSR |= (((uint32_t)1U << RTC_MSKSR_MPSE_Pos) & RTC_MSKSR_MPSE_Msk);
  <% pi_count = pi_count + 1;
	} else { }
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpmi") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
  
  /* Enable periodic minutes interrupt */
  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPMI_Pos) & RTC_MSKSR_MPMI_Msk);
  <% pi_count = pi_count + 1;
	} else { }
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpho") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
  
  /* Enable periodic hours interrupt */
  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPHO_Pos) & RTC_MSKSR_MPHO_Msk);
  <% pi_count = pi_count + 1;
	} else {}
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpda") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
  
  /* Enable periodic days interrupt */
  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPDA_Pos) & RTC_MSKSR_MPDA_Msk);
  <% pi_count = pi_count + 1;
	} else {}
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpmo") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
  
  /* Enable periodic months interrupt */
  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPMO_Pos) & RTC_MSKSR_MPMO_Msk);
  <% pi_count = pi_count + 1;
	} else {}
	if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpye") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
  
  /* Enable periodic years interrupt */
  RTC->MSKSR |=(((uint32_t)1U << RTC_MSKSR_MPYE_Pos) & RTC_MSKSR_MPYE_Msk);
  <% pi_count = pi_count + 1;
	} else { }%> 	
  <%if (pi_count > 0)%>  
  <%if (Is4Device==1){%> 
  /* Enable RTC periodic interrupt in SCU */
  SCU_INTERRUPT->SRMSK |= (uint32_t)SCU_INTERRUPT_SRMSK_PI_Msk;  
  <%}%>  
  <%String EventHandlerTimer = app.getStringValue(AppBaseuri +"/RTC001_srwTimerUserFunction");
  if((EventHandlerTimer != null) && (EventHandlerTimer != "")) 
  { 
    if (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1) 
    { 
      if (app.getIntegerValue(AppBaseuri + "/RTC001_Eventtrigger_timer/0") == 1) 
      { %> 
    
  /* Register User defined Event Handler for Timer function */  
  <%if (Is4Device==1){%> 
  NVIC_SCU001_RegisterCallback(NVIC_SCU001_PI,<%=EventHandlerTimer%>,0U);
  <% } else {%> 
  NVIC_SR101_RegisterCallback(NVIC_SR101_PI,<%=EventHandlerTimer%>,0U);
  <%}%>
  
     <% } 
     }
  }%>
  <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>
  }
  <% } else { }%>
  <%String EventHandlerAlarm1 = app.getStringValue(AppBaseuri +"/RTC001_srwAlarmUserFunction"); 
  if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwAlarmIntrptEna/0") == 1)) 
  { 
    if((EventHandlerAlarm1 != null) && (EventHandlerAlarm1 != "") && (app.getIntegerValue(AppBaseuri + "/RTC001_Eventtrigger_Alarm/0") == 1)) 
    { %>
      
  /* Configure RTC alarm and register the call back function */  
  status |= RTC001_ConfigAlarm(&RTC001_Handle,&Alarmptr1,<%=EventHandlerAlarm1%>,0U);
 <% }
    else { %>
   
  /* Configure RTC alarm (Call back function is NULL) */  
  status |= RTC001_ConfigAlarm(&RTC001_Handle,&Alarmptr1,NULL,0U); 
   <% } 
  } %> 
  if (status != (uint32_t)DAVEApp_SUCCESS)
  {
    DBG002_ERROR(APP_GID,status, 0, NULL);
  }
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
}


/**
 *@}
 */

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/


/** @ingroup RTC001_publicparam
 * @{
 */

/*
 *  Initialization function for the app. Configures the registers
 *  based on options selected in UI.
 */
void RTC001_Init()
{
	RTC001_lInit(&RTC001_Handle);

}

/*
 *  Deinitialization function which initializes the App internal data
 *  structures to default values. 
 */
void  RTC001_DeInit(void)
{
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_2>>> */
	
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
}


/*
 *  The function enables the RTC module.
 */
status_t  RTC001_Enable(void)
{
  status_t status = (uint32_t) RTC001_ERROR;
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_3>>> */
 
  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR |= (uint32_t)\
    (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk |\
  	SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  /* Enable RTC module */
  RTC->CTR |= (uint32_t)(RTC_CTR_ENB_Msk);
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;	
  
  status = (uint32_t) DAVEApp_SUCCESS;	
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  The function disables the RTC module.
 */
 
status_t  RTC001_Disable(void)	
{
  status_t status = (uint32_t) RTC001_ERROR;
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_4>>> */

  /* Disable the RTC module*/
  RTC->CTR &= (uint32_t) (~(RTC_CTR_ENB_Msk));
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;	

  /* Clear the RTC Time registers */
  <%if (Is4Device==1){%>  
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
  {}
  RTC->TIM0 = 0x00000000U;
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)
  {}
  RTC->TIM1 = 0x00000000U;
  <% } else {%> 
  while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk))!= 0x0U)
  {}
  RTC->TIM0 = 0x00000000U; 
  RTC->TIM1 = 0x00000000U;
  <%}%>  
  /* Clear the Alarm registers */
  <%if (Is4Device==1){%>
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)
  {}
  RTC->ATIM0 = 0x00000000U;
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)
  {}
  RTC->ATIM1 = 0x00000000U; 
  <% } else {%>  
  while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk))!= 0x0U)
  {}
  RTC->ATIM0 = 0x00000000U;  
  RTC->ATIM1 = 0x00000000U;
  <%}%>	
  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR |= (uint32_t)\
    (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk |\
  	SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  	SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);    
  							
  status = (uint32_t)DAVEApp_SUCCESS;
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  The function gets RTC status flag for Alarm and Periodic Timer Events.
 */	
status_t  RTC001_GetFlagStatus(RTC001_FlagType Flag)
{
  status_t status = (uint32_t) RTC001_RESET;
  uint32_t TempValue = 0U;
  /* <<<DD_RTC001_API_6>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);

  /*read the Status Service Request Register*/
  TempValue = RTC->STSSR;
  
  /*check the given flag*/
	if((TempValue & (uint32_t) Flag) != 0U)
	{
	  status = (uint32_t) RTC001_SET;
	}

	DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
	return status;
}


/*
 *  The function clears RTC status flag for Alarm and Periodic Timer Events.
 */
void  RTC001_ClearFlagStatus(RTC001_FlagType Flag)
{
  /* <<<DD_RTC001_API_5>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  
  /*write to the Clear Service Request Register*/
  RTC->CLRSR |= (uint32_t)Flag;

	DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
}

<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					
/*
 *  Interface for creating a new software Timer instance.
 */
handle_t RTC001_CreateTimer
(
  uint32_t Period,
  RTC001_TimerType TimerType, 
  RTC001_TimerCallBackPtr TimerCallBack, 
  void  * pCallBackArgPtr
)
{
  uint8_t TimerID = 0;
  uint8_t Count = 0;
  /* <<<DD_RTC001_API_7>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check for input parameter */
    if((TimerType != RTC001_ONE_SHOT) && (TimerType != RTC001_PERIODIC))
    {
      DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);
      break;	
    }
    if(TimerCallBack == NULL)
    {
      DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);
      break;
    }
    for(Count = 0; Count < RTC001_CFG_MAX_TMR; Count++)
    {
      /* Check for free timer ID */
      if((RTC001_TimerTracker & ((uint32_t)1U << Count)) == 0) 
      {
        /* If yes,assign ID to this timer      */
        RTC001_TimerTracker |= ((uint32_t)1U << Count);   
         /* Initialize timer as per input values */
        RTC001_TimerTbl[Count].TimerID     = Count;     
        RTC001_TimerTbl[Count].TimerType   = TimerType;	
        RTC001_TimerTbl[Count].TimerState  = TIMER_STATE_STOPPED;
        RTC001_TimerTbl[Count].TimerCount    = Period;
        RTC001_TimerTbl[Count].TimerReload	= Period;
        RTC001_TimerTbl[Count].TimerCallBack = TimerCallBack;
        RTC001_TimerTbl[Count].ParamToCallBack = pCallBackArgPtr;
        RTC001_TimerTbl[Count].TimerPrev   = NULL;
        RTC001_TimerTbl[Count].TimerNext   = NULL;
        TimerID = Count + 1;
        break;               
      }
    }  
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return TimerID;                
}  

/*
 *  Interface to start the software timer .
 */
status_t RTC001_StartTimer(handle_t  Handle) 
{
  uint32_t Error = RTC001_ERROR;
  /* <<<DD_RTC001_API_9>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check validity of parameter        */
    if(Handle > RTC001_CFG_MAX_TMR)
    {
        Error = RTC001_INVALID_HANDLE;
        DBG002_ERROR(APP_GID,Error, 0, NULL);
        break;
    }
    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)
    {
        Error = RTC001_INVALID_HANDLE;
        DBG002_ERROR(APP_GID,Error, 0, NULL);
        break;
    }
    /* Check if timer is running */    
    if(RTC001_TimerTbl[(Handle - 1)].TimerState != TIMER_STATE_RUNNING)   
    {
      /* set timer status as TIMER_STATE_RUNNING */
      RTC001_TimerTbl[(Handle - 1)].TimerState = TIMER_STATE_RUNNING;
      /* Insert this timer into timer list  */
      RTC001_lInsertTimerList((Handle - 1));     
    }       
    Error = DAVEApp_SUCCESS;                    
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return Error;
}


/*
 *  Interface to stop the software timer.
 */
status_t RTC001_StopTimer(handle_t Handle) 
{
  uint32_t Error = RTC001_ERROR;
  /* <<<DD_RTC001_API_10>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check validity of parameter        */
    if(Handle > RTC001_CFG_MAX_TMR)
    {
      Error = RTC001_INVALID_HANDLE;
      DBG002_ERROR(APP_GID,Error, 0, NULL);
      break;
    }
    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)
    {
      Error = RTC001_INVALID_HANDLE;
      DBG002_ERROR(APP_GID,Error, 0, NULL);
      break;
    }
    /* Check whether Timer is in Stop state */
    if(RTC001_TimerTbl[(Handle - 1)].TimerState != TIMER_STATE_STOPPED)
    {
      /* remove Timer from node list */
      RTC001_lRemoveTimerList((Handle - 1));
  
      /* Set timer status as TIMER_STATE_STOPPED  */
      RTC001_TimerTbl[(Handle - 1)].TimerState = TIMER_STATE_STOPPED;
    }	
    Error = DAVEApp_SUCCESS;              
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return Error;
}

/*
 *  Function to delete the Timer instance.
 */
status_t RTC001_DeleteTimer(handle_t Handle) 
{
  uint32_t Error = RTC001_ERROR;
  /* <<<DD_RTC001_API_8>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check validity of parameter        */
    if(Handle > RTC001_CFG_MAX_TMR)
    {
      Error = RTC001_INVALID_HANDLE;
      DBG002_ERROR(APP_GID,Error, 0, NULL);
      break;
    }
    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)
    {
      Error = RTC001_INVALID_HANDLE;
      DBG002_ERROR(APP_GID,Error, 0, NULL);
      break;
    }
    /* Check if timer is running */
    if(RTC001_TimerTbl[(Handle - 1)].TimerState == TIMER_STATE_RUNNING) 
    {
        /* Yes,remove this timer from timer list*/
        RTC001_lRemoveTimerList((Handle - 1));         
    }
    /* Release resource that this timer hold*/
    RTC001_TimerTracker &=~((uint32_t)1U << (Handle - 1));     
    Error = DAVEApp_SUCCESS;           
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return Error;
}
<% } else {
 }%>

/*
 *  Interface to configure the RTC alarm.
 */

status_t RTC001_ConfigAlarm (const RTC001_HandleType* Handle, 
    RTC001_TimeHandle* timeptr, AlarmCallBackPtr CallBack,uint32_t CbArg)
{
  uint16_t m1 = 0U,y1 = 0U,d1 = 0U;
  status_t status = (uint32_t)RTC001_ERROR;
  /* <<<DD_RTC001_API_11>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  do
  {
    /* <<<DD_RTC001 _API_4>>> */
    /* Clear Mirror register update status of RTC registers in SCU*/
    SCU_INTERRUPT->SRCLR = (uint32_t)\
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
    <% if (app.getIntegerValue(AppBaseuri + "/RTC001_Eventtrigger_Alarm/0") == 1) %>
    <% { %>  	

    /* Register the call back function with NVIC_SCU001 */		
    if(CallBack != NULL)
    {    
	    <%if (Is4Device==1){%>
	    NVIC_SCU001_RegisterCallback(NVIC_SCU001_AI,CallBack,CbArg);
	    <% } else {%>
	    NVIC_SR101_RegisterCallback(NVIC_SR101_AI,CallBack,CbArg);
	    <%}%>
	  }
    <% } %> 
    /*   Write values into ATIM0 and ATIM1 registers  */
    m1 = timeptr->Month;
    y1 = timeptr->Year;
    d1 = timeptr->Days;
    /* Check whether the date entered is valid */
    if (RTC001_ldatevalid(m1,d1,y1))
    { 
      <%if (Is4Device==1){%>
      /*Wait until any transfer over serial interface to ATIM0 is completed*/   
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)
      {}   
      /*Configure the Alarm Time Register 0 */
      RTC->ATIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \
              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \
                                  (uint32_t)RTC_ATIM0_AMI_Msk) | \
            ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & \
                                  (uint32_t)RTC_ATIM0_AHO_Msk) | \
        (((((uint32_t)timeptr->Days)-1U) << RTC_ATIM0_ADA_Pos) & \
                                  (uint32_t)RTC_ATIM0_ADA_Msk));

      /*Wait until any transfer over serial interface to ATIM1 is completed*/        
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)
      {}   
      /*Configure the Alarm Time Register 1 */
      RTC->ATIM1 = (uint32_t)\
           ((((((uint32_t)timeptr->Month)-1U) << RTC_ATIM1_AMO_Pos) & \
                                       (uint32_t)RTC_ATIM1_AMO_Msk) | \
        ((uint32_t)(((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos) & \
                                       (uint32_t)RTC_ATIM1_AYE_Msk));
      <% } else {%>
       /*Wait until any transfer over serial interface to ATIM0 and ATIM1 is completed*/
       while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk))!= 0x0U)
       {}   
       /*Configure the Alarm Time Register 0 */
       RTC->ATIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \
              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \
                                  (uint32_t)RTC_ATIM0_AMI_Msk) | \
            ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & \
                                  (uint32_t)RTC_ATIM0_AHO_Msk) | \
        (((((uint32_t)timeptr->Days)-1U) << RTC_ATIM0_ADA_Pos) & \
                                  (uint32_t)RTC_ATIM0_ADA_Msk));        
       /*Configure the Alarm Time Register 1 */
       RTC->ATIM1 = (uint32_t)\
           ((((((uint32_t)timeptr->Month)-1U) << RTC_ATIM1_AMO_Pos) & \
                                       (uint32_t)RTC_ATIM1_AMO_Msk) | \
        ((uint32_t)(((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos) & \
                                       (uint32_t)RTC_ATIM1_AYE_Msk));	
      <%}%> 				       
      status = (uint32_t)DAVEApp_SUCCESS;   
    }  
    else /*date is not valid*/
    {
      status = (uint32_t)RTC001_INVALID_HANDLE;
      DBG002_ERROR(APP_GID,status, 0, NULL);
    }
 
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
}
	

/*
 *  Function to read the current RTC time
 */
 
status_t RTC001_Clock_GetTime (RTC001_TimeHandle* timeptr)
{
  status_t status = (uint32_t)RTC001_ERROR;
  uint32_t temp0,temp1;
  temp0 = RTC->TIM0;
  temp1 = RTC->TIM1;
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_12>>> */

  /*   Read values from TIM0 and TIM1 registers  */
  /*   Days of Week value  */
	timeptr->DaWe = (uint8_t)(temp1 & RTC_TIM1_DAWE_Msk);
  /*   Month value  */
	timeptr->Month = \
          (uint8_t)(((temp1 & RTC_TIM1_MO_Msk) >> RTC_TIM1_MO_Pos) + 1U);
  /*   Year value  */
	timeptr->Year = (uint16_t)((temp1 & RTC_TIM1_YE_Msk) >> RTC_TIM1_YE_Pos);

  /*   Seconds value  */
	timeptr->Sec =  (uint8_t)((temp0 & RTC_TIM0_SE_Msk));
  /*   Minutes value  */
	timeptr->Min = (uint8_t)(((temp0 & RTC_TIM0_MI_Msk) >> RTC_TIM0_MI_Pos));
  /*   Hours value  */
	timeptr->Hours = (uint8_t)(((temp0 & RTC_TIM0_HO_Msk) >> RTC_TIM0_HO_Pos));
  /*   Days value starting from the 1st day of the month */
	timeptr->Days = \
          (uint8_t)(((temp0 & RTC_TIM0_DA_Msk) >> RTC_TIM0_DA_Pos) + 1U);
	status = (uint32_t)DAVEApp_SUCCESS;
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  This function is to set the time.
 */
status_t RTC001_Clock_SetTime(RTC001_TimeHandle* timeptr)
{
  uint16_t m1 = 0U,y1 = 0U,d1 = 0U;
  uint32_t weekDay = 0U;
  status_t status = (uint32_t)RTC001_ERROR;
  
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_13>>> */
  


  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR = \
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
 
  /*   Days of Week value  */
  m1 = timeptr->Month;
  y1 = timeptr->Year;
  d1 = timeptr->Days;
  
  do
  {    
    if (RTC001_ldatevalid(m1,d1,y1))
    { 
      weekDay = ((uint32_t)(RTC001_lweekday(m1,d1,y1)));
      if(weekDay < 6U)
      {
        weekDay += 1U;
      }
      else if(weekDay == 6U)
      {
        weekDay = 0U;
      }
      else
      {
        status = (uint32_t)RTC001_INVALID_HANDLE;
        DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);
        break;
      }
      /*Write values into TIM0 and TIM1 registers  */
      /*wait until any serial transaction is completed*/
      <%if (Is4Device==1){%>      
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
      {}
      /*Configure RTC Time register 0*/
      RTC->TIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \
              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \
                                  (uint32_t)RTC_TIM0_MI_Msk) | \
            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \
                                  (uint32_t)RTC_TIM0_HO_Msk) | \
      ((((((uint32_t)timeptr->Days)-1U)) << RTC_TIM0_DA_Pos) & \
                                  (uint32_t)RTC_TIM0_DA_Msk));      
      /*wait until any serial transaction is completed*/
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)
      {}     
      /*Configure RTC Time register 1*/
      RTC->TIM1 = (uint32_t) (weekDay |\
                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \
                                              (uint32_t)RTC_TIM1_MO_Msk) | \
                         ((((uint32_t)timeptr->Year) << RTC_TIM1_YE_Pos) & \
                                              (uint32_t)RTC_TIM1_YE_Msk));
      <% } else {%>       
      while((SCU_GENERAL->MIRRSTS & (SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk | SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk))!= 0x0U)
      {}
      /*Configure RTC Time register 0*/
      RTC->TIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \
              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \
                                  (uint32_t)RTC_TIM0_MI_Msk) | \
            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \
                                  (uint32_t)RTC_TIM0_HO_Msk) | \
      ((((((uint32_t)timeptr->Days)-1U)) << RTC_TIM0_DA_Pos) & \
                                  (uint32_t)RTC_TIM0_DA_Msk));  
      /*Configure RTC Time register 1*/
      RTC->TIM1 = (uint32_t) (weekDay |\
                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \
                                              (uint32_t)RTC_TIM1_MO_Msk) | \
                         ((((uint32_t)timeptr->Year) << RTC_TIM1_YE_Pos) & \
                                              (uint32_t)RTC_TIM1_YE_Msk));      
      <%}%>      
      status = (uint32_t) DAVEApp_SUCCESS;
    }  
    else
    {
      status = (uint32_t) RTC001_INVALID_HANDLE;
      DBG002_ERROR(APP_GID,status, 0, NULL);
    }
  }while(0);

  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  This function is to get the time in seconds calculated from Epoch time (01/01/1970).
 */

status_t RTC001_Time(time_t* time_value)
{

  uint32_t CurrentYear = 0U, ElapsedYear = 0U;
  uint32_t CurrentMonth = 0U, ElapsedMonth = 0U;
  uint32_t CurrentDay = 0U, ElapsedDays = 0U;
  uint32_t CurrentHour = 0U;
  uint32_t CurrentMin = 0U;
  uint32_t CurrentSec = 0U;
  uint32_t ElapsedSeconds = 0U;
  status_t Status = (uint32_t)RTC001_ERROR; 
  
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_15>>> */
  
  /*check if RTC module is enabled and no NULL pointer*/
  if(((RTC->CTR & (RTC_CTR_ENB_Msk)) != 0U) && (time_value != NULL))
  {

    /*   Read values from TIM0 and TIM1 registers  */
    CurrentYear = ((uint32_t)((RTC->TIM1 & RTC_TIM1_YE_Msk) >> 16U));
    CurrentMonth = 	((uint32_t)(((RTC->TIM1 & RTC_TIM1_MO_Msk) >> 8U) + 1U));
    CurrentDay = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_DA_Msk) >> 24U) + 1U));
    CurrentHour = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_HO_Msk) >> 16U)));
    CurrentMin = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_MI_Msk) >> 8U)));
    CurrentSec = ((uint32_t)((RTC->TIM0 & RTC_TIM0_SE_Msk)));
    
    /*Count number of Days for Elapsed Years since Epoch*/
    ElapsedDays = (uint32_t)(CurrentYear - RTC001_EPOCH_YEAR) *\
                  (uint32_t) RTC001_DAYS_IN_AN_YEAR;

    /* Add the number of days to be adjusted for leap years, 
    start from previous year and check backwords */
    for (ElapsedYear=(CurrentYear-1U); ElapsedYear>= 1970U; ElapsedYear--)
    {
      if((((ElapsedYear) % 400U) == 0U) || \
        ((((ElapsedYear) % 100U) != 0U) && (((ElapsedYear) %4U) == 0U)))
      {
        ElapsedDays++;
      }
    }
    /*if current year is leap year add 1 only if March or later*/
    if((((CurrentYear) % 400U) == 0U) || \
      ((((CurrentYear) % 100U) != 0U) && (((CurrentYear) %4U) == 0U)))
    {
      if(CurrentMonth > 2U)
      {
        ElapsedDays++;
      }
    }
    
    /*Add number of Days from Elapsed months from current year*/
    for (ElapsedMonth = (CurrentMonth - 1U); ElapsedMonth != 0U; ElapsedMonth--)
    {
      ElapsedDays += RTC001_DAYS_IN_MONTH[ElapsedMonth];  
    } 
    
    /*add Elapsed days from current month*/
    ElapsedDays += CurrentDay - 1U;
    
    /*Accumulate the total seconds for ElapsedDays*/
    ElapsedSeconds = (ElapsedDays * RTC001_SECONDS_IN_A_DAY);

    /*Add seconds for current hour, minute and seconds*/
    ElapsedSeconds += (CurrentHour * RTC001_SECONDS_IN_AN_HOUR);   
    ElapsedSeconds += (CurrentMin * RTC001_SECONDS_IN_A_MINUTE); 
    ElapsedSeconds += CurrentSec; 

    *time_value = (time_t) ElapsedSeconds;
    Status = (uint32_t) DAVEApp_SUCCESS;
    
  }
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return Status;
}
/* return 1 if date is valid, 0 otherwise.	*/
static uint32_t RTC001_ldatevalid(uint16_t m,uint16_t d,uint16_t y)
{
  uint32_t valid = 0U;

  if ((m == 0U) || (m > 12U) )
  {
    valid = 0U;
  }
  else  if ((m != 2U) || (d < 29U))
  {
     if (d <= RTC001_DAYS_IN_MONTH[m])
     {
       valid = 1U;
     }
  }
  else /*reaches here only if m = February and day = 29*/
  {
    /*check if it is leap year*/
    if ((((y) % 400U) == 0U) || ((((y) % 100U) != 0U) && (((y) %4U) == 0U)))
    {
      if (d == 29U)
      { 
        valid = 1U;
      }
    }
  }
  return valid;
}

/* given month, day, year, returns day of week, eg. Monday = 0 etc.
*/ 

static uint32_t RTC001_lweekday(uint16_t m,uint16_t d,uint16_t y)
{
  uint16_t vx, tx, ix, feb;
  const uint8_t vx_list[] = 
  {
      0U, 20U, 0U, 16U, 24U, 20U, 0U, 24U, 4U, 12U, 8U, 16U, 12U
  };

  vx = vx_list[m];
  if(y > 1900U)
  {
    y = y - 1900U;
  }
  feb = (m  > 2U)? 1U : 0U;
/* take care of February */
  ix = ((y - 21U) % 28U) + vx + feb;
/* take care of leap year */
  tx = ((ix + (ix / 4U)) % 7U) + d;
  tx = tx % 7U;
  return ((uint32_t)tx);
}

/**
 *@}
 */

/*CODE_BLOCK_END*/
